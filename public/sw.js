/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./app/sw.ts":
/*!*******************!*\
  !*** ./app/sw.ts ***!
  \*******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var serwist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! serwist */ \"./node_modules/serwist/dist/index.js\");\n\nconst serwist = new serwist__WEBPACK_IMPORTED_MODULE_0__.Serwist({\n    precacheEntries: [\n        ...undefined || []\n    ],\n    skipWaiting: true,\n    clientsClaim: true,\n    navigationPreload: true,\n    runtimeCaching: [\n        {\n            matcher: (param)=>{\n                let { request } = param;\n                return request.destination === \"image\";\n            },\n            handler: new serwist__WEBPACK_IMPORTED_MODULE_0__.StaleWhileRevalidate({\n                cacheName: \"images\"\n            })\n        },\n        {\n            matcher: (param)=>{\n                let { request } = param;\n                return request.destination === \"script\" || request.destination === \"style\";\n            },\n            handler: new serwist__WEBPACK_IMPORTED_MODULE_0__.NetworkFirst({\n                cacheName: \"static-resources\",\n                networkTimeoutSeconds: 3\n            })\n        },\n        {\n            matcher: (param)=>{\n                let { url } = param;\n                return url.pathname.startsWith(\"/api/\");\n            },\n            handler: new serwist__WEBPACK_IMPORTED_MODULE_0__.StaleWhileRevalidate({\n                cacheName: \"map-tiles\",\n                plugins: [\n                    {\n                        cacheWillUpdate: async (param)=>{\n                            let { response } = param;\n                            return response.status === 200 ? response : null;\n                        }\n                    }\n                ]\n            })\n        },\n        {\n            matcher: (param)=>{\n                let { request } = param;\n                return request.mode === \"navigate\";\n            },\n            handler: new serwist__WEBPACK_IMPORTED_MODULE_0__.NetworkFirst({\n                cacheName: \"pages\",\n                networkTimeoutSeconds: 3\n            })\n        }\n    ]\n});\nserwist.addEventListeners();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                /* unsupported import.meta.webpackHot */ undefined.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hcHAvc3cudHMiLCJtYXBwaW5ncyI6Ijs7QUFDc0U7QUFTdEUsTUFBTUcsVUFBVSxJQUFJRiw0Q0FBT0EsQ0FBQztJQUMxQkcsaUJBQWlCO1dBQUtDLEtBQUtDLGFBQWEsSUFBSSxFQUFFO0tBQUU7SUFDaERDLGFBQWE7SUFDYkMsY0FBYztJQUNkQyxtQkFBbUI7SUFDbkJDLGdCQUFnQjtRQUNkO1lBQ0VDLFNBQVM7b0JBQUMsRUFBRUMsT0FBTyxFQUFFO3VCQUFLQSxRQUFRQyxXQUFXLEtBQUs7O1lBQ2xEQyxTQUFTLElBQUlaLHlEQUFvQkEsQ0FBQztnQkFBRWEsV0FBVztZQUFTO1FBQzFEO1FBQ0E7WUFDRUosU0FBUztvQkFBQyxFQUFFQyxPQUFPLEVBQUU7dUJBQUtBLFFBQVFDLFdBQVcsS0FBSyxZQUFZRCxRQUFRQyxXQUFXLEtBQUs7O1lBQ3RGQyxTQUFTLElBQUlkLGlEQUFZQSxDQUFDO2dCQUN4QmUsV0FBVztnQkFDWEMsdUJBQXVCO1lBQ3pCO1FBQ0Y7UUFDQTtZQUNFTCxTQUFTO29CQUFDLEVBQUVNLEdBQUcsRUFBRTt1QkFBS0EsSUFBSUMsUUFBUSxDQUFDQyxVQUFVLENBQUM7O1lBQzlDTCxTQUFTLElBQUlaLHlEQUFvQkEsQ0FBQztnQkFDaENhLFdBQVc7Z0JBQ1hLLFNBQVM7b0JBQ1A7d0JBQ0VDLGlCQUFpQjtnQ0FBTyxFQUFFQyxRQUFRLEVBQUU7bUNBQU1BLFNBQVNDLE1BQU0sS0FBSyxNQUFNRCxXQUFXOztvQkFDakY7aUJBQ0Q7WUFDSDtRQUNGO1FBQ0E7WUFDRVgsU0FBUztvQkFBQyxFQUFFQyxPQUFPLEVBQUU7dUJBQUtBLFFBQVFZLElBQUksS0FBSzs7WUFDM0NWLFNBQVMsSUFBSWQsaURBQVlBLENBQUM7Z0JBQUVlLFdBQVc7Z0JBQVNDLHVCQUF1QjtZQUFFO1FBQzNFO0tBQ0Q7QUFDSDtBQUVBYixRQUFRc0IsaUJBQWlCIiwic291cmNlcyI6WyIvaG9tZS9ueXgvV29ya3NwYWNlL09zdWMvVWJpQ2F0ZS12Mi9hcHAvc3cudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBQcmVjYWNoZUVudHJ5LCBTZXJ3aXN0R2xvYmFsQ29uZmlnIH0gZnJvbSBcInNlcndpc3RcIjtcbmltcG9ydCB7IE5ldHdvcmtGaXJzdCwgU2Vyd2lzdCwgU3RhbGVXaGlsZVJldmFsaWRhdGUgfSBmcm9tIFwic2Vyd2lzdFwiO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXb3JrZXJHbG9iYWxTY29wZSBleHRlbmRzIFNlcndpc3RHbG9iYWxDb25maWcge1xuICAgIF9fU1dfTUFOSUZFU1Q6IChQcmVjYWNoZUVudHJ5IHwgc3RyaW5nKVtdIHwgdW5kZWZpbmVkO1xuICB9XG59XG5kZWNsYXJlIGNvbnN0IHNlbGY6IFNlcnZpY2VXb3JrZXJHbG9iYWxTY29wZTtcblxuY29uc3Qgc2Vyd2lzdCA9IG5ldyBTZXJ3aXN0KHtcbiAgcHJlY2FjaGVFbnRyaWVzOiBbLi4uKHNlbGYuX19TV19NQU5JRkVTVCB8fCBbXSldLFxuICBza2lwV2FpdGluZzogdHJ1ZSxcbiAgY2xpZW50c0NsYWltOiB0cnVlLFxuICBuYXZpZ2F0aW9uUHJlbG9hZDogdHJ1ZSxcbiAgcnVudGltZUNhY2hpbmc6IFtcbiAgICB7XG4gICAgICBtYXRjaGVyOiAoeyByZXF1ZXN0IH0pID0+IHJlcXVlc3QuZGVzdGluYXRpb24gPT09IFwiaW1hZ2VcIixcbiAgICAgIGhhbmRsZXI6IG5ldyBTdGFsZVdoaWxlUmV2YWxpZGF0ZSh7IGNhY2hlTmFtZTogXCJpbWFnZXNcIiB9KSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG1hdGNoZXI6ICh7IHJlcXVlc3QgfSkgPT4gcmVxdWVzdC5kZXN0aW5hdGlvbiA9PT0gXCJzY3JpcHRcIiB8fCByZXF1ZXN0LmRlc3RpbmF0aW9uID09PSBcInN0eWxlXCIsXG4gICAgICBoYW5kbGVyOiBuZXcgTmV0d29ya0ZpcnN0KHtcbiAgICAgICAgY2FjaGVOYW1lOiBcInN0YXRpYy1yZXNvdXJjZXNcIixcbiAgICAgICAgbmV0d29ya1RpbWVvdXRTZWNvbmRzOiAzLFxuICAgICAgfSksXG4gICAgfSxcbiAgICB7XG4gICAgICBtYXRjaGVyOiAoeyB1cmwgfSkgPT4gdXJsLnBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvYXBpL1wiKSxcbiAgICAgIGhhbmRsZXI6IG5ldyBTdGFsZVdoaWxlUmV2YWxpZGF0ZSh7XG4gICAgICAgIGNhY2hlTmFtZTogXCJtYXAtdGlsZXNcIixcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNhY2hlV2lsbFVwZGF0ZTogYXN5bmMgKHsgcmVzcG9uc2UgfSkgPT4gKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwID8gcmVzcG9uc2UgOiBudWxsKSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSksXG4gICAgfSxcbiAgICB7XG4gICAgICBtYXRjaGVyOiAoeyByZXF1ZXN0IH0pID0+IHJlcXVlc3QubW9kZSA9PT0gXCJuYXZpZ2F0ZVwiLFxuICAgICAgaGFuZGxlcjogbmV3IE5ldHdvcmtGaXJzdCh7IGNhY2hlTmFtZTogXCJwYWdlc1wiLCBuZXR3b3JrVGltZW91dFNlY29uZHM6IDMgfSksXG4gICAgfSxcbiAgXSxcbn0pO1xuXG5zZXJ3aXN0LmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4iXSwibmFtZXMiOlsiTmV0d29ya0ZpcnN0IiwiU2Vyd2lzdCIsIlN0YWxlV2hpbGVSZXZhbGlkYXRlIiwic2Vyd2lzdCIsInByZWNhY2hlRW50cmllcyIsInNlbGYiLCJfX1NXX01BTklGRVNUIiwic2tpcFdhaXRpbmciLCJjbGllbnRzQ2xhaW0iLCJuYXZpZ2F0aW9uUHJlbG9hZCIsInJ1bnRpbWVDYWNoaW5nIiwibWF0Y2hlciIsInJlcXVlc3QiLCJkZXN0aW5hdGlvbiIsImhhbmRsZXIiLCJjYWNoZU5hbWUiLCJuZXR3b3JrVGltZW91dFNlY29uZHMiLCJ1cmwiLCJwYXRobmFtZSIsInN0YXJ0c1dpdGgiLCJwbHVnaW5zIiwiY2FjaGVXaWxsVXBkYXRlIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJtb2RlIiwiYWRkRXZlbnRMaXN0ZW5lcnMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./app/sw.ts\n"));

/***/ }),

/***/ "./node_modules/idb/build/index.js":
/*!*****************************************!*\
  !*** ./node_modules/idb/build/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: () => (/* binding */ deleteDB),\n/* harmony export */   openDB: () => (/* binding */ openDB),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlDQUF5QyxJQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVUsSUFBSTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRXlDIiwic291cmNlcyI6WyIvaG9tZS9ueXgvV29ya3NwYWNlL09zdWMvVWJpQ2F0ZS12Mi9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGluc3RhbmNlT2ZBbnkgPSAob2JqZWN0LCBjb25zdHJ1Y3RvcnMpID0+IGNvbnN0cnVjdG9ycy5zb21lKChjKSA9PiBvYmplY3QgaW5zdGFuY2VvZiBjKTtcblxubGV0IGlkYlByb3h5YWJsZVR5cGVzO1xubGV0IGN1cnNvckFkdmFuY2VNZXRob2RzO1xuLy8gVGhpcyBpcyBhIGZ1bmN0aW9uIHRvIHByZXZlbnQgaXQgdGhyb3dpbmcgdXAgaW4gbm9kZSBlbnZpcm9ubWVudHMuXG5mdW5jdGlvbiBnZXRJZGJQcm94eWFibGVUeXBlcygpIHtcbiAgICByZXR1cm4gKGlkYlByb3h5YWJsZVR5cGVzIHx8XG4gICAgICAgIChpZGJQcm94eWFibGVUeXBlcyA9IFtcbiAgICAgICAgICAgIElEQkRhdGFiYXNlLFxuICAgICAgICAgICAgSURCT2JqZWN0U3RvcmUsXG4gICAgICAgICAgICBJREJJbmRleCxcbiAgICAgICAgICAgIElEQkN1cnNvcixcbiAgICAgICAgICAgIElEQlRyYW5zYWN0aW9uLFxuICAgICAgICBdKSk7XG59XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkge1xuICAgIHJldHVybiAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgfHxcbiAgICAgICAgKGN1cnNvckFkdmFuY2VNZXRob2RzID0gW1xuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5hZHZhbmNlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZSxcbiAgICAgICAgICAgIElEQkN1cnNvci5wcm90b3R5cGUuY29udGludWVQcmltYXJ5S2V5LFxuICAgICAgICBdKSk7XG59XG5jb25zdCB0cmFuc2FjdGlvbkRvbmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHByb21pc2lmeVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSh3cmFwKHJlcXVlc3QucmVzdWx0KSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignc3VjY2VzcycsIHN1Y2Nlc3MpO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH0pO1xuICAgIC8vIFRoaXMgbWFwcGluZyBleGlzdHMgaW4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlIGJ1dCBkb2Vzbid0IGV4aXN0IGluIHRyYW5zZm9ybUNhY2hlLiBUaGlzXG4gICAgLy8gaXMgYmVjYXVzZSB3ZSBjcmVhdGUgbWFueSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm9taXNlLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih0eCkge1xuICAgIC8vIEVhcmx5IGJhaWwgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGEgZG9uZSBwcm9taXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIGlmICh0cmFuc2FjdGlvbkRvbmVNYXAuaGFzKHR4KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHR4LmVycm9yIHx8IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0RXJyb3InLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgfSk7XG4gICAgLy8gQ2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICB0cmFuc2FjdGlvbkRvbmVNYXAuc2V0KHR4LCBkb25lKTtcbn1cbmxldCBpZGJQcm94eVRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdHJhbnNhY3Rpb24uZG9uZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnZG9uZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRG9uZU1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIE1ha2UgdHguc3RvcmUgcmV0dXJuIHRoZSBvbmx5IHN0b3JlIGluIHRoZSB0cmFuc2FjdGlvbiwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBtYW55LlxuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdzdG9yZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1sxXVxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IHJlY2VpdmVyLm9iamVjdFN0b3JlKHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2UgdHJhbnNmb3JtIHdoYXRldmVyIHdlIGdldCBiYWNrLlxuICAgICAgICByZXR1cm4gd3JhcCh0YXJnZXRbcHJvcF0pO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24gJiZcbiAgICAgICAgICAgIChwcm9wID09PSAnZG9uZScgfHwgcHJvcCA9PT0gJ3N0b3JlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wIGluIHRhcmdldDtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHJlcGxhY2VUcmFwcyhjYWxsYmFjaykge1xuICAgIGlkYlByb3h5VHJhcHMgPSBjYWxsYmFjayhpZGJQcm94eVRyYXBzKTtcbn1cbmZ1bmN0aW9uIHdyYXBGdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gRHVlIHRvIGV4cGVjdGVkIG9iamVjdCBlcXVhbGl0eSAod2hpY2ggaXMgZW5mb3JjZWQgYnkgdGhlIGNhY2hpbmcgaW4gYHdyYXBgKSwgd2VcbiAgICAvLyBvbmx5IGNyZWF0ZSBvbmUgbmV3IGZ1bmMgcGVyIGZ1bmMuXG4gICAgLy8gQ3Vyc29yIG1ldGhvZHMgYXJlIHNwZWNpYWwsIGFzIHRoZSBiZWhhdmlvdXIgaXMgYSBsaXR0bGUgbW9yZSBkaWZmZXJlbnQgdG8gc3RhbmRhcmQgSURCLiBJblxuICAgIC8vIElEQiwgeW91IGFkdmFuY2UgdGhlIGN1cnNvciBhbmQgd2FpdCBmb3IgYSBuZXcgJ3N1Y2Nlc3MnIG9uIHRoZSBJREJSZXF1ZXN0IHRoYXQgZ2F2ZSB5b3UgdGhlXG4gICAgLy8gY3Vyc29yLiBJdCdzIGtpbmRhIGxpa2UgYSBwcm9taXNlIHRoYXQgY2FuIHJlc29sdmUgd2l0aCBtYW55IHZhbHVlcy4gVGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAvLyB3aXRoIHJlYWwgcHJvbWlzZXMsIHNvIGVhY2ggYWR2YW5jZSBtZXRob2RzIHJldHVybnMgYSBuZXcgcHJvbWlzZSBmb3IgdGhlIGN1cnNvciBvYmplY3QsIG9yXG4gICAgLy8gdW5kZWZpbmVkIGlmIHRoZSBlbmQgb2YgdGhlIGN1cnNvciBoYXMgYmVlbiByZWFjaGVkLlxuICAgIGlmIChnZXRDdXJzb3JBZHZhbmNlTWV0aG9kcygpLmluY2x1ZGVzKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIG9iamVjdC5cbiAgICAgICAgICAgIGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB3cmFwKHRoaXMucmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgIHJldHVybiB3cmFwKGZ1bmMuYXBwbHkodW53cmFwKHRoaXMpLCBhcmdzKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gd3JhcEZ1bmN0aW9uKHZhbHVlKTtcbiAgICAvLyBUaGlzIGRvZXNuJ3QgcmV0dXJuLCBpdCBqdXN0IGNyZWF0ZXMgYSAnZG9uZScgcHJvbWlzZSBmb3IgdGhlIHRyYW5zYWN0aW9uLFxuICAgIC8vIHdoaWNoIGlzIGxhdGVyIHJldHVybmVkIGZvciB0cmFuc2FjdGlvbi5kb25lIChzZWUgaWRiT2JqZWN0SGFuZGxlcikuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pXG4gICAgICAgIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih2YWx1ZSk7XG4gICAgaWYgKGluc3RhbmNlT2ZBbnkodmFsdWUsIGdldElkYlByb3h5YWJsZVR5cGVzKCkpKVxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHZhbHVlLCBpZGJQcm94eVRyYXBzKTtcbiAgICAvLyBSZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFjayBpZiB3ZSdyZSBub3QgZ29pbmcgdG8gdHJhbnNmb3JtIGl0LlxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHdyYXAodmFsdWUpIHtcbiAgICAvLyBXZSBzb21ldGltZXMgZ2VuZXJhdGUgbXVsdGlwbGUgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0IChlZyB3aGVuIGN1cnNvcmluZyksIGJlY2F1c2VcbiAgICAvLyBJREIgaXMgd2VpcmQgYW5kIGEgc2luZ2xlIElEQlJlcXVlc3QgY2FuIHlpZWxkIG1hbnkgcmVzcG9uc2VzLCBzbyB0aGVzZSBjYW4ndCBiZSBjYWNoZWQuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSURCUmVxdWVzdClcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeVJlcXVlc3QodmFsdWUpO1xuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgdHJhbnNmb3JtZWQgdGhpcyB2YWx1ZSBiZWZvcmUsIHJldXNlIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZS5cbiAgICAvLyBUaGlzIGlzIGZhc3RlciwgYnV0IGl0IGFsc28gcHJvdmlkZXMgb2JqZWN0IGVxdWFsaXR5LlxuICAgIGlmICh0cmFuc2Zvcm1DYWNoZS5oYXModmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRyYW5zZm9ybUNhY2hhYmxlVmFsdWUodmFsdWUpO1xuICAgIC8vIE5vdCBhbGwgdHlwZXMgYXJlIHRyYW5zZm9ybWVkLlxuICAgIC8vIFRoZXNlIG1heSBiZSBwcmltaXRpdmUgdHlwZXMsIHNvIHRoZXkgY2FuJ3QgYmUgV2Vha01hcCBrZXlzLlxuICAgIGlmIChuZXdWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgdHJhbnNmb3JtQ2FjaGUuc2V0KHZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQobmV3VmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuY29uc3QgdW53cmFwID0gKHZhbHVlKSA9PiByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuZ2V0KHZhbHVlKTtcblxuLyoqXG4gKiBPcGVuIGEgZGF0YWJhc2UuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgZGF0YWJhc2UuXG4gKiBAcGFyYW0gdmVyc2lvbiBTY2hlbWEgdmVyc2lvbi5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQWRkaXRpb25hbCBjYWxsYmFja3MuXG4gKi9cbmZ1bmN0aW9uIG9wZW5EQihuYW1lLCB2ZXJzaW9uLCB7IGJsb2NrZWQsIHVwZ3JhZGUsIGJsb2NraW5nLCB0ZXJtaW5hdGVkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihuYW1lLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBvcGVuUHJvbWlzZSA9IHdyYXAocmVxdWVzdCk7XG4gICAgaWYgKHVwZ3JhZGUpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCd1cGdyYWRlbmVlZGVkJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB1cGdyYWRlKHdyYXAocmVxdWVzdC5yZXN1bHQpLCBldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCB3cmFwKHJlcXVlc3QudHJhbnNhY3Rpb24pLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlZCkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoZXZlbnQpID0+IGJsb2NrZWQoXG4gICAgICAgIC8vIENhc3RpbmcgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC1ET00tbGliLWdlbmVyYXRvci9wdWxsLzE0MDVcbiAgICAgICAgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgZXZlbnQpKTtcbiAgICB9XG4gICAgb3BlblByb21pc2VcbiAgICAgICAgLnRoZW4oKGRiKSA9PiB7XG4gICAgICAgIGlmICh0ZXJtaW5hdGVkKVxuICAgICAgICAgICAgZGIuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCAoKSA9PiB0ZXJtaW5hdGVkKCkpO1xuICAgICAgICBpZiAoYmxvY2tpbmcpIHtcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ3ZlcnNpb25jaGFuZ2UnLCAoZXZlbnQpID0+IGJsb2NraW5nKGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIGV2ZW50KSk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICByZXR1cm4gb3BlblByb21pc2U7XG59XG4vKipcbiAqIERlbGV0ZSBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICovXG5mdW5jdGlvbiBkZWxldGVEQihuYW1lLCB7IGJsb2NrZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKTtcbiAgICBpZiAoYmxvY2tlZCkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Jsb2NrZWQnLCAoZXZlbnQpID0+IGJsb2NrZWQoXG4gICAgICAgIC8vIENhc3RpbmcgZHVlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC1ET00tbGliLWdlbmVyYXRvci9wdWxsLzE0MDVcbiAgICAgICAgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXAocmVxdWVzdCkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xufVxuXG5jb25zdCByZWFkTWV0aG9kcyA9IFsnZ2V0JywgJ2dldEtleScsICdnZXRBbGwnLCAnZ2V0QWxsS2V5cycsICdjb3VudCddO1xuY29uc3Qgd3JpdGVNZXRob2RzID0gWydwdXQnLCAnYWRkJywgJ2RlbGV0ZScsICdjbGVhciddO1xuY29uc3QgY2FjaGVkTWV0aG9kcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHtcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBJREJEYXRhYmFzZSAmJlxuICAgICAgICAhKHByb3AgaW4gdGFyZ2V0KSAmJlxuICAgICAgICB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApKVxuICAgICAgICByZXR1cm4gY2FjaGVkTWV0aG9kcy5nZXQocHJvcCk7XG4gICAgY29uc3QgdGFyZ2V0RnVuY05hbWUgPSBwcm9wLnJlcGxhY2UoL0Zyb21JbmRleCQvLCAnJyk7XG4gICAgY29uc3QgdXNlSW5kZXggPSBwcm9wICE9PSB0YXJnZXRGdW5jTmFtZTtcbiAgICBjb25zdCBpc1dyaXRlID0gd3JpdGVNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKTtcbiAgICBpZiAoXG4gICAgLy8gQmFpbCBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHRhcmdldC4gRWcsIGdldEFsbCBpc24ndCBpbiBFZGdlLlxuICAgICEodGFyZ2V0RnVuY05hbWUgaW4gKHVzZUluZGV4ID8gSURCSW5kZXggOiBJREJPYmplY3RTdG9yZSkucHJvdG90eXBlKSB8fFxuICAgICAgICAhKGlzV3JpdGUgfHwgcmVhZE1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIGZ1bmN0aW9uIChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogdW5kZWZpbmVkIGd6aXBwcyBiZXR0ZXIsIGJ1dCBmYWlscyBpbiBFZGdlIDooXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbihzdG9yZU5hbWUsIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seScpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdHguc3RvcmU7XG4gICAgICAgIGlmICh1c2VJbmRleClcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5pbmRleChhcmdzLnNoaWZ0KCkpO1xuICAgICAgICAvLyBNdXN0IHJlamVjdCBpZiBvcCByZWplY3RzLlxuICAgICAgICAvLyBJZiBpdCdzIGEgd3JpdGUgb3BlcmF0aW9uLCBtdXN0IHJlamVjdCBpZiB0eC5kb25lIHJlamVjdHMuXG4gICAgICAgIC8vIE11c3QgcmVqZWN0IHdpdGggb3AgcmVqZWN0aW9uIGZpcnN0LlxuICAgICAgICAvLyBNdXN0IHJlc29sdmUgd2l0aCBvcCB2YWx1ZS5cbiAgICAgICAgLy8gTXVzdCBoYW5kbGUgYm90aCBwcm9taXNlcyAobm8gdW5oYW5kbGVkIHJlamVjdGlvbnMpXG4gICAgICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGFyZ2V0W3RhcmdldEZ1bmNOYW1lXSguLi5hcmdzKSxcbiAgICAgICAgICAgIGlzV3JpdGUgJiYgdHguZG9uZSxcbiAgICAgICAgXSkpWzBdO1xuICAgIH07XG4gICAgY2FjaGVkTWV0aG9kcy5zZXQocHJvcCwgbWV0aG9kKTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxucmVwbGFjZVRyYXBzKChvbGRUcmFwcykgPT4gKHtcbiAgICAuLi5vbGRUcmFwcyxcbiAgICBnZXQ6ICh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSA9PiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlciksXG4gICAgaGFzOiAodGFyZ2V0LCBwcm9wKSA9PiAhIWdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmhhcyh0YXJnZXQsIHByb3ApLFxufSkpO1xuXG5jb25zdCBhZHZhbmNlTWV0aG9kUHJvcHMgPSBbJ2NvbnRpbnVlJywgJ2NvbnRpbnVlUHJpbWFyeUtleScsICdhZHZhbmNlJ107XG5jb25zdCBtZXRob2RNYXAgPSB7fTtcbmNvbnN0IGFkdmFuY2VSZXN1bHRzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGl0dHJQcm94aWVkQ3Vyc29yVG9PcmlnaW5hbFByb3h5ID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGN1cnNvckl0ZXJhdG9yVHJhcHMgPSB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgICBpZiAoIWFkdmFuY2VNZXRob2RQcm9wcy5pbmNsdWRlcyhwcm9wKSlcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgIGxldCBjYWNoZWRGdW5jID0gbWV0aG9kTWFwW3Byb3BdO1xuICAgICAgICBpZiAoIWNhY2hlZEZ1bmMpIHtcbiAgICAgICAgICAgIGNhY2hlZEZ1bmMgPSBtZXRob2RNYXBbcHJvcF0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGFkdmFuY2VSZXN1bHRzLnNldCh0aGlzLCBpdHRyUHJveGllZEN1cnNvclRvT3JpZ2luYWxQcm94eS5nZXQodGhpcylbcHJvcF0oLi4uYXJncykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkRnVuYztcbiAgICB9LFxufTtcbmFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRlKC4uLmFyZ3MpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdGhpcy1hc3NpZ25tZW50XG4gICAgbGV0IGN1cnNvciA9IHRoaXM7XG4gICAgaWYgKCEoY3Vyc29yIGluc3RhbmNlb2YgSURCQ3Vyc29yKSkge1xuICAgICAgICBjdXJzb3IgPSBhd2FpdCBjdXJzb3Iub3BlbkN1cnNvciguLi5hcmdzKTtcbiAgICB9XG4gICAgaWYgKCFjdXJzb3IpXG4gICAgICAgIHJldHVybjtcbiAgICBjdXJzb3IgPSBjdXJzb3I7XG4gICAgY29uc3QgcHJveGllZEN1cnNvciA9IG5ldyBQcm94eShjdXJzb3IsIGN1cnNvckl0ZXJhdG9yVHJhcHMpO1xuICAgIGl0dHJQcm94aWVkQ3Vyc29yVG9PcmlnaW5hbFByb3h5LnNldChwcm94aWVkQ3Vyc29yLCBjdXJzb3IpO1xuICAgIC8vIE1hcCB0aGlzIGRvdWJsZS1wcm94eSBiYWNrIHRvIHRoZSBvcmlnaW5hbCwgc28gb3RoZXIgY3Vyc29yIG1ldGhvZHMgd29yay5cbiAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KHByb3hpZWRDdXJzb3IsIHVud3JhcChjdXJzb3IpKTtcbiAgICB3aGlsZSAoY3Vyc29yKSB7XG4gICAgICAgIHlpZWxkIHByb3hpZWRDdXJzb3I7XG4gICAgICAgIC8vIElmIG9uZSBvZiB0aGUgYWR2YW5jaW5nIG1ldGhvZHMgd2FzIG5vdCBjYWxsZWQsIGNhbGwgY29udGludWUoKS5cbiAgICAgICAgY3Vyc29yID0gYXdhaXQgKGFkdmFuY2VSZXN1bHRzLmdldChwcm94aWVkQ3Vyc29yKSB8fCBjdXJzb3IuY29udGludWUoKSk7XG4gICAgICAgIGFkdmFuY2VSZXN1bHRzLmRlbGV0ZShwcm94aWVkQ3Vyc29yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0l0ZXJhdG9yUHJvcCh0YXJnZXQsIHByb3ApIHtcbiAgICByZXR1cm4gKChwcm9wID09PSBTeW1ib2wuYXN5bmNJdGVyYXRvciAmJlxuICAgICAgICBpbnN0YW5jZU9mQW55KHRhcmdldCwgW0lEQkluZGV4LCBJREJPYmplY3RTdG9yZSwgSURCQ3Vyc29yXSkpIHx8XG4gICAgICAgIChwcm9wID09PSAnaXRlcmF0ZScgJiYgaW5zdGFuY2VPZkFueSh0YXJnZXQsIFtJREJJbmRleCwgSURCT2JqZWN0U3RvcmVdKSkpO1xufVxucmVwbGFjZVRyYXBzKChvbGRUcmFwcykgPT4gKHtcbiAgICAuLi5vbGRUcmFwcyxcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBpZiAoaXNJdGVyYXRvclByb3AodGFyZ2V0LCBwcm9wKSlcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRlO1xuICAgICAgICByZXR1cm4gb2xkVHJhcHMuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgICByZXR1cm4gaXNJdGVyYXRvclByb3AodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICB9LFxufSkpO1xuXG5leHBvcnQgeyBkZWxldGVEQiwgb3BlbkRCLCB1bndyYXAsIHdyYXAgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/idb/build/index.js\n"));

/***/ }),

/***/ "./node_modules/serwist/dist/chunks/printInstallDetails.js":
/*!*****************************************************************!*\
  !*** ./node_modules/serwist/dist/chunks/printInstallDetails.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   B: () => (/* binding */ BackgroundSyncPlugin),\n/* harmony export */   N: () => (/* binding */ NetworkFirst),\n/* harmony export */   P: () => (/* binding */ PrecacheStrategy),\n/* harmony export */   R: () => (/* binding */ Route),\n/* harmony export */   S: () => (/* binding */ Strategy),\n/* harmony export */   a: () => (/* binding */ NetworkOnly),\n/* harmony export */   b: () => (/* binding */ NavigationRoute),\n/* harmony export */   c: () => (/* binding */ createCacheKey),\n/* harmony export */   d: () => (/* binding */ disableDevLogs),\n/* harmony export */   e: () => (/* binding */ enableNavigationPreload),\n/* harmony export */   f: () => (/* binding */ defaultMethod),\n/* harmony export */   g: () => (/* binding */ generateURLVariations),\n/* harmony export */   h: () => (/* binding */ PrecacheInstallReportPlugin),\n/* harmony export */   i: () => (/* binding */ parallel),\n/* harmony export */   j: () => (/* binding */ printInstallDetails),\n/* harmony export */   k: () => (/* binding */ printCleanupDetails),\n/* harmony export */   l: () => (/* binding */ cacheOkAndOpaquePlugin),\n/* harmony export */   m: () => (/* binding */ messages),\n/* harmony export */   n: () => (/* binding */ normalizeHandler),\n/* harmony export */   o: () => (/* binding */ copyResponse),\n/* harmony export */   p: () => (/* binding */ parseRoute),\n/* harmony export */   q: () => (/* binding */ disableNavigationPreload),\n/* harmony export */   r: () => (/* binding */ isNavigationPreloadSupported),\n/* harmony export */   s: () => (/* binding */ setCacheNameDetails),\n/* harmony export */   t: () => (/* binding */ StrategyHandler),\n/* harmony export */   u: () => (/* binding */ RegExpRoute),\n/* harmony export */   v: () => (/* binding */ BackgroundSyncQueue),\n/* harmony export */   w: () => (/* binding */ BackgroundSyncQueueStore),\n/* harmony export */   x: () => (/* binding */ StorableRequest)\n/* harmony export */ });\n/* harmony import */ var _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./waitUntil.js */ \"./node_modules/serwist/dist/chunks/waitUntil.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! idb */ \"./node_modules/idb/build/index.js\");\n\n\n\nconst defaultMethod = \"GET\";\nconst validMethods = [\n    \"DELETE\",\n    \"GET\",\n    \"HEAD\",\n    \"PATCH\",\n    \"POST\",\n    \"PUT\"\n];\n\nconst normalizeHandler = (handler)=>{\n    if (handler && typeof handler === \"object\") {\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.hasMethod(handler, \"handle\", {\n                moduleName: \"serwist\",\n                className: \"Route\",\n                funcName: \"constructor\",\n                paramName: \"handler\"\n            });\n        }\n        return handler;\n    }\n    if (true) {\n        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(handler, \"function\", {\n            moduleName: \"serwist\",\n            className: \"Route\",\n            funcName: \"constructor\",\n            paramName: \"handler\"\n        });\n    }\n    return {\n        handle: handler\n    };\n};\n\nclass Route {\n    handler;\n    match;\n    method;\n    catchHandler;\n    constructor(match, handler, method = defaultMethod){\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(match, \"function\", {\n                moduleName: \"serwist\",\n                className: \"Route\",\n                funcName: \"constructor\",\n                paramName: \"match\"\n            });\n            if (method) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isOneOf(method, validMethods, {\n                    paramName: \"method\"\n                });\n            }\n        }\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n    }\n    setCatchHandler(handler) {\n        this.catchHandler = normalizeHandler(handler);\n    }\n}\n\nclass NavigationRoute extends Route {\n    _allowlist;\n    _denylist;\n    constructor(handler, { allowlist = [\n        /./\n    ], denylist = [] } = {}){\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isArrayOfClass(allowlist, RegExp, {\n                moduleName: \"serwist\",\n                className: \"NavigationRoute\",\n                funcName: \"constructor\",\n                paramName: \"options.allowlist\"\n            });\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isArrayOfClass(denylist, RegExp, {\n                moduleName: \"serwist\",\n                className: \"NavigationRoute\",\n                funcName: \"constructor\",\n                paramName: \"options.denylist\"\n            });\n        }\n        super((options)=>this._match(options), handler);\n        this._allowlist = allowlist;\n        this._denylist = denylist;\n    }\n    _match({ url, request }) {\n        if (request && request.mode !== \"navigate\") {\n            return false;\n        }\n        const pathnameAndSearch = url.pathname + url.search;\n        for (const regExp of this._denylist){\n            if (regExp.test(pathnameAndSearch)) {\n                if (true) {\n                    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`The navigation route ${pathnameAndSearch} is not being used, since the URL matches this denylist pattern: ${regExp.toString()}`);\n                }\n                return false;\n            }\n        }\n        if (this._allowlist.some((regExp)=>regExp.test(pathnameAndSearch))) {\n            if (true) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`The navigation route ${pathnameAndSearch} is being used.`);\n            }\n            return true;\n        }\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`The navigation route ${pathnameAndSearch} is not being used, since the URL being navigated to doesn't match the allowlist.`);\n        }\n        return false;\n    }\n}\n\nconst removeIgnoredSearchParams = (urlObject, ignoreURLParametersMatching = [])=>{\n    for (const paramName of [\n        ...urlObject.searchParams.keys()\n    ]){\n        if (ignoreURLParametersMatching.some((regExp)=>regExp.test(paramName))) {\n            urlObject.searchParams.delete(paramName);\n        }\n    }\n    return urlObject;\n};\n\nfunction* generateURLVariations(url, { directoryIndex = \"index.html\", ignoreURLParametersMatching = [\n    /^utm_/,\n    /^fbclid$/\n], cleanURLs = true, urlManipulation } = {}) {\n    const urlObject = new URL(url, location.href);\n    urlObject.hash = \"\";\n    yield urlObject.href;\n    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n    yield urlWithoutIgnoredParams.href;\n    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith(\"/\")) {\n        const directoryURL = new URL(urlWithoutIgnoredParams.href);\n        directoryURL.pathname += directoryIndex;\n        yield directoryURL.href;\n    }\n    if (cleanURLs) {\n        const cleanURL = new URL(urlWithoutIgnoredParams.href);\n        cleanURL.pathname += \".html\";\n        yield cleanURL.href;\n    }\n    if (urlManipulation) {\n        const additionalURLs = urlManipulation({\n            url: urlObject\n        });\n        for (const urlToAttempt of additionalURLs){\n            yield urlToAttempt.href;\n        }\n    }\n}\n\nclass RegExpRoute extends Route {\n    constructor(regExp, handler, method){\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(regExp, RegExp, {\n                moduleName: \"serwist\",\n                className: \"RegExpRoute\",\n                funcName: \"constructor\",\n                paramName: \"pattern\"\n            });\n        }\n        const match = ({ url })=>{\n            const result = regExp.exec(url.href);\n            if (!result) {\n                return;\n            }\n            if (url.origin !== location.origin && result.index !== 0) {\n                if (true) {\n                    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`The regular expression '${regExp.toString()}' only partially matched against the cross-origin URL '${url.toString()}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`);\n                }\n                return;\n            }\n            return result.slice(1);\n        };\n        super(match, handler, method);\n    }\n}\n\nconst parallel = async (limit, array, func)=>{\n    const work = array.map((item, index)=>({\n            index,\n            item\n        }));\n    const processor = async (res)=>{\n        const results = [];\n        while(true){\n            const next = work.pop();\n            if (!next) {\n                return res(results);\n            }\n            const result = await func(next.item);\n            results.push({\n                result: result,\n                index: next.index\n            });\n        }\n    };\n    const queues = Array.from({\n        length: limit\n    }, ()=>new Promise(processor));\n    const results = (await Promise.all(queues)).flat().sort((a, b)=>a.index < b.index ? -1 : 1).map((res)=>res.result);\n    return results;\n};\n\nconst disableDevLogs = ()=>{\n    self.__WB_DISABLE_DEV_LOGS = true;\n};\n\nfunction toRequest(input) {\n    return typeof input === \"string\" ? new Request(input) : input;\n}\nclass StrategyHandler {\n    event;\n    request;\n    url;\n    params;\n    _cacheKeys = {};\n    _strategy;\n    _handlerDeferred;\n    _extendLifetimePromises;\n    _plugins;\n    _pluginStateMap;\n    constructor(strategy, options){\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(options.event, ExtendableEvent, {\n                moduleName: \"serwist\",\n                className: \"StrategyHandler\",\n                funcName: \"constructor\",\n                paramName: \"options.event\"\n            });\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(options.request, Request, {\n                moduleName: \"serwist\",\n                className: \"StrategyHandler\",\n                funcName: \"constructor\",\n                paramName: \"options.request\"\n            });\n        }\n        this.event = options.event;\n        this.request = options.request;\n        if (options.url) {\n            this.url = options.url;\n            this.params = options.params;\n        }\n        this._strategy = strategy;\n        this._handlerDeferred = new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.D();\n        this._extendLifetimePromises = [];\n        this._plugins = [\n            ...strategy.plugins\n        ];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins){\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        const preloadResponse = await this.getPreloadResponse();\n        if (preloadResponse) {\n            return preloadResponse;\n        }\n        const originalRequest = this.hasCallback(\"fetchDidFail\") ? request.clone() : null;\n        try {\n            for (const cb of this.iterateCallbacks(\"requestWillFetch\")){\n                request = await cb({\n                    request: request.clone(),\n                    event\n                });\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"plugin-error-request-will-fetch\", {\n                    thrownErrorMessage: err.message\n                });\n            }\n        }\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            fetchResponse = await fetch(request, request.mode === \"navigate\" ? undefined : this._strategy.fetchOptions);\n            if (true) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`Network request for '${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}' returned a response with status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks(\"fetchDidSucceed\")){\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse\n                });\n            }\n            return fetchResponse;\n        } catch (error) {\n            if (true) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Network request for '${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}' threw an error.`, error);\n            }\n            if (originalRequest) {\n                await this.runCallbacks(\"fetchDidFail\", {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone()\n                });\n            }\n            throw error;\n        }\n    }\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, \"read\");\n        const multiMatchOptions = {\n            ...matchOptions,\n            ...{\n                cacheName\n            }\n        };\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (true) {\n            if (cachedResponse) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`Found a cached response in '${cacheName}'.`);\n            } else {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks(\"cachedResponseWillBeUsed\")){\n            cachedResponse = await callback({\n                cacheName,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n                event: this.event\n            }) || undefined;\n        }\n        return cachedResponse;\n    }\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        await (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.t)(0);\n        const effectiveRequest = await this.getCacheKey(request, \"write\");\n        if (true) {\n            if (effectiveRequest.method && effectiveRequest.method !== \"GET\") {\n                throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"attempt-to-cache-non-get-request\", {\n                    url: (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url),\n                    method: effectiveRequest.method\n                });\n            }\n        }\n        if (!response) {\n            if (true) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.error(`Cannot cache non-existent response for '${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url)}'.`);\n            }\n            throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"cache-put-with-no-response\", {\n                url: (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url)\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (true) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`Response '${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url)}' will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        if (true) {\n            const vary = response.headers.get(\"Vary\");\n            if (vary && matchOptions?.ignoreVary !== true) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`The response for ${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url)} has a 'Vary: ${vary}' header. Consider setting the {ignoreVary: true} option on your strategy to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        const hasCacheUpdateCallback = this.hasCallback(\"cacheDidUpdate\");\n        const oldResponse = hasCacheUpdateCallback ? await (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.d)(cache, effectiveRequest.clone(), [\n            \"__WB_REVISION__\"\n        ], matchOptions) : null;\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`Updating the '${cacheName}' cache with a new Response for ${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        } catch (error) {\n            if (error instanceof Error) {\n                if (error.name === \"QuotaExceededError\") {\n                    await (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.e)();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks(\"cacheDidUpdate\")){\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event\n            });\n        }\n        return true;\n    }\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks(\"cacheKeyWillBeUsed\")){\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    params: this.params\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins){\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)){\n            await callback(param);\n        }\n    }\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins){\n            if (typeof plugin[name] === \"function\") {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param)=>{\n                    const statefulParam = {\n                        ...param,\n                        state\n                    };\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    async doneWaiting() {\n        let promise;\n        while(promise = this._extendLifetimePromises.shift()){\n            await promise;\n        }\n    }\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    async getPreloadResponse() {\n        if (this.event instanceof FetchEvent && this.event.request.mode === \"navigate\" && \"preloadResponse\" in this.event) {\n            try {\n                const possiblePreloadResponse = await this.event.preloadResponse;\n                if (possiblePreloadResponse) {\n                    if (true) {\n                        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Using a preloaded navigation response for '${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(this.event.request.url)}'`);\n                    }\n                    return possiblePreloadResponse;\n                }\n            } catch (error) {\n                if (true) {\n                    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.error(error);\n                }\n                return undefined;\n            }\n        }\n        return undefined;\n    }\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks(\"cacheWillUpdate\")){\n            responseToCache = await callback({\n                request: this.request,\n                response: responseToCache,\n                event: this.event\n            }) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                if (true) {\n                    if (responseToCache.status === 0) {\n                        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.warn(`The response for '${this.request.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`);\n                    } else {\n                        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`The response for '${this.request.url}' returned a status code of '${response.status}' and won't be cached as a result.`);\n                    }\n                }\n                responseToCache = undefined;\n            }\n        }\n        return responseToCache;\n    }\n}\n\nclass Strategy {\n    cacheName;\n    plugins;\n    fetchOptions;\n    matchOptions;\n    constructor(options = {}){\n        this.cacheName = _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.c.getRuntimeName(options.cacheName);\n        this.plugins = options.plugins || [];\n        this.fetchOptions = options.fetchOptions;\n        this.matchOptions = options.matchOptions;\n    }\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    handleAll(options) {\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === \"string\" ? new Request(options.request) : options.request;\n        const handler = new StrategyHandler(this, options.url ? {\n            event,\n            request,\n            url: options.url,\n            params: options.params\n        } : {\n            event,\n            request\n        });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        return [\n            responseDone,\n            handlerDone\n        ];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks(\"handlerWillStart\", {\n            event,\n            request\n        });\n        let response;\n        try {\n            response = await this._handle(request, handler);\n            if (response === undefined || response.type === \"error\") {\n                throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"no-response\", {\n                    url: request.url\n                });\n            }\n        } catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks(\"handlerDidError\")){\n                    response = await callback({\n                        error,\n                        event,\n                        request\n                    });\n                    if (response !== undefined) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            if (true) {\n                throw _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`While responding to '${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}', an ${error instanceof Error ? error.toString() : \"\"} error occurred. Using a fallback response provided by a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks(\"handlerWillRespond\")){\n            response = await callback({\n                event,\n                request,\n                response\n            });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        } catch  {}\n        try {\n            await handler.runCallbacks(\"handlerDidRespond\", {\n                event,\n                request,\n                response\n            });\n            await handler.doneWaiting();\n        } catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks(\"handlerDidComplete\", {\n            event,\n            request,\n            response,\n            error\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\n\nconst cacheOkAndOpaquePlugin = {\n    cacheWillUpdate: async ({ response })=>{\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    }\n};\n\nconst messages = {\n    strategyStart: (strategyName, request)=>`Using ${strategyName} to respond to '${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}'`,\n    printFinalResponse: (response)=>{\n        if (response) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(\"View the final response here.\");\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(response || \"[No response returned]\");\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n        }\n    }\n};\n\nclass NetworkFirst extends Strategy {\n    _networkTimeoutSeconds;\n    constructor(options = {}){\n        super(options);\n        if (!this.plugins.some((p)=>\"cacheWillUpdate\" in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (true) {\n            if (this._networkTimeoutSeconds) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(this._networkTimeoutSeconds, \"number\", {\n                    moduleName: \"serwist\",\n                    className: this.constructor.name,\n                    funcName: \"constructor\",\n                    paramName: \"networkTimeoutSeconds\"\n                });\n            }\n        }\n    }\n    async _handle(request, handler) {\n        const logs = [];\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: this.constructor.name,\n                funcName: \"handle\",\n                paramName: \"makeRequest\"\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({\n                request,\n                logs,\n                handler\n            });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({\n            timeoutId,\n            request,\n            logs,\n            handler\n        });\n        promises.push(networkPromise);\n        const response = await handler.waitUntil((async ()=>{\n            return await handler.waitUntil(Promise.race(promises)) || await networkPromise;\n        })());\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs){\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(log);\n            }\n            messages.printFinalResponse(response);\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n        }\n        if (!response) {\n            throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"no-response\", {\n                url: request.url\n            });\n        }\n        return response;\n    }\n    _getTimeoutPromise({ request, logs, handler }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve)=>{\n            const onNetworkTimeout = async ()=>{\n                if (true) {\n                    logs.push(`Timing out the network response at ${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await handler.cacheMatch(request));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId\n        };\n    }\n    async _getNetworkPromise({ timeoutId, request, logs, handler }) {\n        let error;\n        let response;\n        try {\n            response = await handler.fetchAndCachePut(request);\n        } catch (fetchError) {\n            if (fetchError instanceof Error) {\n                error = fetchError;\n            }\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (true) {\n            if (response) {\n                logs.push(\"Got response from network.\");\n            } else {\n                logs.push(\"Unable to get a response from the network. Will respond \" + \"with a cached response.\");\n            }\n        }\n        if (error || !response) {\n            response = await handler.cacheMatch(request);\n            if (true) {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n                } else {\n                    logs.push(`No response found in the '${this.cacheName}' cache.`);\n                }\n            }\n        }\n        return response;\n    }\n}\n\nclass NetworkOnly extends Strategy {\n    _networkTimeoutSeconds;\n    constructor(options = {}){\n        super(options);\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n    }\n    async _handle(request, handler) {\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: this.constructor.name,\n                funcName: \"_handle\",\n                paramName: \"request\"\n            });\n        }\n        let error;\n        let response;\n        try {\n            const promises = [\n                handler.fetch(request)\n            ];\n            if (this._networkTimeoutSeconds) {\n                const timeoutPromise = (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.t)(this._networkTimeoutSeconds * 1000);\n                promises.push(timeoutPromise);\n            }\n            response = await Promise.race(promises);\n            if (!response) {\n                throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`);\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                error = err;\n            }\n        }\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Got response from network.\");\n            } else {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Unable to get a response from the network.\");\n            }\n            messages.printFinalResponse(response);\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n        }\n        if (!response) {\n            throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"no-response\", {\n                url: request.url,\n                error\n            });\n        }\n        return response;\n    }\n}\n\nconst BACKGROUND_SYNC_DB_VERSION = 3;\nconst BACKGROUND_SYNC_DB_NAME = \"serwist-background-sync\";\nconst REQUEST_OBJECT_STORE_NAME = \"requests\";\nconst QUEUE_NAME_INDEX = \"queueName\";\nclass BackgroundSyncQueueDb {\n    _db = null;\n    async addEntry(entry) {\n        const db = await this.getDb();\n        const tx = db.transaction(REQUEST_OBJECT_STORE_NAME, \"readwrite\", {\n            durability: \"relaxed\"\n        });\n        await tx.store.add(entry);\n        await tx.done;\n    }\n    async getFirstEntryId() {\n        const db = await this.getDb();\n        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.openCursor();\n        return cursor?.value.id;\n    }\n    async getAllEntriesByQueueName(queueName) {\n        const db = await this.getDb();\n        const results = await db.getAllFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));\n        return results ? results : [];\n    }\n    async getEntryCountByQueueName(queueName) {\n        const db = await this.getDb();\n        return db.countFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));\n    }\n    async deleteEntry(id) {\n        const db = await this.getDb();\n        await db.delete(REQUEST_OBJECT_STORE_NAME, id);\n    }\n    async getFirstEntryByQueueName(queueName) {\n        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), \"next\");\n    }\n    async getLastEntryByQueueName(queueName) {\n        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), \"prev\");\n    }\n    async getEndEntryFromIndex(query, direction) {\n        const db = await this.getDb();\n        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.index(QUEUE_NAME_INDEX).openCursor(query, direction);\n        return cursor?.value;\n    }\n    async getDb() {\n        if (!this._db) {\n            this._db = await (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)(BACKGROUND_SYNC_DB_NAME, BACKGROUND_SYNC_DB_VERSION, {\n                upgrade: this._upgradeDb\n            });\n        }\n        return this._db;\n    }\n    _upgradeDb(db, oldVersion) {\n        if (oldVersion > 0 && oldVersion < BACKGROUND_SYNC_DB_VERSION) {\n            if (db.objectStoreNames.contains(REQUEST_OBJECT_STORE_NAME)) {\n                db.deleteObjectStore(REQUEST_OBJECT_STORE_NAME);\n            }\n        }\n        const objStore = db.createObjectStore(REQUEST_OBJECT_STORE_NAME, {\n            autoIncrement: true,\n            keyPath: \"id\"\n        });\n        objStore.createIndex(QUEUE_NAME_INDEX, QUEUE_NAME_INDEX, {\n            unique: false\n        });\n    }\n}\n\nclass BackgroundSyncQueueStore {\n    _queueName;\n    _queueDb;\n    constructor(queueName){\n        this._queueName = queueName;\n        this._queueDb = new BackgroundSyncQueueDb();\n    }\n    async pushEntry(entry) {\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"pushEntry\",\n                paramName: \"entry\"\n            });\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry.requestData, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"pushEntry\",\n                paramName: \"entry.requestData\"\n            });\n        }\n        delete entry.id;\n        entry.queueName = this._queueName;\n        await this._queueDb.addEntry(entry);\n    }\n    async unshiftEntry(entry) {\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"unshiftEntry\",\n                paramName: \"entry\"\n            });\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry.requestData, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"unshiftEntry\",\n                paramName: \"entry.requestData\"\n            });\n        }\n        const firstId = await this._queueDb.getFirstEntryId();\n        if (firstId) {\n            entry.id = firstId - 1;\n        } else {\n            delete entry.id;\n        }\n        entry.queueName = this._queueName;\n        await this._queueDb.addEntry(entry);\n    }\n    async popEntry() {\n        return this._removeEntry(await this._queueDb.getLastEntryByQueueName(this._queueName));\n    }\n    async shiftEntry() {\n        return this._removeEntry(await this._queueDb.getFirstEntryByQueueName(this._queueName));\n    }\n    async getAll() {\n        return await this._queueDb.getAllEntriesByQueueName(this._queueName);\n    }\n    async size() {\n        return await this._queueDb.getEntryCountByQueueName(this._queueName);\n    }\n    async deleteEntry(id) {\n        await this._queueDb.deleteEntry(id);\n    }\n    async _removeEntry(entry) {\n        if (entry) {\n            await this.deleteEntry(entry.id);\n        }\n        return entry;\n    }\n}\n\nconst serializableProperties = [\n    \"method\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"mode\",\n    \"credentials\",\n    \"cache\",\n    \"redirect\",\n    \"integrity\",\n    \"keepalive\"\n];\nclass StorableRequest {\n    _requestData;\n    static async fromRequest(request) {\n        const requestData = {\n            url: request.url,\n            headers: {}\n        };\n        if (request.method !== \"GET\") {\n            requestData.body = await request.clone().arrayBuffer();\n        }\n        request.headers.forEach((value, key)=>{\n            requestData.headers[key] = value;\n        });\n        for (const prop of serializableProperties){\n            if (request[prop] !== undefined) {\n                requestData[prop] = request[prop];\n            }\n        }\n        return new StorableRequest(requestData);\n    }\n    constructor(requestData){\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(requestData, \"object\", {\n                moduleName: \"serwist\",\n                className: \"StorableRequest\",\n                funcName: \"constructor\",\n                paramName: \"requestData\"\n            });\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(requestData.url, \"string\", {\n                moduleName: \"serwist\",\n                className: \"StorableRequest\",\n                funcName: \"constructor\",\n                paramName: \"requestData.url\"\n            });\n        }\n        if (requestData.mode === \"navigate\") {\n            requestData.mode = \"same-origin\";\n        }\n        this._requestData = requestData;\n    }\n    toObject() {\n        const requestData = Object.assign({}, this._requestData);\n        requestData.headers = Object.assign({}, this._requestData.headers);\n        if (requestData.body) {\n            requestData.body = requestData.body.slice(0);\n        }\n        return requestData;\n    }\n    toRequest() {\n        return new Request(this._requestData.url, this._requestData);\n    }\n    clone() {\n        return new StorableRequest(this.toObject());\n    }\n}\n\nconst TAG_PREFIX = \"serwist-background-sync\";\nconst MAX_RETENTION_TIME = 60 * 24 * 7;\nconst queueNames = new Set();\nconst convertEntry = (queueStoreEntry)=>{\n    const queueEntry = {\n        request: new StorableRequest(queueStoreEntry.requestData).toRequest(),\n        timestamp: queueStoreEntry.timestamp\n    };\n    if (queueStoreEntry.metadata) {\n        queueEntry.metadata = queueStoreEntry.metadata;\n    }\n    return queueEntry;\n};\nclass BackgroundSyncQueue {\n    _name;\n    _onSync;\n    _maxRetentionTime;\n    _queueStore;\n    _forceSyncFallback;\n    _syncInProgress = false;\n    _requestsAddedDuringSync = false;\n    constructor(name, { forceSyncFallback, onSync, maxRetentionTime } = {}){\n        if (queueNames.has(name)) {\n            throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"duplicate-queue-name\", {\n                name\n            });\n        }\n        queueNames.add(name);\n        this._name = name;\n        this._onSync = onSync || this.replayRequests;\n        this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME;\n        this._forceSyncFallback = Boolean(forceSyncFallback);\n        this._queueStore = new BackgroundSyncQueueStore(this._name);\n        this._addSyncListener();\n    }\n    get name() {\n        return this._name;\n    }\n    async pushRequest(entry) {\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"pushRequest\",\n                paramName: \"entry\"\n            });\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(entry.request, Request, {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"pushRequest\",\n                paramName: \"entry.request\"\n            });\n        }\n        await this._addRequest(entry, \"push\");\n    }\n    async unshiftRequest(entry) {\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry, \"object\", {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"unshiftRequest\",\n                paramName: \"entry\"\n            });\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(entry.request, Request, {\n                moduleName: \"serwist\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"unshiftRequest\",\n                paramName: \"entry.request\"\n            });\n        }\n        await this._addRequest(entry, \"unshift\");\n    }\n    async popRequest() {\n        return this._removeRequest(\"pop\");\n    }\n    async shiftRequest() {\n        return this._removeRequest(\"shift\");\n    }\n    async getAll() {\n        const allEntries = await this._queueStore.getAll();\n        const now = Date.now();\n        const unexpiredEntries = [];\n        for (const entry of allEntries){\n            const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n            if (now - entry.timestamp > maxRetentionTimeInMs) {\n                await this._queueStore.deleteEntry(entry.id);\n            } else {\n                unexpiredEntries.push(convertEntry(entry));\n            }\n        }\n        return unexpiredEntries;\n    }\n    async size() {\n        return await this._queueStore.size();\n    }\n    async _addRequest({ request, metadata, timestamp = Date.now() }, operation) {\n        const storableRequest = await StorableRequest.fromRequest(request.clone());\n        const entry = {\n            requestData: storableRequest.toObject(),\n            timestamp\n        };\n        if (metadata) {\n            entry.metadata = metadata;\n        }\n        switch(operation){\n            case \"push\":\n                await this._queueStore.pushEntry(entry);\n                break;\n            case \"unshift\":\n                await this._queueStore.unshiftEntry(entry);\n                break;\n        }\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Request for '${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}' has ` + `been added to background sync queue '${this._name}'.`);\n        }\n        if (this._syncInProgress) {\n            this._requestsAddedDuringSync = true;\n        } else {\n            await this.registerSync();\n        }\n    }\n    async _removeRequest(operation) {\n        const now = Date.now();\n        let entry;\n        switch(operation){\n            case \"pop\":\n                entry = await this._queueStore.popEntry();\n                break;\n            case \"shift\":\n                entry = await this._queueStore.shiftEntry();\n                break;\n        }\n        if (entry) {\n            const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n            if (now - entry.timestamp > maxRetentionTimeInMs) {\n                return this._removeRequest(operation);\n            }\n            return convertEntry(entry);\n        }\n        return undefined;\n    }\n    async replayRequests() {\n        let entry;\n        while(entry = await this.shiftRequest()){\n            try {\n                await fetch(entry.request.clone());\n                if (true) {\n                    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Request for '${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(entry.request.url)}' ` + `has been replayed in queue '${this._name}'`);\n                }\n            } catch  {\n                await this.unshiftRequest(entry);\n                if (true) {\n                    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Request for '${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(entry.request.url)}' ` + `failed to replay, putting it back in queue '${this._name}'`);\n                }\n                throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"queue-replay-failed\", {\n                    name: this._name\n                });\n            }\n        }\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`All requests in queue '${this.name}' have successfully replayed; the queue is now empty!`);\n        }\n    }\n    async registerSync() {\n        if (\"sync\" in self.registration && !this._forceSyncFallback) {\n            try {\n                await self.registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n            } catch (err) {\n                if (true) {\n                    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.warn(`Unable to register sync event for '${this._name}'.`, err);\n                }\n            }\n        }\n    }\n    _addSyncListener() {\n        if (\"sync\" in self.registration && !this._forceSyncFallback) {\n            self.addEventListener(\"sync\", (event)=>{\n                if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n                    if (true) {\n                        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Background sync for tag '${event.tag}' has been received`);\n                    }\n                    const syncComplete = async ()=>{\n                        this._syncInProgress = true;\n                        let syncError;\n                        try {\n                            await this._onSync({\n                                queue: this\n                            });\n                        } catch (error) {\n                            if (error instanceof Error) {\n                                syncError = error;\n                                throw syncError;\n                            }\n                        } finally{\n                            if (this._requestsAddedDuringSync && !(syncError && !event.lastChance)) {\n                                await this.registerSync();\n                            }\n                            this._syncInProgress = false;\n                            this._requestsAddedDuringSync = false;\n                        }\n                    };\n                    event.waitUntil(syncComplete());\n                }\n            });\n        } else {\n            if (true) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Background sync replaying without background sync event\");\n            }\n            void this._onSync({\n                queue: this\n            });\n        }\n    }\n    static get _queueNames() {\n        return queueNames;\n    }\n}\n\nclass BackgroundSyncPlugin {\n    _queue;\n    constructor(name, options){\n        this._queue = new BackgroundSyncQueue(name, options);\n    }\n    async fetchDidFail({ request }) {\n        await this._queue.pushRequest({\n            request\n        });\n    }\n}\n\nconst copyResponse = async (response, modifier)=>{\n    let origin = null;\n    if (response.url) {\n        const responseURL = new URL(response.url);\n        origin = responseURL.origin;\n    }\n    if (origin !== self.location.origin) {\n        throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"cross-origin-copy-response\", {\n            origin\n        });\n    }\n    const clonedResponse = response.clone();\n    const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText\n    };\n    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n    const body = (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.h)() ? clonedResponse.body : await clonedResponse.blob();\n    return new Response(body, modifiedResponseInit);\n};\n\nclass PrecacheStrategy extends Strategy {\n    _fallbackToNetwork;\n    static defaultPrecacheCacheabilityPlugin = {\n        async cacheWillUpdate ({ response }) {\n            if (!response || response.status >= 400) {\n                return null;\n            }\n            return response;\n        }\n    };\n    static copyRedirectedCacheableResponsesPlugin = {\n        async cacheWillUpdate ({ response }) {\n            return response.redirected ? await copyResponse(response) : response;\n        }\n    };\n    constructor(options = {}){\n        options.cacheName = _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.c.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork = options.fallbackToNetwork !== false;\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    }\n    async _handle(request, handler) {\n        const preloadResponse = await handler.getPreloadResponse();\n        if (preloadResponse) {\n            return preloadResponse;\n        }\n        const response = await handler.cacheMatch(request);\n        if (response) {\n            return response;\n        }\n        if (handler.event && handler.event.type === \"install\") {\n            return await this._handleInstall(request, handler);\n        }\n        return await this._handleFetch(request, handler);\n    }\n    async _handleFetch(request, handler) {\n        let response;\n        const params = handler.params || {};\n        if (this._fallbackToNetwork) {\n            if (true) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.warn(`The precached response for ${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)} in ${this.cacheName} was not found. Falling back to the network.`);\n            }\n            const integrityInManifest = params.integrity;\n            const integrityInRequest = request.integrity;\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n            response = await handler.fetch(new Request(request, {\n                integrity: request.mode !== \"no-cors\" ? integrityInRequest || integrityInManifest : undefined\n            }));\n            if (integrityInManifest && noIntegrityConflict && request.mode !== \"no-cors\") {\n                this._useDefaultCacheabilityPluginIfNeeded();\n                const wasCached = await handler.cachePut(request, response.clone());\n                if (true) {\n                    if (wasCached) {\n                        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`A response for ${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)} was used to \"repair\" the precache.`);\n                    }\n                }\n            }\n        } else {\n            throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"missing-precache-entry\", {\n                cacheName: this.cacheName,\n                url: request.url\n            });\n        }\n        if (true) {\n            const cacheKey = params.cacheKey || await handler.getCacheKey(request, \"read\");\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(`Precaching is responding to: ${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}`);\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Serving the precached url: ${(0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.g)(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(\"View request details here.\");\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(request);\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(\"View response details here.\");\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(response);\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n            throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"bad-precaching-response\", {\n                url: request.url,\n                status: response.status\n            });\n        }\n        return response;\n    }\n    _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()){\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n                continue;\n            }\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n                defaultPluginIndex = index;\n            }\n            if (plugin.cacheWillUpdate) {\n                cacheWillUpdatePluginCount++;\n            }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n            this.plugins.splice(defaultPluginIndex, 1);\n        }\n    }\n}\n\nconst isNavigationPreloadSupported = ()=>{\n    return Boolean(self.registration?.navigationPreload);\n};\nconst enableNavigationPreload = (headerValue)=>{\n    if (isNavigationPreloadSupported()) {\n        self.addEventListener(\"activate\", (event)=>{\n            event.waitUntil(self.registration.navigationPreload.enable().then(()=>{\n                if (headerValue) {\n                    void self.registration.navigationPreload.setHeaderValue(headerValue);\n                }\n                if (true) {\n                    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Navigation preloading is enabled.\");\n                }\n            }));\n        });\n    } else {\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Navigation preloading is not supported in this browser.\");\n        }\n    }\n};\nconst disableNavigationPreload = ()=>{\n    if (isNavigationPreloadSupported()) {\n        self.addEventListener(\"activate\", (event)=>{\n            event.waitUntil(self.registration.navigationPreload.disable().then(()=>{\n                if (true) {\n                    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Navigation preloading is disabled.\");\n                }\n            }));\n        });\n    } else {\n        if (true) {\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Navigation preloading is not supported in this browser.\");\n        }\n    }\n};\n\nconst setCacheNameDetails = (details)=>{\n    if (true) {\n        for (const key of Object.keys(details)){\n            _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(details[key], \"string\", {\n                moduleName: \"@serwist/core\",\n                funcName: \"setCacheNameDetails\",\n                paramName: `details.${key}`\n            });\n        }\n        if (details.precache?.length === 0) {\n            throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-cache-name\", {\n                cacheNameId: \"precache\",\n                value: details.precache\n            });\n        }\n        if (details.runtime?.length === 0) {\n            throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-cache-name\", {\n                cacheNameId: \"runtime\",\n                value: details.runtime\n            });\n        }\n        if (details.googleAnalytics?.length === 0) {\n            throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-cache-name\", {\n                cacheNameId: \"googleAnalytics\",\n                value: details.googleAnalytics\n            });\n        }\n    }\n    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.c.updateDetails(details);\n};\n\nclass PrecacheInstallReportPlugin {\n    updatedURLs = [];\n    notUpdatedURLs = [];\n    handlerWillStart = async ({ request, state })=>{\n        if (state) {\n            state.originalRequest = request;\n        }\n    };\n    cachedResponseWillBeUsed = async ({ event, state, cachedResponse })=>{\n        if (event.type === \"install\") {\n            if (state?.originalRequest && state.originalRequest instanceof Request) {\n                const url = state.originalRequest.url;\n                if (cachedResponse) {\n                    this.notUpdatedURLs.push(url);\n                } else {\n                    this.updatedURLs.push(url);\n                }\n            }\n        }\n        return cachedResponse;\n    };\n}\n\nconst REVISION_SEARCH_PARAM = \"__WB_REVISION__\";\nconst createCacheKey = (entry)=>{\n    if (!entry) {\n        throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"add-to-cache-list-unexpected-type\", {\n            entry\n        });\n    }\n    if (typeof entry === \"string\") {\n        const urlObject = new URL(entry, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href\n        };\n    }\n    const { revision, url } = entry;\n    if (!url) {\n        throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"add-to-cache-list-unexpected-type\", {\n            entry\n        });\n    }\n    if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href\n        };\n    }\n    const cacheKeyURL = new URL(url, location.href);\n    const originalURL = new URL(url, location.href);\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n    return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href\n    };\n};\n\nconst parseRoute = (capture, handler, method)=>{\n    if (typeof capture === \"string\") {\n        const captureUrl = new URL(capture, location.href);\n        if (true) {\n            if (!(capture.startsWith(\"/\") || capture.startsWith(\"http\"))) {\n                throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-string\", {\n                    moduleName: \"serwist\",\n                    funcName: \"parseRoute\",\n                    paramName: \"capture\"\n                });\n            }\n            const valueToCheck = capture.startsWith(\"http\") ? captureUrl.pathname : capture;\n            const wildcards = \"[*:?+]\";\n            if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n                _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`The '$capture' parameter contains an Express-style wildcard character (${wildcards}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`);\n            }\n        }\n        const matchCallback = ({ url })=>{\n            if (true) {\n                if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n                    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`${capture} only partially matches the cross-origin URL ${url.toString()}. This route will only handle cross-origin requests if they match the entire URL.`);\n                }\n            }\n            return url.href === captureUrl.href;\n        };\n        return new Route(matchCallback, handler, method);\n    }\n    if (capture instanceof RegExp) {\n        return new RegExpRoute(capture, handler, method);\n    }\n    if (typeof capture === \"function\") {\n        return new Route(capture, handler, method);\n    }\n    if (capture instanceof Route) {\n        return capture;\n    }\n    throw new _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.S(\"unsupported-route-type\", {\n        moduleName: \"serwist\",\n        funcName: \"parseRoute\",\n        paramName: \"capture\"\n    });\n};\n\nconst logGroup = (groupTitle, deletedURLs)=>{\n    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(groupTitle);\n    for (const url of deletedURLs){\n        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(url);\n    }\n    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n};\nconst printCleanupDetails = (deletedURLs)=>{\n    const deletionCount = deletedURLs.length;\n    if (deletionCount > 0) {\n        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(`During precaching cleanup, ${deletionCount} cached request${deletionCount === 1 ? \" was\" : \"s were\"} deleted.`);\n        logGroup(\"Deleted Cache Requests\", deletedURLs);\n        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n    }\n};\n\nfunction _nestedGroup(groupTitle, urls) {\n    if (urls.length === 0) {\n        return;\n    }\n    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(groupTitle);\n    for (const url of urls){\n        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.log(url);\n    }\n    _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n}\nconst printInstallDetails = (urlsToPrecache, urlsAlreadyPrecached)=>{\n    const precachedCount = urlsToPrecache.length;\n    const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n    if (precachedCount || alreadyPrecachedCount) {\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? \"\" : \"s\"}.`;\n        if (alreadyPrecachedCount > 0) {\n            message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? \" is\" : \"s are\"} already cached.`;\n        }\n        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(message);\n        _nestedGroup(\"View newly precached URLs.\", urlsToPrecache);\n        _nestedGroup(\"View previously precached URLs.\", urlsAlreadyPrecached);\n        _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n    }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2Vyd2lzdC9kaXN0L2NodW5rcy9wcmludEluc3RhbGxEZXRhaWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbVE7QUFDdE87O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDRDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDLFFBQVEsNENBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDRDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQiw0Q0FBa0I7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsdUJBQXVCLElBQUk7QUFDM0IsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDRDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDRDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFxQztBQUN6RCxvQkFBb0IsNENBQU0sNkJBQTZCLG1CQUFtQixrRUFBa0Usa0JBQWtCO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBcUM7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QUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJDQUFNO0FBQ25DO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSw0Q0FBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWSw0Q0FBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDRDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDRDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNB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Q0FBTSw4Q0FBOEMsZUFBZSxnQkFBZ0IseUNBQXlDO0FBQ3BJO0FBQ0EsUUFBUSw0Q0FBTTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRDQUFNO0FBQ1Y7QUFDQSxRQUFRLDRDQUFNO0FBQ2Q7QUFDQSxJQUFJLDRDQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0IsTUFBTSxnQ0FBZ0M7QUFDMUY7QUFDQSwyQkFBMkIsdUJBQXVCLFdBQVcsK0NBQStDO0FBQzVHO0FBQ0EsUUFBUSw0Q0FBTTtBQUNkO0FBQ0E7QUFDQSxRQUFRLDRDQUFNO0FBQ2Q7QUFDQTs7QUFFeXFCIiwic291cmNlcyI6WyIvaG9tZS9ueXgvV29ya3NwYWNlL09zdWMvVWJpQ2F0ZS12Mi9ub2RlX21vZHVsZXMvc2Vyd2lzdC9kaXN0L2NodW5rcy9wcmludEluc3RhbGxEZXRhaWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGYgYXMgZmluYWxBc3NlcnRFeHBvcnRzLCBsIGFzIGxvZ2dlciwgRCBhcyBEZWZlcnJlZCwgUyBhcyBTZXJ3aXN0RXJyb3IsIGcgYXMgZ2V0RnJpZW5kbHlVUkwsIHQgYXMgdGltZW91dCwgZCBhcyBjYWNoZU1hdGNoSWdub3JlUGFyYW1zLCBlIGFzIGV4ZWN1dGVRdW90YUVycm9yQ2FsbGJhY2tzLCBjIGFzIGNhY2hlTmFtZXMsIGggYXMgY2FuQ29uc3RydWN0UmVzcG9uc2VGcm9tQm9keVN0cmVhbSB9IGZyb20gJy4vd2FpdFVudGlsLmpzJztcbmltcG9ydCB7IG9wZW5EQiB9IGZyb20gJ2lkYic7XG5cbmNvbnN0IGRlZmF1bHRNZXRob2QgPSBcIkdFVFwiO1xuY29uc3QgdmFsaWRNZXRob2RzID0gW1xuICAgIFwiREVMRVRFXCIsXG4gICAgXCJHRVRcIixcbiAgICBcIkhFQURcIixcbiAgICBcIlBBVENIXCIsXG4gICAgXCJQT1NUXCIsXG4gICAgXCJQVVRcIlxuXTtcblxuY29uc3Qgbm9ybWFsaXplSGFuZGxlciA9IChoYW5kbGVyKT0+e1xuICAgIGlmIChoYW5kbGVyICYmIHR5cGVvZiBoYW5kbGVyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5oYXNNZXRob2QoaGFuZGxlciwgXCJoYW5kbGVcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJSb3V0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImhhbmRsZXJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShoYW5kbGVyLCBcImZ1bmN0aW9uXCIsIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlJvdXRlXCIsXG4gICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgcGFyYW1OYW1lOiBcImhhbmRsZXJcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFuZGxlOiBoYW5kbGVyXG4gICAgfTtcbn07XG5cbmNsYXNzIFJvdXRlIHtcbiAgICBoYW5kbGVyO1xuICAgIG1hdGNoO1xuICAgIG1ldGhvZDtcbiAgICBjYXRjaEhhbmRsZXI7XG4gICAgY29uc3RydWN0b3IobWF0Y2gsIGhhbmRsZXIsIG1ldGhvZCA9IGRlZmF1bHRNZXRob2Qpe1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKG1hdGNoLCBcImZ1bmN0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiUm91dGVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJtYXRjaFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNPbmVPZihtZXRob2QsIHZhbGlkTWV0aG9kcywge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwibWV0aG9kXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIH1cbiAgICBzZXRDYXRjaEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmNhdGNoSGFuZGxlciA9IG5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlcik7XG4gICAgfVxufVxuXG5jbGFzcyBOYXZpZ2F0aW9uUm91dGUgZXh0ZW5kcyBSb3V0ZSB7XG4gICAgX2FsbG93bGlzdDtcbiAgICBfZGVueWxpc3Q7XG4gICAgY29uc3RydWN0b3IoaGFuZGxlciwgeyBhbGxvd2xpc3QgPSBbXG4gICAgICAgIC8uL1xuICAgIF0sIGRlbnlsaXN0ID0gW10gfSA9IHt9KXtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzQXJyYXlPZkNsYXNzKGFsbG93bGlzdCwgUmVnRXhwLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIk5hdmlnYXRpb25Sb3V0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm9wdGlvbnMuYWxsb3dsaXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzQXJyYXlPZkNsYXNzKGRlbnlsaXN0LCBSZWdFeHAsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiTmF2aWdhdGlvblJvdXRlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwib3B0aW9ucy5kZW55bGlzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigob3B0aW9ucyk9PnRoaXMuX21hdGNoKG9wdGlvbnMpLCBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fYWxsb3dsaXN0ID0gYWxsb3dsaXN0O1xuICAgICAgICB0aGlzLl9kZW55bGlzdCA9IGRlbnlsaXN0O1xuICAgIH1cbiAgICBfbWF0Y2goeyB1cmwsIHJlcXVlc3QgfSkge1xuICAgICAgICBpZiAocmVxdWVzdCAmJiByZXF1ZXN0Lm1vZGUgIT09IFwibmF2aWdhdGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lQW5kU2VhcmNoID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgZm9yIChjb25zdCByZWdFeHAgb2YgdGhpcy5fZGVueWxpc3Qpe1xuICAgICAgICAgICAgaWYgKHJlZ0V4cC50ZXN0KHBhdGhuYW1lQW5kU2VhcmNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgVGhlIG5hdmlnYXRpb24gcm91dGUgJHtwYXRobmFtZUFuZFNlYXJjaH0gaXMgbm90IGJlaW5nIHVzZWQsIHNpbmNlIHRoZSBVUkwgbWF0Y2hlcyB0aGlzIGRlbnlsaXN0IHBhdHRlcm46ICR7cmVnRXhwLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYWxsb3dsaXN0LnNvbWUoKHJlZ0V4cCk9PnJlZ0V4cC50ZXN0KHBhdGhuYW1lQW5kU2VhcmNoKSkpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSBuYXZpZ2F0aW9uIHJvdXRlICR7cGF0aG5hbWVBbmRTZWFyY2h9IGlzIGJlaW5nIHVzZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBUaGUgbmF2aWdhdGlvbiByb3V0ZSAke3BhdGhuYW1lQW5kU2VhcmNofSBpcyBub3QgYmVpbmcgdXNlZCwgc2luY2UgdGhlIFVSTCBiZWluZyBuYXZpZ2F0ZWQgdG8gZG9lc24ndCBtYXRjaCB0aGUgYWxsb3dsaXN0LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmNvbnN0IHJlbW92ZUlnbm9yZWRTZWFyY2hQYXJhbXMgPSAodXJsT2JqZWN0LCBpZ25vcmVVUkxQYXJhbWV0ZXJzTWF0Y2hpbmcgPSBbXSk9PntcbiAgICBmb3IgKGNvbnN0IHBhcmFtTmFtZSBvZiBbXG4gICAgICAgIC4uLnVybE9iamVjdC5zZWFyY2hQYXJhbXMua2V5cygpXG4gICAgXSl7XG4gICAgICAgIGlmIChpZ25vcmVVUkxQYXJhbWV0ZXJzTWF0Y2hpbmcuc29tZSgocmVnRXhwKT0+cmVnRXhwLnRlc3QocGFyYW1OYW1lKSkpIHtcbiAgICAgICAgICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKHBhcmFtTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVybE9iamVjdDtcbn07XG5cbmZ1bmN0aW9uKiBnZW5lcmF0ZVVSTFZhcmlhdGlvbnModXJsLCB7IGRpcmVjdG9yeUluZGV4ID0gXCJpbmRleC5odG1sXCIsIGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZyA9IFtcbiAgICAvXnV0bV8vLFxuICAgIC9eZmJjbGlkJC9cbl0sIGNsZWFuVVJMcyA9IHRydWUsIHVybE1hbmlwdWxhdGlvbiB9ID0ge30pIHtcbiAgICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSBcIlwiO1xuICAgIHlpZWxkIHVybE9iamVjdC5ocmVmO1xuICAgIGNvbnN0IHVybFdpdGhvdXRJZ25vcmVkUGFyYW1zID0gcmVtb3ZlSWdub3JlZFNlYXJjaFBhcmFtcyh1cmxPYmplY3QsIGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZyk7XG4gICAgeWllbGQgdXJsV2l0aG91dElnbm9yZWRQYXJhbXMuaHJlZjtcbiAgICBpZiAoZGlyZWN0b3J5SW5kZXggJiYgdXJsV2l0aG91dElnbm9yZWRQYXJhbXMucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdG9yeVVSTCA9IG5ldyBVUkwodXJsV2l0aG91dElnbm9yZWRQYXJhbXMuaHJlZik7XG4gICAgICAgIGRpcmVjdG9yeVVSTC5wYXRobmFtZSArPSBkaXJlY3RvcnlJbmRleDtcbiAgICAgICAgeWllbGQgZGlyZWN0b3J5VVJMLmhyZWY7XG4gICAgfVxuICAgIGlmIChjbGVhblVSTHMpIHtcbiAgICAgICAgY29uc3QgY2xlYW5VUkwgPSBuZXcgVVJMKHVybFdpdGhvdXRJZ25vcmVkUGFyYW1zLmhyZWYpO1xuICAgICAgICBjbGVhblVSTC5wYXRobmFtZSArPSBcIi5odG1sXCI7XG4gICAgICAgIHlpZWxkIGNsZWFuVVJMLmhyZWY7XG4gICAgfVxuICAgIGlmICh1cmxNYW5pcHVsYXRpb24pIHtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbFVSTHMgPSB1cmxNYW5pcHVsYXRpb24oe1xuICAgICAgICAgICAgdXJsOiB1cmxPYmplY3RcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgdXJsVG9BdHRlbXB0IG9mIGFkZGl0aW9uYWxVUkxzKXtcbiAgICAgICAgICAgIHlpZWxkIHVybFRvQXR0ZW1wdC5ocmVmO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBSZWdFeHBSb3V0ZSBleHRlbmRzIFJvdXRlIHtcbiAgICBjb25zdHJ1Y3RvcihyZWdFeHAsIGhhbmRsZXIsIG1ldGhvZCl7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc0luc3RhbmNlKHJlZ0V4cCwgUmVnRXhwLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlJlZ0V4cFJvdXRlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicGF0dGVyblwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaCA9ICh7IHVybCB9KT0+e1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVnRXhwLmV4ZWModXJsLmhyZWYpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXJsLm9yaWdpbiAhPT0gbG9jYXRpb24ub3JpZ2luICYmIHJlc3VsdC5pbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaGUgcmVndWxhciBleHByZXNzaW9uICcke3JlZ0V4cC50b1N0cmluZygpfScgb25seSBwYXJ0aWFsbHkgbWF0Y2hlZCBhZ2FpbnN0IHRoZSBjcm9zcy1vcmlnaW4gVVJMICcke3VybC50b1N0cmluZygpfScuIFJlZ0V4cFJvdXRlJ3Mgd2lsbCBvbmx5IGhhbmRsZSBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgaWYgdGhleSBtYXRjaCB0aGUgZW50aXJlIFVSTC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zbGljZSgxKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIobWF0Y2gsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfVxufVxuXG5jb25zdCBwYXJhbGxlbCA9IGFzeW5jIChsaW1pdCwgYXJyYXksIGZ1bmMpPT57XG4gICAgY29uc3Qgd29yayA9IGFycmF5Lm1hcCgoaXRlbSwgaW5kZXgpPT4oe1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgIH0pKTtcbiAgICBjb25zdCBwcm9jZXNzb3IgPSBhc3luYyAocmVzKT0+e1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHdvcmsucG9wKCk7XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZnVuYyhuZXh0Lml0ZW0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBpbmRleDogbmV4dC5pbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHF1ZXVlcyA9IEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IGxpbWl0XG4gICAgfSwgKCk9Pm5ldyBQcm9taXNlKHByb2Nlc3NvcikpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSAoYXdhaXQgUHJvbWlzZS5hbGwocXVldWVzKSkuZmxhdCgpLnNvcnQoKGEsIGIpPT5hLmluZGV4IDwgYi5pbmRleCA/IC0xIDogMSkubWFwKChyZXMpPT5yZXMucmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbmNvbnN0IGRpc2FibGVEZXZMb2dzID0gKCk9PntcbiAgICBzZWxmLl9fV0JfRElTQUJMRV9ERVZfTE9HUyA9IHRydWU7XG59O1xuXG5mdW5jdGlvbiB0b1JlcXVlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiID8gbmV3IFJlcXVlc3QoaW5wdXQpIDogaW5wdXQ7XG59XG5jbGFzcyBTdHJhdGVneUhhbmRsZXIge1xuICAgIGV2ZW50O1xuICAgIHJlcXVlc3Q7XG4gICAgdXJsO1xuICAgIHBhcmFtcztcbiAgICBfY2FjaGVLZXlzID0ge307XG4gICAgX3N0cmF0ZWd5O1xuICAgIF9oYW5kbGVyRGVmZXJyZWQ7XG4gICAgX2V4dGVuZExpZmV0aW1lUHJvbWlzZXM7XG4gICAgX3BsdWdpbnM7XG4gICAgX3BsdWdpblN0YXRlTWFwO1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWd5LCBvcHRpb25zKXtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzSW5zdGFuY2Uob3B0aW9ucy5ldmVudCwgRXh0ZW5kYWJsZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlN0cmF0ZWd5SGFuZGxlclwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm9wdGlvbnMuZXZlbnRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNJbnN0YW5jZShvcHRpb25zLnJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiU3RyYXRlZ3lIYW5kbGVyXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwib3B0aW9ucy5yZXF1ZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnQgPSBvcHRpb25zLmV2ZW50O1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7XG4gICAgICAgIGlmIChvcHRpb25zLnVybCkge1xuICAgICAgICAgICAgdGhpcy51cmwgPSBvcHRpb25zLnVybDtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgdGhpcy5faGFuZGxlckRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuX2V4dGVuZExpZmV0aW1lUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fcGx1Z2lucyA9IFtcbiAgICAgICAgICAgIC4uLnN0cmF0ZWd5LnBsdWdpbnNcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fcGx1Z2luU3RhdGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMuX3BsdWdpbnMpe1xuICAgICAgICAgICAgdGhpcy5fcGx1Z2luU3RhdGVNYXAuc2V0KHBsdWdpbiwge30pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnQud2FpdFVudGlsKHRoaXMuX2hhbmRsZXJEZWZlcnJlZC5wcm9taXNlKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2goaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBldmVudCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0b1JlcXVlc3QoaW5wdXQpO1xuICAgICAgICBjb25zdCBwcmVsb2FkUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFByZWxvYWRSZXNwb25zZSgpO1xuICAgICAgICBpZiAocHJlbG9hZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlbG9hZFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUmVxdWVzdCA9IHRoaXMuaGFzQ2FsbGJhY2soXCJmZXRjaERpZEZhaWxcIikgPyByZXF1ZXN0LmNsb25lKCkgOiBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYiBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoXCJyZXF1ZXN0V2lsbEZldGNoXCIpKXtcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gYXdhaXQgY2Ioe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LmNsb25lKCksXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcInBsdWdpbi1lcnJvci1yZXF1ZXN0LXdpbGwtZmV0Y2hcIiwge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd25FcnJvck1lc3NhZ2U6IGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGx1Z2luRmlsdGVyZWRSZXF1ZXN0ID0gcmVxdWVzdC5jbG9uZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGZldGNoUmVzcG9uc2U7XG4gICAgICAgICAgICBmZXRjaFJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCwgcmVxdWVzdC5tb2RlID09PSBcIm5hdmlnYXRlXCIgPyB1bmRlZmluZWQgOiB0aGlzLl9zdHJhdGVneS5mZXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTmV0d29yayByZXF1ZXN0IGZvciAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9JyByZXR1cm5lZCBhIHJlc3BvbnNlIHdpdGggc3RhdHVzICcke2ZldGNoUmVzcG9uc2Uuc3RhdHVzfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhcImZldGNoRGlkU3VjY2VlZFwiKSl7XG4gICAgICAgICAgICAgICAgZmV0Y2hSZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHBsdWdpbkZpbHRlcmVkUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGZldGNoUmVzcG9uc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaFJlc3BvbnNlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYE5ldHdvcmsgcmVxdWVzdCBmb3IgJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfScgdGhyZXcgYW4gZXJyb3IuYCwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9yaWdpbmFsUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuQ2FsbGJhY2tzKFwiZmV0Y2hEaWRGYWlsXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxSZXF1ZXN0OiBvcmlnaW5hbFJlcXVlc3QuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcGx1Z2luRmlsdGVyZWRSZXF1ZXN0LmNsb25lKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoQW5kQ2FjaGVQdXQoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoKGlucHV0KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VDbG9uZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgIHZvaWQgdGhpcy53YWl0VW50aWwodGhpcy5jYWNoZVB1dChpbnB1dCwgcmVzcG9uc2VDbG9uZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIGNhY2hlTWF0Y2goa2V5KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0b1JlcXVlc3Qoa2V5KTtcbiAgICAgICAgbGV0IGNhY2hlZFJlc3BvbnNlO1xuICAgICAgICBjb25zdCB7IGNhY2hlTmFtZSwgbWF0Y2hPcHRpb25zIH0gPSB0aGlzLl9zdHJhdGVneTtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlUmVxdWVzdCA9IGF3YWl0IHRoaXMuZ2V0Q2FjaGVLZXkocmVxdWVzdCwgXCJyZWFkXCIpO1xuICAgICAgICBjb25zdCBtdWx0aU1hdGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLm1hdGNoT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSBhd2FpdCBjYWNoZXMubWF0Y2goZWZmZWN0aXZlUmVxdWVzdCwgbXVsdGlNYXRjaE9wdGlvbnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoY2FjaGVkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYEZvdW5kIGEgY2FjaGVkIHJlc3BvbnNlIGluICcke2NhY2hlTmFtZX0nLmApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYE5vIGNhY2hlZCByZXNwb25zZSBmb3VuZCBpbiAnJHtjYWNoZU5hbWV9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhcImNhY2hlZFJlc3BvbnNlV2lsbEJlVXNlZFwiKSl7XG4gICAgICAgICAgICBjYWNoZWRSZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWUsXG4gICAgICAgICAgICAgICAgbWF0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnRcbiAgICAgICAgICAgIH0pIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIGNhY2hlUHV0KGtleSwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRvUmVxdWVzdChrZXkpO1xuICAgICAgICBhd2FpdCB0aW1lb3V0KDApO1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVSZXF1ZXN0ID0gYXdhaXQgdGhpcy5nZXRDYWNoZUtleShyZXF1ZXN0LCBcIndyaXRlXCIpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0aXZlUmVxdWVzdC5tZXRob2QgJiYgZWZmZWN0aXZlUmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiYXR0ZW1wdC10by1jYWNoZS1ub24tZ2V0LXJlcXVlc3RcIiwge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGdldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYENhbm5vdCBjYWNoZSBub24tZXhpc3RlbnQgcmVzcG9uc2UgZm9yICcke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImNhY2hlLXB1dC13aXRoLW5vLXJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgICAgICB1cmw6IGdldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VUb0NhY2hlID0gYXdhaXQgdGhpcy5fZW5zdXJlUmVzcG9uc2VTYWZlVG9DYWNoZShyZXNwb25zZSk7XG4gICAgICAgIGlmICghcmVzcG9uc2VUb0NhY2hlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBSZXNwb25zZSAnJHtnZXRGcmllbmRseVVSTChlZmZlY3RpdmVSZXF1ZXN0LnVybCl9JyB3aWxsIG5vdCBiZSBjYWNoZWQuYCwgcmVzcG9uc2VUb0NhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhY2hlTmFtZSwgbWF0Y2hPcHRpb25zIH0gPSB0aGlzLl9zdHJhdGVneTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKGNhY2hlTmFtZSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcnkgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIlZhcnlcIik7XG4gICAgICAgICAgICBpZiAodmFyeSAmJiBtYXRjaE9wdGlvbnM/Lmlnbm9yZVZhcnkgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSByZXNwb25zZSBmb3IgJHtnZXRGcmllbmRseVVSTChlZmZlY3RpdmVSZXF1ZXN0LnVybCl9IGhhcyBhICdWYXJ5OiAke3Zhcnl9JyBoZWFkZXIuIENvbnNpZGVyIHNldHRpbmcgdGhlIHtpZ25vcmVWYXJ5OiB0cnVlfSBvcHRpb24gb24geW91ciBzdHJhdGVneSB0byBlbnN1cmUgY2FjaGUgbWF0Y2hpbmcgYW5kIGRlbGV0aW9uIHdvcmtzIGFzIGV4cGVjdGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0NhY2hlVXBkYXRlQ2FsbGJhY2sgPSB0aGlzLmhhc0NhbGxiYWNrKFwiY2FjaGVEaWRVcGRhdGVcIik7XG4gICAgICAgIGNvbnN0IG9sZFJlc3BvbnNlID0gaGFzQ2FjaGVVcGRhdGVDYWxsYmFjayA/IGF3YWl0IGNhY2hlTWF0Y2hJZ25vcmVQYXJhbXMoY2FjaGUsIGVmZmVjdGl2ZVJlcXVlc3QuY2xvbmUoKSwgW1xuICAgICAgICAgICAgXCJfX1dCX1JFVklTSU9OX19cIlxuICAgICAgICBdLCBtYXRjaE9wdGlvbnMpIDogbnVsbDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBVcGRhdGluZyB0aGUgJyR7Y2FjaGVOYW1lfScgY2FjaGUgd2l0aCBhIG5ldyBSZXNwb25zZSBmb3IgJHtnZXRGcmllbmRseVVSTChlZmZlY3RpdmVSZXF1ZXN0LnVybCl9LmApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZS5wdXQoZWZmZWN0aXZlUmVxdWVzdCwgaGFzQ2FjaGVVcGRhdGVDYWxsYmFjayA/IHJlc3BvbnNlVG9DYWNoZS5jbG9uZSgpIDogcmVzcG9uc2VUb0NhY2hlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiUXVvdGFFeGNlZWRlZEVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoXCJjYWNoZURpZFVwZGF0ZVwiKSl7XG4gICAgICAgICAgICBhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgY2FjaGVOYW1lLFxuICAgICAgICAgICAgICAgIG9sZFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIG5ld1Jlc3BvbnNlOiByZXNwb25zZVRvQ2FjaGUuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBlZmZlY3RpdmVSZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2FjaGVLZXkocmVxdWVzdCwgbW9kZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBgJHtyZXF1ZXN0LnVybH0gfCAke21vZGV9YDtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZUtleXNba2V5XSkge1xuICAgICAgICAgICAgbGV0IGVmZmVjdGl2ZVJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLml0ZXJhdGVDYWxsYmFja3MoXCJjYWNoZUtleVdpbGxCZVVzZWRcIikpe1xuICAgICAgICAgICAgICAgIGVmZmVjdGl2ZVJlcXVlc3QgPSB0b1JlcXVlc3QoYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBlZmZlY3RpdmVSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB0aGlzLnBhcmFtc1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5c1trZXldID0gZWZmZWN0aXZlUmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVLZXlzW2tleV07XG4gICAgfVxuICAgIGhhc0NhbGxiYWNrKG5hbWUpIHtcbiAgICAgICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5fc3RyYXRlZ3kucGx1Z2lucyl7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIHJ1bkNhbGxiYWNrcyhuYW1lLCBwYXJhbSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhuYW1lKSl7XG4gICAgICAgICAgICBhd2FpdCBjYWxsYmFjayhwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKml0ZXJhdGVDYWxsYmFja3MobmFtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLl9zdHJhdGVneS5wbHVnaW5zKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1Z2luW25hbWVdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3BsdWdpblN0YXRlTWFwLmdldChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlZnVsQ2FsbGJhY2sgPSAocGFyYW0pPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlZnVsUGFyYW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW5bbmFtZV0oc3RhdGVmdWxQYXJhbSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB5aWVsZCBzdGF0ZWZ1bENhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHdhaXRVbnRpbChwcm9taXNlKSB7XG4gICAgICAgIHRoaXMuX2V4dGVuZExpZmV0aW1lUHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGFzeW5jIGRvbmVXYWl0aW5nKCkge1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgd2hpbGUocHJvbWlzZSA9IHRoaXMuX2V4dGVuZExpZmV0aW1lUHJvbWlzZXMuc2hpZnQoKSl7XG4gICAgICAgICAgICBhd2FpdCBwcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJEZWZlcnJlZC5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBhc3luYyBnZXRQcmVsb2FkUmVzcG9uc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50IGluc3RhbmNlb2YgRmV0Y2hFdmVudCAmJiB0aGlzLmV2ZW50LnJlcXVlc3QubW9kZSA9PT0gXCJuYXZpZ2F0ZVwiICYmIFwicHJlbG9hZFJlc3BvbnNlXCIgaW4gdGhpcy5ldmVudCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZVByZWxvYWRSZXNwb25zZSA9IGF3YWl0IHRoaXMuZXZlbnQucHJlbG9hZFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVByZWxvYWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBVc2luZyBhIHByZWxvYWRlZCBuYXZpZ2F0aW9uIHJlc3BvbnNlIGZvciAnJHtnZXRGcmllbmRseVVSTCh0aGlzLmV2ZW50LnJlcXVlc3QudXJsKX0nYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIF9lbnN1cmVSZXNwb25zZVNhZmVUb0NhY2hlKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCByZXNwb25zZVRvQ2FjaGUgPSByZXNwb25zZTtcbiAgICAgICAgbGV0IHBsdWdpbnNVc2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKFwiY2FjaGVXaWxsVXBkYXRlXCIpKXtcbiAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlVG9DYWNoZSxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudFxuICAgICAgICAgICAgfSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgcGx1Z2luc1VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsdWdpbnNVc2VkKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlICYmIHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBUaGUgcmVzcG9uc2UgZm9yICcke3RoaXMucmVxdWVzdC51cmx9JyBpcyBhbiBvcGFxdWUgcmVzcG9uc2UuIFRoZSBjYWNoaW5nIHN0cmF0ZWd5IHRoYXQgeW91J3JlIHVzaW5nIHdpbGwgbm90IGNhY2hlIG9wYXF1ZSByZXNwb25zZXMgYnkgZGVmYXVsdC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIHJlc3BvbnNlIGZvciAnJHt0aGlzLnJlcXVlc3QudXJsfScgcmV0dXJuZWQgYSBzdGF0dXMgY29kZSBvZiAnJHtyZXNwb25zZS5zdGF0dXN9JyBhbmQgd29uJ3QgYmUgY2FjaGVkIGFzIGEgcmVzdWx0LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VUb0NhY2hlO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyYXRlZ3kge1xuICAgIGNhY2hlTmFtZTtcbiAgICBwbHVnaW5zO1xuICAgIGZldGNoT3B0aW9ucztcbiAgICBtYXRjaE9wdGlvbnM7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KXtcbiAgICAgICAgdGhpcy5jYWNoZU5hbWUgPSBjYWNoZU5hbWVzLmdldFJ1bnRpbWVOYW1lKG9wdGlvbnMuY2FjaGVOYW1lKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zIHx8IFtdO1xuICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IG9wdGlvbnMuZmV0Y2hPcHRpb25zO1xuICAgICAgICB0aGlzLm1hdGNoT3B0aW9ucyA9IG9wdGlvbnMubWF0Y2hPcHRpb25zO1xuICAgIH1cbiAgICBoYW5kbGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCBbcmVzcG9uc2VEb25lXSA9IHRoaXMuaGFuZGxlQWxsKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VEb25lO1xuICAgIH1cbiAgICBoYW5kbGVBbGwob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEZldGNoRXZlbnQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogb3B0aW9ucy5yZXF1ZXN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gb3B0aW9ucy5ldmVudDtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHR5cGVvZiBvcHRpb25zLnJlcXVlc3QgPT09IFwic3RyaW5nXCIgPyBuZXcgUmVxdWVzdChvcHRpb25zLnJlcXVlc3QpIDogb3B0aW9ucy5yZXF1ZXN0O1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gbmV3IFN0cmF0ZWd5SGFuZGxlcih0aGlzLCBvcHRpb25zLnVybCA/IHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRG9uZSA9IHRoaXMuX2dldFJlc3BvbnNlKGhhbmRsZXIsIHJlcXVlc3QsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgaGFuZGxlckRvbmUgPSB0aGlzLl9hd2FpdENvbXBsZXRlKHJlc3BvbnNlRG9uZSwgaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcmVzcG9uc2VEb25lLFxuICAgICAgICAgICAgaGFuZGxlckRvbmVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFJlc3BvbnNlKGhhbmRsZXIsIHJlcXVlc3QsIGV2ZW50KSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZXIucnVuQ2FsbGJhY2tzKFwiaGFuZGxlcldpbGxTdGFydFwiLCB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5faGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcIm5vLXJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGhhbmRsZXIuaXRlcmF0ZUNhbGxiYWNrcyhcImhhbmRsZXJEaWRFcnJvclwiKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBsb2dnZXIubG9nKGBXaGlsZSByZXNwb25kaW5nIHRvICcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nLCBhbiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci50b1N0cmluZygpIDogXCJcIn0gZXJyb3Igb2NjdXJyZWQuIFVzaW5nIGEgZmFsbGJhY2sgcmVzcG9uc2UgcHJvdmlkZWQgYnkgYSBoYW5kbGVyRGlkRXJyb3IgcGx1Z2luLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgaGFuZGxlci5pdGVyYXRlQ2FsbGJhY2tzKFwiaGFuZGxlcldpbGxSZXNwb25kXCIpKXtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2F3YWl0Q29tcGxldGUocmVzcG9uc2VEb25lLCBoYW5kbGVyLCByZXF1ZXN0LCBldmVudCkge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VEb25lO1xuICAgICAgICB9IGNhdGNoICB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5ydW5DYWxsYmFja3MoXCJoYW5kbGVyRGlkUmVzcG9uZFwiLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmRvbmVXYWl0aW5nKCk7XG4gICAgICAgIH0gY2F0Y2ggKHdhaXRVbnRpbEVycm9yKSB7XG4gICAgICAgICAgICBpZiAod2FpdFVudGlsRXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yID0gd2FpdFVudGlsRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgaGFuZGxlci5ydW5DYWxsYmFja3MoXCJoYW5kbGVyRGlkQ29tcGxldGVcIiwge1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICBlcnJvclxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IGNhY2hlT2tBbmRPcGFxdWVQbHVnaW4gPSB7XG4gICAgY2FjaGVXaWxsVXBkYXRlOiBhc3luYyAoeyByZXNwb25zZSB9KT0+e1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuY29uc3QgbWVzc2FnZXMgPSB7XG4gICAgc3RyYXRlZ3lTdGFydDogKHN0cmF0ZWd5TmFtZSwgcmVxdWVzdCk9PmBVc2luZyAke3N0cmF0ZWd5TmFtZX0gdG8gcmVzcG9uZCB0byAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9J2AsXG4gICAgcHJpbnRGaW5hbFJlc3BvbnNlOiAocmVzcG9uc2UpPT57XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKFwiVmlldyB0aGUgZmluYWwgcmVzcG9uc2UgaGVyZS5cIik7XG4gICAgICAgICAgICBsb2dnZXIubG9nKHJlc3BvbnNlIHx8IFwiW05vIHJlc3BvbnNlIHJldHVybmVkXVwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY2xhc3MgTmV0d29ya0ZpcnN0IGV4dGVuZHMgU3RyYXRlZ3kge1xuICAgIF9uZXR3b3JrVGltZW91dFNlY29uZHM7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KXtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhpcy5wbHVnaW5zLnNvbWUoKHApPT5cImNhY2hlV2lsbFVwZGF0ZVwiIGluIHApKSB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMudW5zaGlmdChjYWNoZU9rQW5kT3BhcXVlUGx1Z2luKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZXR3b3JrVGltZW91dFNlY29uZHMgPSBvcHRpb25zLm5ldHdvcmtUaW1lb3V0U2Vjb25kcyB8fCAwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZSh0aGlzLl9uZXR3b3JrVGltZW91dFNlY29uZHMsIFwibnVtYmVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwibmV0d29ya1RpbWVvdXRTZWNvbmRzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgbG9ncyA9IFtdO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiaGFuZGxlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm1ha2VSZXF1ZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICAgIGlmICh0aGlzLl9uZXR3b3JrVGltZW91dFNlY29uZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHByb21pc2UgfSA9IHRoaXMuX2dldFRpbWVvdXRQcm9taXNlKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGxvZ3MsXG4gICAgICAgICAgICAgICAgaGFuZGxlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBpZDtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV0d29ya1Byb21pc2UgPSB0aGlzLl9nZXROZXR3b3JrUHJvbWlzZSh7XG4gICAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgbG9ncyxcbiAgICAgICAgICAgIGhhbmRsZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHByb21pc2VzLnB1c2gobmV0d29ya1Byb21pc2UpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIud2FpdFVudGlsKChhc3luYyAoKT0+e1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZXIud2FpdFVudGlsKFByb21pc2UucmFjZShwcm9taXNlcykpIHx8IGF3YWl0IG5ldHdvcmtQcm9taXNlO1xuICAgICAgICB9KSgpKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKG1lc3NhZ2VzLnN0cmF0ZWd5U3RhcnQodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxvZyBvZiBsb2dzKXtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGxvZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXNzYWdlcy5wcmludEZpbmFsUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcIm5vLXJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgICAgICB1cmw6IHJlcXVlc3QudXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIF9nZXRUaW1lb3V0UHJvbWlzZSh7IHJlcXVlc3QsIGxvZ3MsIGhhbmRsZXIgfSkge1xuICAgICAgICBsZXQgdGltZW91dElkO1xuICAgICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICAgICAgY29uc3Qgb25OZXR3b3JrVGltZW91dCA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dzLnB1c2goYFRpbWluZyBvdXQgdGhlIG5ldHdvcmsgcmVzcG9uc2UgYXQgJHt0aGlzLl9uZXR3b3JrVGltZW91dFNlY29uZHN9IHNlY29uZHMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoYXdhaXQgaGFuZGxlci5jYWNoZU1hdGNoKHJlcXVlc3QpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KG9uTmV0d29ya1RpbWVvdXQsIHRoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kcyAqIDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb21pc2U6IHRpbWVvdXRQcm9taXNlLFxuICAgICAgICAgICAgaWQ6IHRpbWVvdXRJZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBfZ2V0TmV0d29ya1Byb21pc2UoeyB0aW1lb3V0SWQsIHJlcXVlc3QsIGxvZ3MsIGhhbmRsZXIgfSkge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5mZXRjaEFuZENhY2hlUHV0KHJlcXVlc3QpO1xuICAgICAgICB9IGNhdGNoIChmZXRjaEVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZmV0Y2hFcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBmZXRjaEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxvZ3MucHVzaChcIkdvdCByZXNwb25zZSBmcm9tIG5ldHdvcmsuXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dzLnB1c2goXCJVbmFibGUgdG8gZ2V0IGEgcmVzcG9uc2UgZnJvbSB0aGUgbmV0d29yay4gV2lsbCByZXNwb25kIFwiICsgXCJ3aXRoIGEgY2FjaGVkIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgfHwgIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuY2FjaGVNYXRjaChyZXF1ZXN0KTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBGb3VuZCBhIGNhY2hlZCByZXNwb25zZSBpbiB0aGUgJyR7dGhpcy5jYWNoZU5hbWV9JyBjYWNoZS5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dzLnB1c2goYE5vIHJlc3BvbnNlIGZvdW5kIGluIHRoZSAnJHt0aGlzLmNhY2hlTmFtZX0nIGNhY2hlLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxufVxuXG5jbGFzcyBOZXR3b3JrT25seSBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICBfbmV0d29ya1RpbWVvdXRTZWNvbmRzO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9uZXR3b3JrVGltZW91dFNlY29uZHMgPSBvcHRpb25zLm5ldHdvcmtUaW1lb3V0U2Vjb25kcyB8fCAwO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcIl9oYW5kbGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuZmV0Y2gocmVxdWVzdClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAodGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSB0aW1lb3V0KHRoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kcyAqIDEwMDApO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGltZW91dFByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBQcm9taXNlLnJhY2UocHJvbWlzZXMpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGltZWQgb3V0IHRoZSBuZXR3b3JrIHJlc3BvbnNlIGFmdGVyICR7dGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzfSBzZWNvbmRzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChtZXNzYWdlcy5zdHJhdGVneVN0YXJ0KHRoaXMuY29uc3RydWN0b3IubmFtZSwgcmVxdWVzdCkpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIkdvdCByZXNwb25zZSBmcm9tIG5ldHdvcmsuXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiVW5hYmxlIHRvIGdldCBhIHJlc3BvbnNlIGZyb20gdGhlIG5ldHdvcmsuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZXMucHJpbnRGaW5hbFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJuby1yZXNwb25zZVwiLCB7XG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cblxuY29uc3QgQkFDS0dST1VORF9TWU5DX0RCX1ZFUlNJT04gPSAzO1xuY29uc3QgQkFDS0dST1VORF9TWU5DX0RCX05BTUUgPSBcInNlcndpc3QtYmFja2dyb3VuZC1zeW5jXCI7XG5jb25zdCBSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FID0gXCJyZXF1ZXN0c1wiO1xuY29uc3QgUVVFVUVfTkFNRV9JTkRFWCA9IFwicXVldWVOYW1lXCI7XG5jbGFzcyBCYWNrZ3JvdW5kU3luY1F1ZXVlRGIge1xuICAgIF9kYiA9IG51bGw7XG4gICAgYXN5bmMgYWRkRW50cnkoZW50cnkpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oUkVRVUVTVF9PQkpFQ1RfU1RPUkVfTkFNRSwgXCJyZWFkd3JpdGVcIiwge1xuICAgICAgICAgICAgZHVyYWJpbGl0eTogXCJyZWxheGVkXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHR4LnN0b3JlLmFkZChlbnRyeSk7XG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XG4gICAgfVxuICAgIGFzeW5jIGdldEZpcnN0RW50cnlJZCgpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIGNvbnN0IGN1cnNvciA9IGF3YWl0IGRiLnRyYW5zYWN0aW9uKFJFUVVFU1RfT0JKRUNUX1NUT1JFX05BTUUpLnN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcj8udmFsdWUuaWQ7XG4gICAgfVxuICAgIGFzeW5jIGdldEFsbEVudHJpZXNCeVF1ZXVlTmFtZShxdWV1ZU5hbWUpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBkYi5nZXRBbGxGcm9tSW5kZXgoUkVRVUVTVF9PQkpFQ1RfU1RPUkVfTkFNRSwgUVVFVUVfTkFNRV9JTkRFWCwgSURCS2V5UmFuZ2Uub25seShxdWV1ZU5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMgPyByZXN1bHRzIDogW107XG4gICAgfVxuICAgIGFzeW5jIGdldEVudHJ5Q291bnRCeVF1ZXVlTmFtZShxdWV1ZU5hbWUpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIHJldHVybiBkYi5jb3VudEZyb21JbmRleChSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FLCBRVUVVRV9OQU1FX0lOREVYLCBJREJLZXlSYW5nZS5vbmx5KHF1ZXVlTmFtZSkpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVFbnRyeShpZCkge1xuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0RGIoKTtcbiAgICAgICAgYXdhaXQgZGIuZGVsZXRlKFJFUVVFU1RfT0JKRUNUX1NUT1JFX05BTUUsIGlkKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Rmlyc3RFbnRyeUJ5UXVldWVOYW1lKHF1ZXVlTmFtZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRFbmRFbnRyeUZyb21JbmRleChJREJLZXlSYW5nZS5vbmx5KHF1ZXVlTmFtZSksIFwibmV4dFwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGFzdEVudHJ5QnlRdWV1ZU5hbWUocXVldWVOYW1lKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEVuZEVudHJ5RnJvbUluZGV4KElEQktleVJhbmdlLm9ubHkocXVldWVOYW1lKSwgXCJwcmV2XCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRFbmRFbnRyeUZyb21JbmRleChxdWVyeSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREYigpO1xuICAgICAgICBjb25zdCBjdXJzb3IgPSBhd2FpdCBkYi50cmFuc2FjdGlvbihSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FKS5zdG9yZS5pbmRleChRVUVVRV9OQU1FX0lOREVYKS5vcGVuQ3Vyc29yKHF1ZXJ5LCBkaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gY3Vyc29yPy52YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RiID0gYXdhaXQgb3BlbkRCKEJBQ0tHUk9VTkRfU1lOQ19EQl9OQU1FLCBCQUNLR1JPVU5EX1NZTkNfREJfVkVSU0lPTiwge1xuICAgICAgICAgICAgICAgIHVwZ3JhZGU6IHRoaXMuX3VwZ3JhZGVEYlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RiO1xuICAgIH1cbiAgICBfdXBncmFkZURiKGRiLCBvbGRWZXJzaW9uKSB7XG4gICAgICAgIGlmIChvbGRWZXJzaW9uID4gMCAmJiBvbGRWZXJzaW9uIDwgQkFDS0dST1VORF9TWU5DX0RCX1ZFUlNJT04pIHtcbiAgICAgICAgICAgIGlmIChkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKFJFUVVFU1RfT0JKRUNUX1NUT1JFX05BTUUpKSB7XG4gICAgICAgICAgICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoUkVRVUVTVF9PQkpFQ1RfU1RPUkVfTkFNRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FLCB7XG4gICAgICAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAga2V5UGF0aDogXCJpZFwiXG4gICAgICAgIH0pO1xuICAgICAgICBvYmpTdG9yZS5jcmVhdGVJbmRleChRVUVVRV9OQU1FX0lOREVYLCBRVUVVRV9OQU1FX0lOREVYLCB7XG4gICAgICAgICAgICB1bmlxdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgQmFja2dyb3VuZFN5bmNRdWV1ZVN0b3JlIHtcbiAgICBfcXVldWVOYW1lO1xuICAgIF9xdWV1ZURiO1xuICAgIGNvbnN0cnVjdG9yKHF1ZXVlTmFtZSl7XG4gICAgICAgIHRoaXMuX3F1ZXVlTmFtZSA9IHF1ZXVlTmFtZTtcbiAgICAgICAgdGhpcy5fcXVldWVEYiA9IG5ldyBCYWNrZ3JvdW5kU3luY1F1ZXVlRGIoKTtcbiAgICB9XG4gICAgYXN5bmMgcHVzaEVudHJ5KGVudHJ5KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUoZW50cnksIFwib2JqZWN0XCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQmFja2dyb3VuZFN5bmNRdWV1ZVN0b3JlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwicHVzaEVudHJ5XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImVudHJ5XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShlbnRyeS5yZXF1ZXN0RGF0YSwgXCJvYmplY3RcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCYWNrZ3JvdW5kU3luY1F1ZXVlU3RvcmVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJwdXNoRW50cnlcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiZW50cnkucmVxdWVzdERhdGFcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGVudHJ5LmlkO1xuICAgICAgICBlbnRyeS5xdWV1ZU5hbWUgPSB0aGlzLl9xdWV1ZU5hbWU7XG4gICAgICAgIGF3YWl0IHRoaXMuX3F1ZXVlRGIuYWRkRW50cnkoZW50cnkpO1xuICAgIH1cbiAgICBhc3luYyB1bnNoaWZ0RW50cnkoZW50cnkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShlbnRyeSwgXCJvYmplY3RcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCYWNrZ3JvdW5kU3luY1F1ZXVlU3RvcmVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJ1bnNoaWZ0RW50cnlcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiZW50cnlcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKGVudHJ5LnJlcXVlc3REYXRhLCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkJhY2tncm91bmRTeW5jUXVldWVTdG9yZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInVuc2hpZnRFbnRyeVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJlbnRyeS5yZXF1ZXN0RGF0YVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdElkID0gYXdhaXQgdGhpcy5fcXVldWVEYi5nZXRGaXJzdEVudHJ5SWQoKTtcbiAgICAgICAgaWYgKGZpcnN0SWQpIHtcbiAgICAgICAgICAgIGVudHJ5LmlkID0gZmlyc3RJZCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgZW50cnkuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZW50cnkucXVldWVOYW1lID0gdGhpcy5fcXVldWVOYW1lO1xuICAgICAgICBhd2FpdCB0aGlzLl9xdWV1ZURiLmFkZEVudHJ5KGVudHJ5KTtcbiAgICB9XG4gICAgYXN5bmMgcG9wRW50cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVFbnRyeShhd2FpdCB0aGlzLl9xdWV1ZURiLmdldExhc3RFbnRyeUJ5UXVldWVOYW1lKHRoaXMuX3F1ZXVlTmFtZSkpO1xuICAgIH1cbiAgICBhc3luYyBzaGlmdEVudHJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlRW50cnkoYXdhaXQgdGhpcy5fcXVldWVEYi5nZXRGaXJzdEVudHJ5QnlRdWV1ZU5hbWUodGhpcy5fcXVldWVOYW1lKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFsbCgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3F1ZXVlRGIuZ2V0QWxsRW50cmllc0J5UXVldWVOYW1lKHRoaXMuX3F1ZXVlTmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIHNpemUoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9xdWV1ZURiLmdldEVudHJ5Q291bnRCeVF1ZXVlTmFtZSh0aGlzLl9xdWV1ZU5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVFbnRyeShpZCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9xdWV1ZURiLmRlbGV0ZUVudHJ5KGlkKTtcbiAgICB9XG4gICAgYXN5bmMgX3JlbW92ZUVudHJ5KGVudHJ5KSB7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kZWxldGVFbnRyeShlbnRyeS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbn1cblxuY29uc3Qgc2VyaWFsaXphYmxlUHJvcGVydGllcyA9IFtcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwicmVmZXJyZXJcIixcbiAgICBcInJlZmVycmVyUG9saWN5XCIsXG4gICAgXCJtb2RlXCIsXG4gICAgXCJjcmVkZW50aWFsc1wiLFxuICAgIFwiY2FjaGVcIixcbiAgICBcInJlZGlyZWN0XCIsXG4gICAgXCJpbnRlZ3JpdHlcIixcbiAgICBcImtlZXBhbGl2ZVwiXG5dO1xuY2xhc3MgU3RvcmFibGVSZXF1ZXN0IHtcbiAgICBfcmVxdWVzdERhdGE7XG4gICAgc3RhdGljIGFzeW5jIGZyb21SZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdERhdGEgPSB7XG4gICAgICAgICAgICB1cmw6IHJlcXVlc3QudXJsLFxuICAgICAgICAgICAgaGVhZGVyczoge31cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSBcIkdFVFwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0RGF0YS5ib2R5ID0gYXdhaXQgcmVxdWVzdC5jbG9uZSgpLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpPT57XG4gICAgICAgICAgICByZXF1ZXN0RGF0YS5oZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzZXJpYWxpemFibGVQcm9wZXJ0aWVzKXtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0W3Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YVtwcm9wXSA9IHJlcXVlc3RbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdG9yYWJsZVJlcXVlc3QocmVxdWVzdERhdGEpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0RGF0YSl7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUocmVxdWVzdERhdGEsIFwib2JqZWN0XCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiU3RvcmFibGVSZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicmVxdWVzdERhdGFcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKHJlcXVlc3REYXRhLnVybCwgXCJzdHJpbmdcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJTdG9yYWJsZVJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyZXF1ZXN0RGF0YS51cmxcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3REYXRhLm1vZGUgPT09IFwibmF2aWdhdGVcIikge1xuICAgICAgICAgICAgcmVxdWVzdERhdGEubW9kZSA9IFwic2FtZS1vcmlnaW5cIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXF1ZXN0RGF0YSA9IHJlcXVlc3REYXRhO1xuICAgIH1cbiAgICB0b09iamVjdCgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdERhdGEgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXF1ZXN0RGF0YSk7XG4gICAgICAgIHJlcXVlc3REYXRhLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXF1ZXN0RGF0YS5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlcXVlc3REYXRhLmJvZHkpIHtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLmJvZHkgPSByZXF1ZXN0RGF0YS5ib2R5LnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0RGF0YTtcbiAgICB9XG4gICAgdG9SZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcy5fcmVxdWVzdERhdGEudXJsLCB0aGlzLl9yZXF1ZXN0RGF0YSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0b3JhYmxlUmVxdWVzdCh0aGlzLnRvT2JqZWN0KCkpO1xuICAgIH1cbn1cblxuY29uc3QgVEFHX1BSRUZJWCA9IFwic2Vyd2lzdC1iYWNrZ3JvdW5kLXN5bmNcIjtcbmNvbnN0IE1BWF9SRVRFTlRJT05fVElNRSA9IDYwICogMjQgKiA3O1xuY29uc3QgcXVldWVOYW1lcyA9IG5ldyBTZXQoKTtcbmNvbnN0IGNvbnZlcnRFbnRyeSA9IChxdWV1ZVN0b3JlRW50cnkpPT57XG4gICAgY29uc3QgcXVldWVFbnRyeSA9IHtcbiAgICAgICAgcmVxdWVzdDogbmV3IFN0b3JhYmxlUmVxdWVzdChxdWV1ZVN0b3JlRW50cnkucmVxdWVzdERhdGEpLnRvUmVxdWVzdCgpLFxuICAgICAgICB0aW1lc3RhbXA6IHF1ZXVlU3RvcmVFbnRyeS50aW1lc3RhbXBcbiAgICB9O1xuICAgIGlmIChxdWV1ZVN0b3JlRW50cnkubWV0YWRhdGEpIHtcbiAgICAgICAgcXVldWVFbnRyeS5tZXRhZGF0YSA9IHF1ZXVlU3RvcmVFbnRyeS5tZXRhZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXVlRW50cnk7XG59O1xuY2xhc3MgQmFja2dyb3VuZFN5bmNRdWV1ZSB7XG4gICAgX25hbWU7XG4gICAgX29uU3luYztcbiAgICBfbWF4UmV0ZW50aW9uVGltZTtcbiAgICBfcXVldWVTdG9yZTtcbiAgICBfZm9yY2VTeW5jRmFsbGJhY2s7XG4gICAgX3N5bmNJblByb2dyZXNzID0gZmFsc2U7XG4gICAgX3JlcXVlc3RzQWRkZWREdXJpbmdTeW5jID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IobmFtZSwgeyBmb3JjZVN5bmNGYWxsYmFjaywgb25TeW5jLCBtYXhSZXRlbnRpb25UaW1lIH0gPSB7fSl7XG4gICAgICAgIGlmIChxdWV1ZU5hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImR1cGxpY2F0ZS1xdWV1ZS1uYW1lXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZU5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX29uU3luYyA9IG9uU3luYyB8fCB0aGlzLnJlcGxheVJlcXVlc3RzO1xuICAgICAgICB0aGlzLl9tYXhSZXRlbnRpb25UaW1lID0gbWF4UmV0ZW50aW9uVGltZSB8fCBNQVhfUkVURU5USU9OX1RJTUU7XG4gICAgICAgIHRoaXMuX2ZvcmNlU3luY0ZhbGxiYWNrID0gQm9vbGVhbihmb3JjZVN5bmNGYWxsYmFjayk7XG4gICAgICAgIHRoaXMuX3F1ZXVlU3RvcmUgPSBuZXcgQmFja2dyb3VuZFN5bmNRdWV1ZVN0b3JlKHRoaXMuX25hbWUpO1xuICAgICAgICB0aGlzLl9hZGRTeW5jTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBhc3luYyBwdXNoUmVxdWVzdChlbnRyeSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKGVudHJ5LCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkJhY2tncm91bmRTeW5jUXVldWVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJwdXNoUmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJlbnRyeVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc0luc3RhbmNlKGVudHJ5LnJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQmFja2dyb3VuZFN5bmNRdWV1ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInB1c2hSZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImVudHJ5LnJlcXVlc3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fYWRkUmVxdWVzdChlbnRyeSwgXCJwdXNoXCIpO1xuICAgIH1cbiAgICBhc3luYyB1bnNoaWZ0UmVxdWVzdChlbnRyeSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKGVudHJ5LCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkJhY2tncm91bmRTeW5jUXVldWVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJ1bnNoaWZ0UmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJlbnRyeVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc0luc3RhbmNlKGVudHJ5LnJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQmFja2dyb3VuZFN5bmNRdWV1ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInVuc2hpZnRSZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImVudHJ5LnJlcXVlc3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fYWRkUmVxdWVzdChlbnRyeSwgXCJ1bnNoaWZ0XCIpO1xuICAgIH1cbiAgICBhc3luYyBwb3BSZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlUmVxdWVzdChcInBvcFwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2hpZnRSZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlUmVxdWVzdChcInNoaWZ0XCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBbGwoKSB7XG4gICAgICAgIGNvbnN0IGFsbEVudHJpZXMgPSBhd2FpdCB0aGlzLl9xdWV1ZVN0b3JlLmdldEFsbCgpO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCB1bmV4cGlyZWRFbnRyaWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgYWxsRW50cmllcyl7XG4gICAgICAgICAgICBjb25zdCBtYXhSZXRlbnRpb25UaW1lSW5NcyA9IHRoaXMuX21heFJldGVudGlvblRpbWUgKiA2MCAqIDEwMDA7XG4gICAgICAgICAgICBpZiAobm93IC0gZW50cnkudGltZXN0YW1wID4gbWF4UmV0ZW50aW9uVGltZUluTXMpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9xdWV1ZVN0b3JlLmRlbGV0ZUVudHJ5KGVudHJ5LmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5leHBpcmVkRW50cmllcy5wdXNoKGNvbnZlcnRFbnRyeShlbnRyeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmV4cGlyZWRFbnRyaWVzO1xuICAgIH1cbiAgICBhc3luYyBzaXplKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcXVldWVTdG9yZS5zaXplKCk7XG4gICAgfVxuICAgIGFzeW5jIF9hZGRSZXF1ZXN0KHsgcmVxdWVzdCwgbWV0YWRhdGEsIHRpbWVzdGFtcCA9IERhdGUubm93KCkgfSwgb3BlcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhYmxlUmVxdWVzdCA9IGF3YWl0IFN0b3JhYmxlUmVxdWVzdC5mcm9tUmVxdWVzdChyZXF1ZXN0LmNsb25lKCkpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhOiBzdG9yYWJsZVJlcXVlc3QudG9PYmplY3QoKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGVudHJ5Lm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKG9wZXJhdGlvbil7XG4gICAgICAgICAgICBjYXNlIFwicHVzaFwiOlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3F1ZXVlU3RvcmUucHVzaEVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1bnNoaWZ0XCI6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcXVldWVTdG9yZS51bnNoaWZ0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlcXVlc3QgZm9yICcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nIGhhcyBgICsgYGJlZW4gYWRkZWQgdG8gYmFja2dyb3VuZCBzeW5jIHF1ZXVlICcke3RoaXMuX25hbWV9Jy5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzQWRkZWREdXJpbmdTeW5jID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0ZXJTeW5jKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3JlbW92ZVJlcXVlc3Qob3BlcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCBlbnRyeTtcbiAgICAgICAgc3dpdGNoKG9wZXJhdGlvbil7XG4gICAgICAgICAgICBjYXNlIFwicG9wXCI6XG4gICAgICAgICAgICAgICAgZW50cnkgPSBhd2FpdCB0aGlzLl9xdWV1ZVN0b3JlLnBvcEVudHJ5KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2hpZnRcIjpcbiAgICAgICAgICAgICAgICBlbnRyeSA9IGF3YWl0IHRoaXMuX3F1ZXVlU3RvcmUuc2hpZnRFbnRyeSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY29uc3QgbWF4UmV0ZW50aW9uVGltZUluTXMgPSB0aGlzLl9tYXhSZXRlbnRpb25UaW1lICogNjAgKiAxMDAwO1xuICAgICAgICAgICAgaWYgKG5vdyAtIGVudHJ5LnRpbWVzdGFtcCA+IG1heFJldGVudGlvblRpbWVJbk1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZVJlcXVlc3Qob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIHJlcGxheVJlcXVlc3RzKCkge1xuICAgICAgICBsZXQgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gYXdhaXQgdGhpcy5zaGlmdFJlcXVlc3QoKSl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGZldGNoKGVudHJ5LnJlcXVlc3QuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBSZXF1ZXN0IGZvciAnJHtnZXRGcmllbmRseVVSTChlbnRyeS5yZXF1ZXN0LnVybCl9JyBgICsgYGhhcyBiZWVuIHJlcGxheWVkIGluIHF1ZXVlICcke3RoaXMuX25hbWV9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVuc2hpZnRSZXF1ZXN0KGVudHJ5KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlcXVlc3QgZm9yICcke2dldEZyaWVuZGx5VVJMKGVudHJ5LnJlcXVlc3QudXJsKX0nIGAgKyBgZmFpbGVkIHRvIHJlcGxheSwgcHV0dGluZyBpdCBiYWNrIGluIHF1ZXVlICcke3RoaXMuX25hbWV9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwicXVldWUtcmVwbGF5LWZhaWxlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX25hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBBbGwgcmVxdWVzdHMgaW4gcXVldWUgJyR7dGhpcy5uYW1lfScgaGF2ZSBzdWNjZXNzZnVsbHkgcmVwbGF5ZWQ7IHRoZSBxdWV1ZSBpcyBub3cgZW1wdHkhYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVnaXN0ZXJTeW5jKCkge1xuICAgICAgICBpZiAoXCJzeW5jXCIgaW4gc2VsZi5yZWdpc3RyYXRpb24gJiYgIXRoaXMuX2ZvcmNlU3luY0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGYucmVnaXN0cmF0aW9uLnN5bmMucmVnaXN0ZXIoYCR7VEFHX1BSRUZJWH06JHt0aGlzLl9uYW1lfWApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVW5hYmxlIHRvIHJlZ2lzdGVyIHN5bmMgZXZlbnQgZm9yICcke3RoaXMuX25hbWV9Jy5gLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkU3luY0xpc3RlbmVyKCkge1xuICAgICAgICBpZiAoXCJzeW5jXCIgaW4gc2VsZi5yZWdpc3RyYXRpb24gJiYgIXRoaXMuX2ZvcmNlU3luY0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJzeW5jXCIsIChldmVudCk9PntcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnID09PSBgJHtUQUdfUFJFRklYfToke3RoaXMuX25hbWV9YCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBCYWNrZ3JvdW5kIHN5bmMgZm9yIHRhZyAnJHtldmVudC50YWd9JyBoYXMgYmVlbiByZWNlaXZlZGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNDb21wbGV0ZSA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zeW5jSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3luY0Vycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9vblN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3luY0Vycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVxdWVzdHNBZGRlZER1cmluZ1N5bmMgJiYgIShzeW5jRXJyb3IgJiYgIWV2ZW50Lmxhc3RDaGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0ZXJTeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N5bmNJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHNBZGRlZER1cmluZ1N5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQud2FpdFVudGlsKHN5bmNDb21wbGV0ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiQmFja2dyb3VuZCBzeW5jIHJlcGxheWluZyB3aXRob3V0IGJhY2tncm91bmQgc3luYyBldmVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZvaWQgdGhpcy5fb25TeW5jKHtcbiAgICAgICAgICAgICAgICBxdWV1ZTogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldCBfcXVldWVOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlTmFtZXM7XG4gICAgfVxufVxuXG5jbGFzcyBCYWNrZ3JvdW5kU3luY1BsdWdpbiB7XG4gICAgX3F1ZXVlO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbnMpe1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBCYWNrZ3JvdW5kU3luY1F1ZXVlKG5hbWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaERpZEZhaWwoeyByZXF1ZXN0IH0pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcXVldWUucHVzaFJlcXVlc3Qoe1xuICAgICAgICAgICAgcmVxdWVzdFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IGNvcHlSZXNwb25zZSA9IGFzeW5jIChyZXNwb25zZSwgbW9kaWZpZXIpPT57XG4gICAgbGV0IG9yaWdpbiA9IG51bGw7XG4gICAgaWYgKHJlc3BvbnNlLnVybCkge1xuICAgICAgICBjb25zdCByZXNwb25zZVVSTCA9IG5ldyBVUkwocmVzcG9uc2UudXJsKTtcbiAgICAgICAgb3JpZ2luID0gcmVzcG9uc2VVUkwub3JpZ2luO1xuICAgIH1cbiAgICBpZiAob3JpZ2luICE9PSBzZWxmLmxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiY3Jvc3Mtb3JpZ2luLWNvcHktcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgb3JpZ2luXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgY29uc3QgcmVzcG9uc2VJbml0ID0ge1xuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhjbG9uZWRSZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgc3RhdHVzOiBjbG9uZWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IGNsb25lZFJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICB9O1xuICAgIGNvbnN0IG1vZGlmaWVkUmVzcG9uc2VJbml0ID0gbW9kaWZpZXIgPyBtb2RpZmllcihyZXNwb25zZUluaXQpIDogcmVzcG9uc2VJbml0O1xuICAgIGNvbnN0IGJvZHkgPSBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtKCkgPyBjbG9uZWRSZXNwb25zZS5ib2R5IDogYXdhaXQgY2xvbmVkUmVzcG9uc2UuYmxvYigpO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwgbW9kaWZpZWRSZXNwb25zZUluaXQpO1xufTtcblxuY2xhc3MgUHJlY2FjaGVTdHJhdGVneSBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICBfZmFsbGJhY2tUb05ldHdvcms7XG4gICAgc3RhdGljIGRlZmF1bHRQcmVjYWNoZUNhY2hlYWJpbGl0eVBsdWdpbiA9IHtcbiAgICAgICAgYXN5bmMgY2FjaGVXaWxsVXBkYXRlICh7IHJlc3BvbnNlIH0pIHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UgfHwgcmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzdGF0aWMgY29weVJlZGlyZWN0ZWRDYWNoZWFibGVSZXNwb25zZXNQbHVnaW4gPSB7XG4gICAgICAgIGFzeW5jIGNhY2hlV2lsbFVwZGF0ZSAoeyByZXNwb25zZSB9KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UucmVkaXJlY3RlZCA/IGF3YWl0IGNvcHlSZXNwb25zZShyZXNwb25zZSkgOiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KXtcbiAgICAgICAgb3B0aW9ucy5jYWNoZU5hbWUgPSBjYWNoZU5hbWVzLmdldFByZWNhY2hlTmFtZShvcHRpb25zLmNhY2hlTmFtZSk7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9mYWxsYmFja1RvTmV0d29yayA9IG9wdGlvbnMuZmFsbGJhY2tUb05ldHdvcmsgIT09IGZhbHNlO1xuICAgICAgICB0aGlzLnBsdWdpbnMucHVzaChQcmVjYWNoZVN0cmF0ZWd5LmNvcHlSZWRpcmVjdGVkQ2FjaGVhYmxlUmVzcG9uc2VzUGx1Z2luKTtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZShyZXF1ZXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHByZWxvYWRSZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuZ2V0UHJlbG9hZFJlc3BvbnNlKCk7XG4gICAgICAgIGlmIChwcmVsb2FkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVsb2FkUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVyLmV2ZW50ICYmIGhhbmRsZXIuZXZlbnQudHlwZSA9PT0gXCJpbnN0YWxsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9oYW5kbGVJbnN0YWxsKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9oYW5kbGVGZXRjaChyZXF1ZXN0LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZUZldGNoKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBoYW5kbGVyLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgaWYgKHRoaXMuX2ZhbGxiYWNrVG9OZXR3b3JrKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRoZSBwcmVjYWNoZWQgcmVzcG9uc2UgZm9yICR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfSBpbiAke3RoaXMuY2FjaGVOYW1lfSB3YXMgbm90IGZvdW5kLiBGYWxsaW5nIGJhY2sgdG8gdGhlIG5ldHdvcmsuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnRlZ3JpdHlJbk1hbmlmZXN0ID0gcGFyYW1zLmludGVncml0eTtcbiAgICAgICAgICAgIGNvbnN0IGludGVncml0eUluUmVxdWVzdCA9IHJlcXVlc3QuaW50ZWdyaXR5O1xuICAgICAgICAgICAgY29uc3Qgbm9JbnRlZ3JpdHlDb25mbGljdCA9ICFpbnRlZ3JpdHlJblJlcXVlc3QgfHwgaW50ZWdyaXR5SW5SZXF1ZXN0ID09PSBpbnRlZ3JpdHlJbk1hbmlmZXN0O1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmZldGNoKG5ldyBSZXF1ZXN0KHJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHJlcXVlc3QubW9kZSAhPT0gXCJuby1jb3JzXCIgPyBpbnRlZ3JpdHlJblJlcXVlc3QgfHwgaW50ZWdyaXR5SW5NYW5pZmVzdCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGludGVncml0eUluTWFuaWZlc3QgJiYgbm9JbnRlZ3JpdHlDb25mbGljdCAmJiByZXF1ZXN0Lm1vZGUgIT09IFwibm8tY29yc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdENhY2hlYWJpbGl0eVBsdWdpbklmTmVlZGVkKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FzQ2FjaGVkID0gYXdhaXQgaGFuZGxlci5jYWNoZVB1dChyZXF1ZXN0LCByZXNwb25zZS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXNDYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYEEgcmVzcG9uc2UgZm9yICR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfSB3YXMgdXNlZCB0byBcInJlcGFpclwiIHRoZSBwcmVjYWNoZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJtaXNzaW5nLXByZWNhY2hlLWVudHJ5XCIsIHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWU6IHRoaXMuY2FjaGVOYW1lLFxuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gcGFyYW1zLmNhY2hlS2V5IHx8IGF3YWl0IGhhbmRsZXIuZ2V0Q2FjaGVLZXkocmVxdWVzdCwgXCJyZWFkXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBQcmVjYWNoaW5nIGlzIHJlc3BvbmRpbmcgdG86ICR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfWApO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU2VydmluZyB0aGUgcHJlY2FjaGVkIHVybDogJHtnZXRGcmllbmRseVVSTChjYWNoZUtleSBpbnN0YW5jZW9mIFJlcXVlc3QgPyBjYWNoZUtleS51cmwgOiBjYWNoZUtleSl9YCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoXCJWaWV3IHJlcXVlc3QgZGV0YWlscyBoZXJlLlwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVxdWVzdCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChcIlZpZXcgcmVzcG9uc2UgZGV0YWlscyBoZXJlLlwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGVJbnN0YWxsKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fdXNlRGVmYXVsdENhY2hlYWJpbGl0eVBsdWdpbklmTmVlZGVkKCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5mZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3Qgd2FzQ2FjaGVkID0gYXdhaXQgaGFuZGxlci5jYWNoZVB1dChyZXF1ZXN0LCByZXNwb25zZS5jbG9uZSgpKTtcbiAgICAgICAgaWYgKCF3YXNDYWNoZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJiYWQtcHJlY2FjaGluZy1yZXNwb25zZVwiLCB7XG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBfdXNlRGVmYXVsdENhY2hlYWJpbGl0eVBsdWdpbklmTmVlZGVkKCkge1xuICAgICAgICBsZXQgZGVmYXVsdFBsdWdpbkluZGV4ID0gbnVsbDtcbiAgICAgICAgbGV0IGNhY2hlV2lsbFVwZGF0ZVBsdWdpbkNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIHBsdWdpbl0gb2YgdGhpcy5wbHVnaW5zLmVudHJpZXMoKSl7XG4gICAgICAgICAgICBpZiAocGx1Z2luID09PSBQcmVjYWNoZVN0cmF0ZWd5LmNvcHlSZWRpcmVjdGVkQ2FjaGVhYmxlUmVzcG9uc2VzUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGx1Z2luID09PSBQcmVjYWNoZVN0cmF0ZWd5LmRlZmF1bHRQcmVjYWNoZUNhY2hlYWJpbGl0eVBsdWdpbikge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRQbHVnaW5JbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsdWdpbi5jYWNoZVdpbGxVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVdpbGxVcGRhdGVQbHVnaW5Db3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZVdpbGxVcGRhdGVQbHVnaW5Db3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2goUHJlY2FjaGVTdHJhdGVneS5kZWZhdWx0UHJlY2FjaGVDYWNoZWFiaWxpdHlQbHVnaW4pO1xuICAgICAgICB9IGVsc2UgaWYgKGNhY2hlV2lsbFVwZGF0ZVBsdWdpbkNvdW50ID4gMSAmJiBkZWZhdWx0UGx1Z2luSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucy5zcGxpY2UoZGVmYXVsdFBsdWdpbkluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgaXNOYXZpZ2F0aW9uUHJlbG9hZFN1cHBvcnRlZCA9ICgpPT57XG4gICAgcmV0dXJuIEJvb2xlYW4oc2VsZi5yZWdpc3RyYXRpb24/Lm5hdmlnYXRpb25QcmVsb2FkKTtcbn07XG5jb25zdCBlbmFibGVOYXZpZ2F0aW9uUHJlbG9hZCA9IChoZWFkZXJWYWx1ZSk9PntcbiAgICBpZiAoaXNOYXZpZ2F0aW9uUHJlbG9hZFN1cHBvcnRlZCgpKSB7XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImFjdGl2YXRlXCIsIChldmVudCk9PntcbiAgICAgICAgICAgIGV2ZW50LndhaXRVbnRpbChzZWxmLnJlZ2lzdHJhdGlvbi5uYXZpZ2F0aW9uUHJlbG9hZC5lbmFibGUoKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlclZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWQgc2VsZi5yZWdpc3RyYXRpb24ubmF2aWdhdGlvblByZWxvYWQuc2V0SGVhZGVyVmFsdWUoaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJOYXZpZ2F0aW9uIHByZWxvYWRpbmcgaXMgZW5hYmxlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKFwiTmF2aWdhdGlvbiBwcmVsb2FkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBkaXNhYmxlTmF2aWdhdGlvblByZWxvYWQgPSAoKT0+e1xuICAgIGlmIChpc05hdmlnYXRpb25QcmVsb2FkU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiYWN0aXZhdGVcIiwgKGV2ZW50KT0+e1xuICAgICAgICAgICAgZXZlbnQud2FpdFVudGlsKHNlbGYucmVnaXN0cmF0aW9uLm5hdmlnYXRpb25QcmVsb2FkLmRpc2FibGUoKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiTmF2aWdhdGlvbiBwcmVsb2FkaW5nIGlzIGRpc2FibGVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJOYXZpZ2F0aW9uIHByZWxvYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3Qgc2V0Q2FjaGVOYW1lRGV0YWlscyA9IChkZXRhaWxzKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZGV0YWlscykpe1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShkZXRhaWxzW2tleV0sIFwic3RyaW5nXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L2NvcmVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJzZXRDYWNoZU5hbWVEZXRhaWxzXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBgZGV0YWlscy4ke2tleX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlscy5wcmVjYWNoZT8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiaW52YWxpZC1jYWNoZS1uYW1lXCIsIHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWVJZDogXCJwcmVjYWNoZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkZXRhaWxzLnByZWNhY2hlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlscy5ydW50aW1lPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJpbnZhbGlkLWNhY2hlLW5hbWVcIiwge1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZUlkOiBcInJ1bnRpbWVcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGV0YWlscy5ydW50aW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlscy5nb29nbGVBbmFseXRpY3M/Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImludmFsaWQtY2FjaGUtbmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgY2FjaGVOYW1lSWQ6IFwiZ29vZ2xlQW5hbHl0aWNzXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRldGFpbHMuZ29vZ2xlQW5hbHl0aWNzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWNoZU5hbWVzLnVwZGF0ZURldGFpbHMoZGV0YWlscyk7XG59O1xuXG5jbGFzcyBQcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4ge1xuICAgIHVwZGF0ZWRVUkxzID0gW107XG4gICAgbm90VXBkYXRlZFVSTHMgPSBbXTtcbiAgICBoYW5kbGVyV2lsbFN0YXJ0ID0gYXN5bmMgKHsgcmVxdWVzdCwgc3RhdGUgfSk9PntcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcmlnaW5hbFJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjYWNoZWRSZXNwb25zZVdpbGxCZVVzZWQgPSBhc3luYyAoeyBldmVudCwgc3RhdGUsIGNhY2hlZFJlc3BvbnNlIH0pPT57XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcImluc3RhbGxcIikge1xuICAgICAgICAgICAgaWYgKHN0YXRlPy5vcmlnaW5hbFJlcXVlc3QgJiYgc3RhdGUub3JpZ2luYWxSZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHN0YXRlLm9yaWdpbmFsUmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90VXBkYXRlZFVSTHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlZFVSTHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzcG9uc2U7XG4gICAgfTtcbn1cblxuY29uc3QgUkVWSVNJT05fU0VBUkNIX1BBUkFNID0gXCJfX1dCX1JFVklTSU9OX19cIjtcbmNvbnN0IGNyZWF0ZUNhY2hlS2V5ID0gKGVudHJ5KT0+e1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImFkZC10by1jYWNoZS1saXN0LXVuZXhwZWN0ZWQtdHlwZVwiLCB7XG4gICAgICAgICAgICBlbnRyeVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKGVudHJ5LCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhY2hlS2V5OiB1cmxPYmplY3QuaHJlZixcbiAgICAgICAgICAgIHVybDogdXJsT2JqZWN0LmhyZWZcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyByZXZpc2lvbiwgdXJsIH0gPSBlbnRyeTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiYWRkLXRvLWNhY2hlLWxpc3QtdW5leHBlY3RlZC10eXBlXCIsIHtcbiAgICAgICAgICAgIGVudHJ5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXJldmlzaW9uKSB7XG4gICAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhY2hlS2V5OiB1cmxPYmplY3QuaHJlZixcbiAgICAgICAgICAgIHVybDogdXJsT2JqZWN0LmhyZWZcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVLZXlVUkwgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgY29uc3Qgb3JpZ2luYWxVUkwgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgY2FjaGVLZXlVUkwuc2VhcmNoUGFyYW1zLnNldChSRVZJU0lPTl9TRUFSQ0hfUEFSQU0sIHJldmlzaW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYWNoZUtleTogY2FjaGVLZXlVUkwuaHJlZixcbiAgICAgICAgdXJsOiBvcmlnaW5hbFVSTC5ocmVmXG4gICAgfTtcbn07XG5cbmNvbnN0IHBhcnNlUm91dGUgPSAoY2FwdHVyZSwgaGFuZGxlciwgbWV0aG9kKT0+e1xuICAgIGlmICh0eXBlb2YgY2FwdHVyZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBjYXB0dXJlVXJsID0gbmV3IFVSTChjYXB0dXJlLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCEoY2FwdHVyZS5zdGFydHNXaXRoKFwiL1wiKSB8fCBjYXB0dXJlLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJpbnZhbGlkLXN0cmluZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJwYXJzZVJvdXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjYXB0dXJlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVG9DaGVjayA9IGNhcHR1cmUuc3RhcnRzV2l0aChcImh0dHBcIikgPyBjYXB0dXJlVXJsLnBhdGhuYW1lIDogY2FwdHVyZTtcbiAgICAgICAgICAgIGNvbnN0IHdpbGRjYXJkcyA9IFwiWyo6PytdXCI7XG4gICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChgJHt3aWxkY2FyZHN9YCkuZXhlYyh2YWx1ZVRvQ2hlY2spKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaGUgJyRjYXB0dXJlJyBwYXJhbWV0ZXIgY29udGFpbnMgYW4gRXhwcmVzcy1zdHlsZSB3aWxkY2FyZCBjaGFyYWN0ZXIgKCR7d2lsZGNhcmRzfSkuIFN0cmluZ3MgYXJlIG5vdyBhbHdheXMgaW50ZXJwcmV0ZWQgYXMgZXhhY3QgbWF0Y2hlczsgdXNlIGEgUmVnRXhwIGZvciBwYXJ0aWFsIG9yIHdpbGRjYXJkIG1hdGNoZXMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hDYWxsYmFjayA9ICh7IHVybCB9KT0+e1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICh1cmwucGF0aG5hbWUgPT09IGNhcHR1cmVVcmwucGF0aG5hbWUgJiYgdXJsLm9yaWdpbiAhPT0gY2FwdHVyZVVybC5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGAke2NhcHR1cmV9IG9ubHkgcGFydGlhbGx5IG1hdGNoZXMgdGhlIGNyb3NzLW9yaWdpbiBVUkwgJHt1cmwudG9TdHJpbmcoKX0uIFRoaXMgcm91dGUgd2lsbCBvbmx5IGhhbmRsZSBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgaWYgdGhleSBtYXRjaCB0aGUgZW50aXJlIFVSTC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsLmhyZWYgPT09IGNhcHR1cmVVcmwuaHJlZjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3V0ZShtYXRjaENhbGxiYWNrLCBoYW5kbGVyLCBtZXRob2QpO1xuICAgIH1cbiAgICBpZiAoY2FwdHVyZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cFJvdXRlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FwdHVyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUm91dGUoY2FwdHVyZSwgaGFuZGxlciwgbWV0aG9kKTtcbiAgICB9XG4gICAgaWYgKGNhcHR1cmUgaW5zdGFuY2VvZiBSb3V0ZSkge1xuICAgICAgICByZXR1cm4gY2FwdHVyZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcInVuc3VwcG9ydGVkLXJvdXRlLXR5cGVcIiwge1xuICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgZnVuY05hbWU6IFwicGFyc2VSb3V0ZVwiLFxuICAgICAgICBwYXJhbU5hbWU6IFwiY2FwdHVyZVwiXG4gICAgfSk7XG59O1xuXG5jb25zdCBsb2dHcm91cCA9IChncm91cFRpdGxlLCBkZWxldGVkVVJMcyk9PntcbiAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoZ3JvdXBUaXRsZSk7XG4gICAgZm9yIChjb25zdCB1cmwgb2YgZGVsZXRlZFVSTHMpe1xuICAgICAgICBsb2dnZXIubG9nKHVybCk7XG4gICAgfVxuICAgIGxvZ2dlci5ncm91cEVuZCgpO1xufTtcbmNvbnN0IHByaW50Q2xlYW51cERldGFpbHMgPSAoZGVsZXRlZFVSTHMpPT57XG4gICAgY29uc3QgZGVsZXRpb25Db3VudCA9IGRlbGV0ZWRVUkxzLmxlbmd0aDtcbiAgICBpZiAoZGVsZXRpb25Db3VudCA+IDApIHtcbiAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBEdXJpbmcgcHJlY2FjaGluZyBjbGVhbnVwLCAke2RlbGV0aW9uQ291bnR9IGNhY2hlZCByZXF1ZXN0JHtkZWxldGlvbkNvdW50ID09PSAxID8gXCIgd2FzXCIgOiBcInMgd2VyZVwifSBkZWxldGVkLmApO1xuICAgICAgICBsb2dHcm91cChcIkRlbGV0ZWQgQ2FjaGUgUmVxdWVzdHNcIiwgZGVsZXRlZFVSTHMpO1xuICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBfbmVzdGVkR3JvdXAoZ3JvdXBUaXRsZSwgdXJscykge1xuICAgIGlmICh1cmxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChncm91cFRpdGxlKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKXtcbiAgICAgICAgbG9nZ2VyLmxvZyh1cmwpO1xuICAgIH1cbiAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbn1cbmNvbnN0IHByaW50SW5zdGFsbERldGFpbHMgPSAodXJsc1RvUHJlY2FjaGUsIHVybHNBbHJlYWR5UHJlY2FjaGVkKT0+e1xuICAgIGNvbnN0IHByZWNhY2hlZENvdW50ID0gdXJsc1RvUHJlY2FjaGUubGVuZ3RoO1xuICAgIGNvbnN0IGFscmVhZHlQcmVjYWNoZWRDb3VudCA9IHVybHNBbHJlYWR5UHJlY2FjaGVkLmxlbmd0aDtcbiAgICBpZiAocHJlY2FjaGVkQ291bnQgfHwgYWxyZWFkeVByZWNhY2hlZENvdW50KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gYFByZWNhY2hpbmcgJHtwcmVjYWNoZWRDb3VudH0gZmlsZSR7cHJlY2FjaGVkQ291bnQgPT09IDEgPyBcIlwiIDogXCJzXCJ9LmA7XG4gICAgICAgIGlmIChhbHJlYWR5UHJlY2FjaGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGAgJHthbHJlYWR5UHJlY2FjaGVkQ291bnR9IGAgKyBgZmlsZSR7YWxyZWFkeVByZWNhY2hlZENvdW50ID09PSAxID8gXCIgaXNcIiA6IFwicyBhcmVcIn0gYWxyZWFkeSBjYWNoZWQuYDtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZSk7XG4gICAgICAgIF9uZXN0ZWRHcm91cChcIlZpZXcgbmV3bHkgcHJlY2FjaGVkIFVSTHMuXCIsIHVybHNUb1ByZWNhY2hlKTtcbiAgICAgICAgX25lc3RlZEdyb3VwKFwiVmlldyBwcmV2aW91c2x5IHByZWNhY2hlZCBVUkxzLlwiLCB1cmxzQWxyZWFkeVByZWNhY2hlZCk7XG4gICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IEJhY2tncm91bmRTeW5jUGx1Z2luIGFzIEIsIE5ldHdvcmtGaXJzdCBhcyBOLCBQcmVjYWNoZVN0cmF0ZWd5IGFzIFAsIFJvdXRlIGFzIFIsIFN0cmF0ZWd5IGFzIFMsIE5ldHdvcmtPbmx5IGFzIGEsIE5hdmlnYXRpb25Sb3V0ZSBhcyBiLCBjcmVhdGVDYWNoZUtleSBhcyBjLCBkaXNhYmxlRGV2TG9ncyBhcyBkLCBlbmFibGVOYXZpZ2F0aW9uUHJlbG9hZCBhcyBlLCBkZWZhdWx0TWV0aG9kIGFzIGYsIGdlbmVyYXRlVVJMVmFyaWF0aW9ucyBhcyBnLCBQcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4gYXMgaCwgcGFyYWxsZWwgYXMgaSwgcHJpbnRJbnN0YWxsRGV0YWlscyBhcyBqLCBwcmludENsZWFudXBEZXRhaWxzIGFzIGssIGNhY2hlT2tBbmRPcGFxdWVQbHVnaW4gYXMgbCwgbWVzc2FnZXMgYXMgbSwgbm9ybWFsaXplSGFuZGxlciBhcyBuLCBjb3B5UmVzcG9uc2UgYXMgbywgcGFyc2VSb3V0ZSBhcyBwLCBkaXNhYmxlTmF2aWdhdGlvblByZWxvYWQgYXMgcSwgaXNOYXZpZ2F0aW9uUHJlbG9hZFN1cHBvcnRlZCBhcyByLCBzZXRDYWNoZU5hbWVEZXRhaWxzIGFzIHMsIFN0cmF0ZWd5SGFuZGxlciBhcyB0LCBSZWdFeHBSb3V0ZSBhcyB1LCBCYWNrZ3JvdW5kU3luY1F1ZXVlIGFzIHYsIEJhY2tncm91bmRTeW5jUXVldWVTdG9yZSBhcyB3LCBTdG9yYWJsZVJlcXVlc3QgYXMgeCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/serwist/dist/chunks/printInstallDetails.js\n"));

/***/ }),

/***/ "./node_modules/serwist/dist/chunks/resultingClientExists.js":
/*!*******************************************************************!*\
  !*** ./node_modules/serwist/dist/chunks/resultingClientExists.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   r: () => (/* binding */ resultingClientExists)\n/* harmony export */ });\n/* harmony import */ var _waitUntil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./waitUntil.js */ \"./node_modules/serwist/dist/chunks/waitUntil.js\");\n\n\nconst MAX_RETRY_TIME = 2000;\nasync function resultingClientExists(resultingClientId) {\n    if (!resultingClientId) {\n        return;\n    }\n    let existingWindows = await self.clients.matchAll({\n        type: \"window\"\n    });\n    const existingWindowIds = new Set(existingWindows.map((w)=>w.id));\n    let resultingWindow;\n    const startTime = performance.now();\n    while(performance.now() - startTime < MAX_RETRY_TIME){\n        existingWindows = await self.clients.matchAll({\n            type: \"window\"\n        });\n        resultingWindow = existingWindows.find((w)=>{\n            if (resultingClientId) {\n                return w.id === resultingClientId;\n            }\n            return !existingWindowIds.has(w.id);\n        });\n        if (resultingWindow) {\n            break;\n        }\n        await (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_0__.t)(100);\n    }\n    return resultingWindow;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2Vyd2lzdC9kaXN0L2NodW5rcy9yZXN1bHRpbmdDbGllbnRFeGlzdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0RBQU87QUFDckI7QUFDQTtBQUNBOztBQUVzQyIsInNvdXJjZXMiOlsiL2hvbWUvbnl4L1dvcmtzcGFjZS9Pc3VjL1ViaUNhdGUtdjIvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3MvcmVzdWx0aW5nQ2xpZW50RXhpc3RzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHQgYXMgdGltZW91dCB9IGZyb20gJy4vd2FpdFVudGlsLmpzJztcblxuY29uc3QgTUFYX1JFVFJZX1RJTUUgPSAyMDAwO1xuYXN5bmMgZnVuY3Rpb24gcmVzdWx0aW5nQ2xpZW50RXhpc3RzKHJlc3VsdGluZ0NsaWVudElkKSB7XG4gICAgaWYgKCFyZXN1bHRpbmdDbGllbnRJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBleGlzdGluZ1dpbmRvd3MgPSBhd2FpdCBzZWxmLmNsaWVudHMubWF0Y2hBbGwoe1xuICAgICAgICB0eXBlOiBcIndpbmRvd1wiXG4gICAgfSk7XG4gICAgY29uc3QgZXhpc3RpbmdXaW5kb3dJZHMgPSBuZXcgU2V0KGV4aXN0aW5nV2luZG93cy5tYXAoKHcpPT53LmlkKSk7XG4gICAgbGV0IHJlc3VsdGluZ1dpbmRvdztcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB3aGlsZShwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSA8IE1BWF9SRVRSWV9USU1FKXtcbiAgICAgICAgZXhpc3RpbmdXaW5kb3dzID0gYXdhaXQgc2VsZi5jbGllbnRzLm1hdGNoQWxsKHtcbiAgICAgICAgICAgIHR5cGU6IFwid2luZG93XCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdGluZ1dpbmRvdyA9IGV4aXN0aW5nV2luZG93cy5maW5kKCh3KT0+e1xuICAgICAgICAgICAgaWYgKHJlc3VsdGluZ0NsaWVudElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHcuaWQgPT09IHJlc3VsdGluZ0NsaWVudElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFleGlzdGluZ1dpbmRvd0lkcy5oYXMody5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0aW5nV2luZG93KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aW1lb3V0KDEwMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRpbmdXaW5kb3c7XG59XG5cbmV4cG9ydCB7IHJlc3VsdGluZ0NsaWVudEV4aXN0cyBhcyByIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/serwist/dist/chunks/resultingClientExists.js\n"));

/***/ }),

/***/ "./node_modules/serwist/dist/chunks/waitUntil.js":
/*!*******************************************************!*\
  !*** ./node_modules/serwist/dist/chunks/waitUntil.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: () => (/* binding */ Deferred),\n/* harmony export */   S: () => (/* binding */ SerwistError),\n/* harmony export */   a: () => (/* binding */ clientsClaim),\n/* harmony export */   b: () => (/* binding */ cleanupOutdatedCaches),\n/* harmony export */   c: () => (/* binding */ cacheNames),\n/* harmony export */   d: () => (/* binding */ cacheMatchIgnoreParams),\n/* harmony export */   e: () => (/* binding */ executeQuotaErrorCallbacks),\n/* harmony export */   f: () => (/* binding */ finalAssertExports),\n/* harmony export */   g: () => (/* binding */ getFriendlyURL),\n/* harmony export */   h: () => (/* binding */ canConstructResponseFromBodyStream),\n/* harmony export */   l: () => (/* binding */ logger),\n/* harmony export */   q: () => (/* binding */ quotaErrorCallbacks),\n/* harmony export */   t: () => (/* binding */ timeout),\n/* harmony export */   w: () => (/* binding */ waitUntil)\n/* harmony export */ });\nconst messages = {\n    \"invalid-value\": ({ paramName, validValueDescription, value })=>{\n        if (!paramName || !validValueDescription) {\n            throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n    },\n    \"not-an-array\": ({ moduleName, className, funcName, paramName })=>{\n        if (!moduleName || !className || !funcName || !paramName) {\n            throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n    },\n    \"incorrect-type\": ({ expectedType, paramName, moduleName, className, funcName })=>{\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n        const classNameStr = className ? `${className}.` : \"\";\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;\n    },\n    \"incorrect-class\": ({ expectedClassName, paramName, moduleName, className, funcName, isReturnValueProblem })=>{\n        if (!expectedClassName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n        const classNameStr = className ? `${className}.` : \"\";\n        if (isReturnValueProblem) {\n            return `The return value from '${moduleName}.${classNameStr}${funcName}()' must be an instance of class ${expectedClassName}.`;\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n    },\n    \"missing-a-method\": ({ expectedMethod, paramName, moduleName, className, funcName })=>{\n        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n            throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n    },\n    \"add-to-cache-list-unexpected-type\": ({ entry })=>{\n        return `An unexpected entry was passed to 'serwist.Serwist.addToPrecacheList()' The entry '${JSON.stringify(entry)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`;\n    },\n    \"add-to-cache-list-conflicting-entries\": ({ firstEntry, secondEntry })=>{\n        if (!firstEntry || !secondEntry) {\n            throw new Error(\"Unexpected input to \" + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n        return `Two of the entries passed to 'serwist.Serwist.addToPrecacheList()' had the URL ${firstEntry} but different revision details. Serwist is unable to cache and version the asset correctly. Please remove one of the entries.`;\n    },\n    \"plugin-error-request-will-fetch\": ({ thrownErrorMessage })=>{\n        if (!thrownErrorMessage) {\n            throw new Error(\"Unexpected input to \" + `'plugin-error-request-will-fetch', error.`);\n        }\n        return `An error was thrown by a plugin's 'requestWillFetch()' method. The thrown error message was: '${thrownErrorMessage}'.`;\n    },\n    \"invalid-cache-name\": ({ cacheNameId, value })=>{\n        if (!cacheNameId) {\n            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n        return `You must provide a name containing at least one character for setCacheDetails({${cacheNameId}: '...'}). Received a value of '${JSON.stringify(value)}'`;\n    },\n    \"unregister-route-but-not-found-with-method\": ({ method })=>{\n        if (!method) {\n            throw new Error(\"Unexpected input to \" + `'unregister-route-but-not-found-with-method' error.`);\n        }\n        return `The route you're trying to unregister was not  previously registered for the method type '${method}'.`;\n    },\n    \"unregister-route-route-not-registered\": ()=>{\n        return `The route you're trying to unregister was not previously ` + \"registered.\";\n    },\n    \"queue-replay-failed\": ({ name })=>{\n        return `Replaying the background sync queue '${name}' failed.`;\n    },\n    \"duplicate-queue-name\": ({ name })=>{\n        return `The queue name '${name}' is already being used. All instances of 'serwist.BackgroundSyncQueue' must be given unique names.`;\n    },\n    \"expired-test-without-max-age\": ({ methodName, paramName })=>{\n        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n    },\n    \"unsupported-route-type\": ({ moduleName, className, funcName, paramName })=>{\n        return `The supplied '${paramName}' parameter was an unsupported type. Please check the docs for ${moduleName}.${className}.${funcName} for valid input types.`;\n    },\n    \"not-array-of-class\": ({ value, expectedClass, moduleName, className, funcName, paramName })=>{\n        return `The supplied '${paramName}' parameter must be an array of '${expectedClass}' objects. Received '${JSON.stringify(value)},'. Please check the call to ${moduleName}.${className}.${funcName}() to fix the issue.`;\n    },\n    \"max-entries-or-age-required\": ({ moduleName, className, funcName })=>{\n        return `You must define either 'config.maxEntries' or 'config.maxAgeSeconds' in '${moduleName}.${className}.${funcName}'`;\n    },\n    \"statuses-or-headers-required\": ({ moduleName, className, funcName })=>{\n        return `You must define either 'config.statuses' or 'config.headers' in '${moduleName}.${className}.${funcName}'`;\n    },\n    \"invalid-string\": ({ moduleName, funcName, paramName })=>{\n        if (!paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n        return `When using strings, the '${paramName}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${moduleName}.${funcName}() for more info.`;\n    },\n    \"channel-name-required\": ()=>{\n        return \"You must provide a channelName to construct a \" + \"BroadcastCacheUpdate instance.\";\n    },\n    \"invalid-responses-are-same-args\": ()=>{\n        return \"The arguments passed into responsesAreSame() appear to be \" + \"invalid. Please ensure valid Responses are used.\";\n    },\n    \"expire-custom-caches-only\": ()=>{\n        return `You must provide a 'cacheName' property when using the ` + \"expiration plugin with a runtime caching strategy.\";\n    },\n    \"unit-must-be-bytes\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n        return `The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"single-range-only\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n        return `Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"invalid-range-values\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n        return `The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"no-range-header\": ()=>{\n        return \"No Range header was found in the Request provided.\";\n    },\n    \"range-not-satisfiable\": ({ size, start, end })=>{\n        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n    },\n    \"attempt-to-cache-non-get-request\": ({ url, method })=>{\n        return `Unable to cache '${url}' because it is a '${method}' request and only 'GET' requests can be cached.`;\n    },\n    \"cache-put-with-no-response\": ({ url })=>{\n        return `There was an attempt to cache '${url}' but the response was not defined.`;\n    },\n    \"no-response\": ({ url, error })=>{\n        let message = `The strategy could not generate a response for '${url}'.`;\n        if (error) {\n            message += ` The underlying error is ${error}.`;\n        }\n        return message;\n    },\n    \"bad-precaching-response\": ({ url, status })=>{\n        return `The precaching request for '${url}' failed${status ? ` with an HTTP status of ${status}.` : \".\"}`;\n    },\n    \"non-precached-url\": ({ url })=>{\n        return `'createHandlerBoundToURL(\"${url}\")' was called, but that URL is not precached. Please pass in a URL that is precached instead.`;\n    },\n    \"add-to-cache-list-conflicting-integrities\": ({ url })=>{\n        return `Two of the entries passed to 'serwist.Serwist.addToPrecacheList()' had the URL ${url} with different integrity values. Please remove one of them.`;\n    },\n    \"missing-precache-entry\": ({ cacheName, url })=>{\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n    },\n    \"cross-origin-copy-response\": ({ origin })=>{\n        return `'@serwist/core.copyResponse()' can only be used with same-origin responses. It was passed a response with origin ${origin}.`;\n    },\n    \"opaque-streams-source\": ({ type })=>{\n        const message = `One of the '@serwist/streams' sources resulted in an '${type}' response.`;\n        if (type === \"opaqueredirect\") {\n            return `${message} Please do not use a navigation request that results in a redirect as a source.`;\n        }\n        return `${message} Please ensure your sources are CORS-enabled.`;\n    }\n};\n\nconst fallback = (code, ...args)=>{\n    let msg = code;\n    if (args.length > 0) {\n        msg += ` :: ${JSON.stringify(args)}`;\n    }\n    return msg;\n};\nconst generatorFunction = (code, details = {})=>{\n    const message = messages[code];\n    if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n    }\n    return message(details);\n};\nconst messageGenerator =  false ? 0 : generatorFunction;\n\nclass SerwistError extends Error {\n    details;\n    constructor(errorCode, details){\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n    }\n}\n\nconst isArray = (value, details)=>{\n    if (!Array.isArray(value)) {\n        throw new SerwistError(\"not-an-array\", details);\n    }\n};\nconst hasMethod = (object, expectedMethod, details)=>{\n    const type = typeof object[expectedMethod];\n    if (type !== \"function\") {\n        details.expectedMethod = expectedMethod;\n        throw new SerwistError(\"missing-a-method\", details);\n    }\n};\nconst isType = (object, expectedType, details)=>{\n    if (typeof object !== expectedType) {\n        details.expectedType = expectedType;\n        throw new SerwistError(\"incorrect-type\", details);\n    }\n};\nconst isInstance = (object, expectedClass, details)=>{\n    if (!(object instanceof expectedClass)) {\n        details.expectedClassName = expectedClass.name;\n        throw new SerwistError(\"incorrect-class\", details);\n    }\n};\nconst isOneOf = (value, validValues, details)=>{\n    if (!validValues.includes(value)) {\n        details.validValueDescription = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new SerwistError(\"invalid-value\", details);\n    }\n};\nconst isArrayOfClass = (value, expectedClass, details)=>{\n    const error = new SerwistError(\"not-array-of-class\", details);\n    if (!Array.isArray(value)) {\n        throw error;\n    }\n    for (const item of value){\n        if (!(item instanceof expectedClass)) {\n            throw error;\n        }\n    }\n};\nconst finalAssertExports =  false ? 0 : {\n    hasMethod,\n    isArray,\n    isInstance,\n    isOneOf,\n    isType,\n    isArrayOfClass\n};\n\nconst logger =  false || typeof self === \"undefined\" ? null : (()=>{\n    if (!(\"__WB_DISABLE_DEV_LOGS\" in globalThis)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n    }\n    let inGroup = false;\n    const methodToColorMap = {\n        debug: \"#7f8c8d\",\n        log: \"#2ecc71\",\n        warn: \"#f39c12\",\n        error: \"#c0392b\",\n        groupCollapsed: \"#3498db\",\n        groupEnd: null\n    };\n    const print = (method, args)=>{\n        if (self.__WB_DISABLE_DEV_LOGS) {\n            return;\n        }\n        if (method === \"groupCollapsed\") {\n            if (typeof navigator !== \"undefined\" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n                console[method](...args);\n                return;\n            }\n        }\n        const styles = [\n            `background: ${methodToColorMap[method]}`,\n            \"border-radius: 0.5em\",\n            \"color: white\",\n            \"font-weight: bold\",\n            \"padding: 2px 0.5em\"\n        ];\n        const logPrefix = inGroup ? [] : [\n            \"%cserwist\",\n            styles.join(\";\")\n        ];\n        console[method](...logPrefix, ...args);\n        if (method === \"groupCollapsed\") {\n            inGroup = true;\n        }\n        if (method === \"groupEnd\") {\n            inGroup = false;\n        }\n    };\n    const loggerMethods = Object.keys(methodToColorMap);\n    return loggerMethods.reduce((api, method)=>{\n        api[method] = (...args)=>{\n            print(method, args);\n        };\n        return api;\n    }, {});\n})();\n\nconst getFriendlyURL = (url)=>{\n    const urlObj = new URL(String(url), location.href);\n    return urlObj.href.replace(new RegExp(`^${location.origin}`), \"\");\n};\n\nconst _cacheNameDetails = {\n    googleAnalytics: \"googleAnalytics\",\n    precache: \"precache-v2\",\n    prefix: \"serwist\",\n    runtime: \"runtime\",\n    suffix: typeof registration !== \"undefined\" ? registration.scope : \"\"\n};\nconst _createCacheName = (cacheName)=>{\n    return [\n        _cacheNameDetails.prefix,\n        cacheName,\n        _cacheNameDetails.suffix\n    ].filter((value)=>value && value.length > 0).join(\"-\");\n};\nconst eachCacheNameDetail = (fn)=>{\n    for (const key of Object.keys(_cacheNameDetails)){\n        fn(key);\n    }\n};\nconst cacheNames = {\n    updateDetails: (details)=>{\n        eachCacheNameDetail((key)=>{\n            const detail = details[key];\n            if (typeof detail === \"string\") {\n                _cacheNameDetails[key] = detail;\n            }\n        });\n    },\n    getGoogleAnalyticsName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n    },\n    getPrecacheName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n    },\n    getPrefix: ()=>{\n        return _cacheNameDetails.prefix;\n    },\n    getRuntimeName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n    },\n    getSuffix: ()=>{\n        return _cacheNameDetails.suffix;\n    }\n};\n\nclass Deferred {\n    promise;\n    resolve;\n    reject;\n    constructor(){\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\nfunction stripParams(fullURL, ignoreParams) {\n    const strippedURL = new URL(fullURL);\n    for (const param of ignoreParams){\n        strippedURL.searchParams.delete(param);\n    }\n    return strippedURL.href;\n}\nasync function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n    const strippedRequestURL = stripParams(request.url, ignoreParams);\n    if (request.url === strippedRequestURL) {\n        return cache.match(request, matchOptions);\n    }\n    const keysOptions = {\n        ...matchOptions,\n        ignoreSearch: true\n    };\n    const cacheKeys = await cache.keys(request, keysOptions);\n    for (const cacheKey of cacheKeys){\n        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n        if (strippedRequestURL === strippedCacheKeyURL) {\n            return cache.match(cacheKey, matchOptions);\n        }\n    }\n    return;\n}\n\nconst quotaErrorCallbacks = new Set();\n\nconst executeQuotaErrorCallbacks = async ()=>{\n    if (true) {\n        logger.log(`About to run ${quotaErrorCallbacks.size} callbacks to clean up caches.`);\n    }\n    for (const callback of quotaErrorCallbacks){\n        await callback();\n        if (true) {\n            logger.log(callback, \"is complete.\");\n        }\n    }\n    if (true) {\n        logger.log(\"Finished running callbacks.\");\n    }\n};\n\nfunction timeout(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n\nlet supportStatus;\nfunction canConstructResponseFromBodyStream() {\n    if (supportStatus === undefined) {\n        const testResponse = new Response(\"\");\n        if (\"body\" in testResponse) {\n            try {\n                new Response(testResponse.body);\n                supportStatus = true;\n            } catch  {\n                supportStatus = false;\n            }\n        }\n        supportStatus = false;\n    }\n    return supportStatus;\n}\n\nconst SUBSTRING_TO_FIND = \"-precache-\";\nconst deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND)=>{\n    const cacheNames = await self.caches.keys();\n    const cacheNamesToDelete = cacheNames.filter((cacheName)=>{\n        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n    });\n    await Promise.all(cacheNamesToDelete.map((cacheName)=>self.caches.delete(cacheName)));\n    return cacheNamesToDelete;\n};\n\nconst cleanupOutdatedCaches = (cacheName)=>{\n    self.addEventListener(\"activate\", (event)=>{\n        event.waitUntil(deleteOutdatedCaches(cacheNames.getPrecacheName(cacheName)).then((cachesDeleted)=>{\n            if (true) {\n                if (cachesDeleted.length > 0) {\n                    logger.log(\"The following out-of-date precaches were cleaned up automatically:\", cachesDeleted);\n                }\n            }\n        }));\n    });\n};\n\nconst clientsClaim = ()=>{\n    self.addEventListener(\"activate\", ()=>self.clients.claim());\n};\n\nconst waitUntil = (event, asyncFn)=>{\n    const returnPromise = asyncFn();\n    event.waitUntil(returnPromise);\n    return returnPromise;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2Vyd2lzdC9kaXN0L2NodW5rcy93YWl0VW50aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVUsK0RBQStELHVCQUF1QiwyQkFBMkIsc0JBQXNCO0FBQ3hLLEtBQUs7QUFDTCx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVLHNCQUFzQixXQUFXLEdBQUcsVUFBVSxHQUFHLFNBQVM7QUFDckcsS0FBSztBQUNMLHlCQUF5QiwwREFBMEQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQsaUNBQWlDLFVBQVUsc0JBQXNCLFdBQVcsR0FBRyxhQUFhLE9BQU8sU0FBUyxzQkFBc0IsYUFBYTtBQUMvSSxLQUFLO0FBQ0wsMEJBQTBCLHFGQUFxRjtBQUMvRztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBLDZDQUE2QyxXQUFXLEdBQUcsYUFBYSxFQUFFLFNBQVMsbUNBQW1DLGtCQUFrQjtBQUN4STtBQUNBLGlDQUFpQyxVQUFVLHNCQUFzQixXQUFXLEdBQUcsYUFBYSxFQUFFLFNBQVMsd0NBQXdDLGtCQUFrQjtBQUNqSyxLQUFLO0FBQ0wsMkJBQTJCLDREQUE0RDtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVyxHQUFHLFVBQVUsR0FBRyxTQUFTLHdCQUF3QixVQUFVLDJCQUEyQixlQUFlO0FBQ2xJLEtBQUs7QUFDTCw0Q0FBNEMsT0FBTztBQUNuRCxxR0FBcUcsc0JBQXNCO0FBQzNILEtBQUs7QUFDTCxnREFBZ0QseUJBQXlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxZQUFZO0FBQzdHLEtBQUs7QUFDTCwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCxtQkFBbUI7QUFDbkksS0FBSztBQUNMLDZCQUE2Qixv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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNEJBQTRCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBcUMsR0FBRyxDQUFJO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsTUFBcUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1QsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0MsbUNBQW1DLDBCQUEwQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNVIiwic291cmNlcyI6WyIvaG9tZS9ueXgvV29ya3NwYWNlL09zdWMvVWJpQ2F0ZS12Mi9ub2RlX21vZHVsZXMvc2Vyd2lzdC9kaXN0L2NodW5rcy93YWl0VW50aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbWVzc2FnZXMgPSB7XG4gICAgXCJpbnZhbGlkLXZhbHVlXCI6ICh7IHBhcmFtTmFtZSwgdmFsaWRWYWx1ZURlc2NyaXB0aW9uLCB2YWx1ZSB9KT0+e1xuICAgICAgICBpZiAoIXBhcmFtTmFtZSB8fCAhdmFsaWRWYWx1ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2ludmFsaWQtdmFsdWUnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciB3YXMgZ2l2ZW4gYSB2YWx1ZSB3aXRoIGFuIGAgKyBgdW5leHBlY3RlZCB2YWx1ZS4gJHt2YWxpZFZhbHVlRGVzY3JpcHRpb259IFJlY2VpdmVkIGEgdmFsdWUgb2YgYCArIGAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0uYDtcbiAgICB9LFxuICAgIFwibm90LWFuLWFycmF5XCI6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KT0+e1xuICAgICAgICBpZiAoIW1vZHVsZU5hbWUgfHwgIWNsYXNzTmFtZSB8fCAhZnVuY05hbWUgfHwgIXBhcmFtTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdub3QtYW4tYXJyYXknIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlIHBhcmFtZXRlciAnJHtwYXJhbU5hbWV9JyBwYXNzZWQgaW50byBgICsgYCcke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSgpJyBtdXN0IGJlIGFuIGFycmF5LmA7XG4gICAgfSxcbiAgICBcImluY29ycmVjdC10eXBlXCI6ICh7IGV4cGVjdGVkVHlwZSwgcGFyYW1OYW1lLCBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lIH0pPT57XG4gICAgICAgIGlmICghZXhwZWN0ZWRUeXBlIHx8ICFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2luY29ycmVjdC10eXBlJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGFzc05hbWVTdHIgPSBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9LmAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYFRoZSBwYXJhbWV0ZXIgJyR7cGFyYW1OYW1lfScgcGFzc2VkIGludG8gYCArIGAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZVN0cn1gICsgYCR7ZnVuY05hbWV9KCknIG11c3QgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZX0uYDtcbiAgICB9LFxuICAgIFwiaW5jb3JyZWN0LWNsYXNzXCI6ICh7IGV4cGVjdGVkQ2xhc3NOYW1lLCBwYXJhbU5hbWUsIG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIGlzUmV0dXJuVmFsdWVQcm9ibGVtIH0pPT57XG4gICAgICAgIGlmICghZXhwZWN0ZWRDbGFzc05hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2luY29ycmVjdC1jbGFzcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xhc3NOYW1lU3RyID0gY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfS5gIDogXCJcIjtcbiAgICAgICAgaWYgKGlzUmV0dXJuVmFsdWVQcm9ibGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gYFRoZSByZXR1cm4gdmFsdWUgZnJvbSAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZVN0cn0ke2Z1bmNOYW1lfSgpJyBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGNsYXNzICR7ZXhwZWN0ZWRDbGFzc05hbWV9LmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgcGFyYW1ldGVyICcke3BhcmFtTmFtZX0nIHBhc3NlZCBpbnRvIGAgKyBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWVTdHJ9JHtmdW5jTmFtZX0oKScgYCArIGBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGNsYXNzICR7ZXhwZWN0ZWRDbGFzc05hbWV9LmA7XG4gICAgfSxcbiAgICBcIm1pc3NpbmctYS1tZXRob2RcIjogKHsgZXhwZWN0ZWRNZXRob2QsIHBhcmFtTmFtZSwgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KT0+e1xuICAgICAgICBpZiAoIWV4cGVjdGVkTWV0aG9kIHx8ICFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWNsYXNzTmFtZSB8fCAhZnVuY05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnbWlzc2luZy1hLW1ldGhvZCcgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSgpIGV4cGVjdGVkIHRoZSBgICsgYCcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciB0byBleHBvc2UgYSAnJHtleHBlY3RlZE1ldGhvZH0nIG1ldGhvZC5gO1xuICAgIH0sXG4gICAgXCJhZGQtdG8tY2FjaGUtbGlzdC11bmV4cGVjdGVkLXR5cGVcIjogKHsgZW50cnkgfSk9PntcbiAgICAgICAgcmV0dXJuIGBBbiB1bmV4cGVjdGVkIGVudHJ5IHdhcyBwYXNzZWQgdG8gJ3Nlcndpc3QuU2Vyd2lzdC5hZGRUb1ByZWNhY2hlTGlzdCgpJyBUaGUgZW50cnkgJyR7SlNPTi5zdHJpbmdpZnkoZW50cnkpfScgaXNuJ3Qgc3VwcG9ydGVkLiBZb3UgbXVzdCBzdXBwbHkgYW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoIG9uZSBvciBtb3JlIGNoYXJhY3RlcnMsIG9iamVjdHMgd2l0aCBhIHVybCBwcm9wZXJ0eSBvciBSZXF1ZXN0IG9iamVjdHMuYDtcbiAgICB9LFxuICAgIFwiYWRkLXRvLWNhY2hlLWxpc3QtY29uZmxpY3RpbmctZW50cmllc1wiOiAoeyBmaXJzdEVudHJ5LCBzZWNvbmRFbnRyeSB9KT0+e1xuICAgICAgICBpZiAoIWZpcnN0RW50cnkgfHwgIXNlY29uZEVudHJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGlucHV0IHRvIFwiICsgYCdhZGQtdG8tY2FjaGUtbGlzdC1kdXBsaWNhdGUtZW50cmllcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUd28gb2YgdGhlIGVudHJpZXMgcGFzc2VkIHRvICdzZXJ3aXN0LlNlcndpc3QuYWRkVG9QcmVjYWNoZUxpc3QoKScgaGFkIHRoZSBVUkwgJHtmaXJzdEVudHJ5fSBidXQgZGlmZmVyZW50IHJldmlzaW9uIGRldGFpbHMuIFNlcndpc3QgaXMgdW5hYmxlIHRvIGNhY2hlIGFuZCB2ZXJzaW9uIHRoZSBhc3NldCBjb3JyZWN0bHkuIFBsZWFzZSByZW1vdmUgb25lIG9mIHRoZSBlbnRyaWVzLmA7XG4gICAgfSxcbiAgICBcInBsdWdpbi1lcnJvci1yZXF1ZXN0LXdpbGwtZmV0Y2hcIjogKHsgdGhyb3duRXJyb3JNZXNzYWdlIH0pPT57XG4gICAgICAgIGlmICghdGhyb3duRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGlucHV0IHRvIFwiICsgYCdwbHVnaW4tZXJyb3ItcmVxdWVzdC13aWxsLWZldGNoJywgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBBbiBlcnJvciB3YXMgdGhyb3duIGJ5IGEgcGx1Z2luJ3MgJ3JlcXVlc3RXaWxsRmV0Y2goKScgbWV0aG9kLiBUaGUgdGhyb3duIGVycm9yIG1lc3NhZ2Ugd2FzOiAnJHt0aHJvd25FcnJvck1lc3NhZ2V9Jy5gO1xuICAgIH0sXG4gICAgXCJpbnZhbGlkLWNhY2hlLW5hbWVcIjogKHsgY2FjaGVOYW1lSWQsIHZhbHVlIH0pPT57XG4gICAgICAgIGlmICghY2FjaGVOYW1lSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSAnY2FjaGVOYW1lSWQnIGZvciBlcnJvciAnaW52YWxpZC1jYWNoZS1uYW1lJ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgcHJvdmlkZSBhIG5hbWUgY29udGFpbmluZyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIGZvciBzZXRDYWNoZURldGFpbHMoeyR7Y2FjaGVOYW1lSWR9OiAnLi4uJ30pLiBSZWNlaXZlZCBhIHZhbHVlIG9mICcke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0nYDtcbiAgICB9LFxuICAgIFwidW5yZWdpc3Rlci1yb3V0ZS1idXQtbm90LWZvdW5kLXdpdGgtbWV0aG9kXCI6ICh7IG1ldGhvZCB9KT0+e1xuICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBpbnB1dCB0byBcIiArIGAndW5yZWdpc3Rlci1yb3V0ZS1idXQtbm90LWZvdW5kLXdpdGgtbWV0aG9kJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSByb3V0ZSB5b3UncmUgdHJ5aW5nIHRvIHVucmVnaXN0ZXIgd2FzIG5vdCAgcHJldmlvdXNseSByZWdpc3RlcmVkIGZvciB0aGUgbWV0aG9kIHR5cGUgJyR7bWV0aG9kfScuYDtcbiAgICB9LFxuICAgIFwidW5yZWdpc3Rlci1yb3V0ZS1yb3V0ZS1ub3QtcmVnaXN0ZXJlZFwiOiAoKT0+e1xuICAgICAgICByZXR1cm4gYFRoZSByb3V0ZSB5b3UncmUgdHJ5aW5nIHRvIHVucmVnaXN0ZXIgd2FzIG5vdCBwcmV2aW91c2x5IGAgKyBcInJlZ2lzdGVyZWQuXCI7XG4gICAgfSxcbiAgICBcInF1ZXVlLXJlcGxheS1mYWlsZWRcIjogKHsgbmFtZSB9KT0+e1xuICAgICAgICByZXR1cm4gYFJlcGxheWluZyB0aGUgYmFja2dyb3VuZCBzeW5jIHF1ZXVlICcke25hbWV9JyBmYWlsZWQuYDtcbiAgICB9LFxuICAgIFwiZHVwbGljYXRlLXF1ZXVlLW5hbWVcIjogKHsgbmFtZSB9KT0+e1xuICAgICAgICByZXR1cm4gYFRoZSBxdWV1ZSBuYW1lICcke25hbWV9JyBpcyBhbHJlYWR5IGJlaW5nIHVzZWQuIEFsbCBpbnN0YW5jZXMgb2YgJ3Nlcndpc3QuQmFja2dyb3VuZFN5bmNRdWV1ZScgbXVzdCBiZSBnaXZlbiB1bmlxdWUgbmFtZXMuYDtcbiAgICB9LFxuICAgIFwiZXhwaXJlZC10ZXN0LXdpdGhvdXQtbWF4LWFnZVwiOiAoeyBtZXRob2ROYW1lLCBwYXJhbU5hbWUgfSk9PntcbiAgICAgICAgcmV0dXJuIGBUaGUgJyR7bWV0aG9kTmFtZX0oKScgbWV0aG9kIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiB0aGUgYCArIGAnJHtwYXJhbU5hbWV9JyBpcyB1c2VkIGluIHRoZSBjb25zdHJ1Y3Rvci5gO1xuICAgIH0sXG4gICAgXCJ1bnN1cHBvcnRlZC1yb3V0ZS10eXBlXCI6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KT0+e1xuICAgICAgICByZXR1cm4gYFRoZSBzdXBwbGllZCAnJHtwYXJhbU5hbWV9JyBwYXJhbWV0ZXIgd2FzIGFuIHVuc3VwcG9ydGVkIHR5cGUuIFBsZWFzZSBjaGVjayB0aGUgZG9jcyBmb3IgJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZX0uJHtmdW5jTmFtZX0gZm9yIHZhbGlkIGlucHV0IHR5cGVzLmA7XG4gICAgfSxcbiAgICBcIm5vdC1hcnJheS1vZi1jbGFzc1wiOiAoeyB2YWx1ZSwgZXhwZWN0ZWRDbGFzcywgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pPT57XG4gICAgICAgIHJldHVybiBgVGhlIHN1cHBsaWVkICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciBtdXN0IGJlIGFuIGFycmF5IG9mICcke2V4cGVjdGVkQ2xhc3N9JyBvYmplY3RzLiBSZWNlaXZlZCAnJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LCcuIFBsZWFzZSBjaGVjayB0aGUgY2FsbCB0byAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSgpIHRvIGZpeCB0aGUgaXNzdWUuYDtcbiAgICB9LFxuICAgIFwibWF4LWVudHJpZXMtb3ItYWdlLXJlcXVpcmVkXCI6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUgfSk9PntcbiAgICAgICAgcmV0dXJuIGBZb3UgbXVzdCBkZWZpbmUgZWl0aGVyICdjb25maWcubWF4RW50cmllcycgb3IgJ2NvbmZpZy5tYXhBZ2VTZWNvbmRzJyBpbiAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZX0uJHtmdW5jTmFtZX0nYDtcbiAgICB9LFxuICAgIFwic3RhdHVzZXMtb3ItaGVhZGVycy1yZXF1aXJlZFwiOiAoeyBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lIH0pPT57XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgZGVmaW5lIGVpdGhlciAnY29uZmlnLnN0YXR1c2VzJyBvciAnY29uZmlnLmhlYWRlcnMnIGluICcke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSdgO1xuICAgIH0sXG4gICAgXCJpbnZhbGlkLXN0cmluZ1wiOiAoeyBtb2R1bGVOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pPT57XG4gICAgICAgIGlmICghcGFyYW1OYW1lIHx8ICFtb2R1bGVOYW1lIHx8ICFmdW5jTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdpbnZhbGlkLXN0cmluZycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBXaGVuIHVzaW5nIHN0cmluZ3MsIHRoZSAnJHtwYXJhbU5hbWV9JyBwYXJhbWV0ZXIgbXVzdCBzdGFydCB3aXRoICdodHRwJyAoZm9yIGNyb3NzLW9yaWdpbiBtYXRjaGVzKSBvciAnLycgKGZvciBzYW1lLW9yaWdpbiBtYXRjaGVzKS4gUGxlYXNlIHNlZSB0aGUgZG9jcyBmb3IgJHttb2R1bGVOYW1lfS4ke2Z1bmNOYW1lfSgpIGZvciBtb3JlIGluZm8uYDtcbiAgICB9LFxuICAgIFwiY2hhbm5lbC1uYW1lLXJlcXVpcmVkXCI6ICgpPT57XG4gICAgICAgIHJldHVybiBcIllvdSBtdXN0IHByb3ZpZGUgYSBjaGFubmVsTmFtZSB0byBjb25zdHJ1Y3QgYSBcIiArIFwiQnJvYWRjYXN0Q2FjaGVVcGRhdGUgaW5zdGFuY2UuXCI7XG4gICAgfSxcbiAgICBcImludmFsaWQtcmVzcG9uc2VzLWFyZS1zYW1lLWFyZ3NcIjogKCk9PntcbiAgICAgICAgcmV0dXJuIFwiVGhlIGFyZ3VtZW50cyBwYXNzZWQgaW50byByZXNwb25zZXNBcmVTYW1lKCkgYXBwZWFyIHRvIGJlIFwiICsgXCJpbnZhbGlkLiBQbGVhc2UgZW5zdXJlIHZhbGlkIFJlc3BvbnNlcyBhcmUgdXNlZC5cIjtcbiAgICB9LFxuICAgIFwiZXhwaXJlLWN1c3RvbS1jYWNoZXMtb25seVwiOiAoKT0+e1xuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IHByb3ZpZGUgYSAnY2FjaGVOYW1lJyBwcm9wZXJ0eSB3aGVuIHVzaW5nIHRoZSBgICsgXCJleHBpcmF0aW9uIHBsdWdpbiB3aXRoIGEgcnVudGltZSBjYWNoaW5nIHN0cmF0ZWd5LlwiO1xuICAgIH0sXG4gICAgXCJ1bml0LW11c3QtYmUtYnl0ZXNcIjogKHsgbm9ybWFsaXplZFJhbmdlSGVhZGVyIH0pPT57XG4gICAgICAgIGlmICghbm9ybWFsaXplZFJhbmdlSGVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ3VuaXQtbXVzdC1iZS1ieXRlcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgJ3VuaXQnIHBvcnRpb24gb2YgdGhlIFJhbmdlIGhlYWRlciBtdXN0IGJlIHNldCB0byAnYnl0ZXMnLiBUaGUgUmFuZ2UgaGVhZGVyIHByb3ZpZGVkIHdhcyBcIiR7bm9ybWFsaXplZFJhbmdlSGVhZGVyfVwiYDtcbiAgICB9LFxuICAgIFwic2luZ2xlLXJhbmdlLW9ubHlcIjogKHsgbm9ybWFsaXplZFJhbmdlSGVhZGVyIH0pPT57XG4gICAgICAgIGlmICghbm9ybWFsaXplZFJhbmdlSGVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ3NpbmdsZS1yYW5nZS1vbmx5JyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYE11bHRpcGxlIHJhbmdlcyBhcmUgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSBhICBzaW5nbGUgc3RhcnQgdmFsdWUsIGFuZCBvcHRpb25hbCBlbmQgdmFsdWUuIFRoZSBSYW5nZSBoZWFkZXIgcHJvdmlkZWQgd2FzIFwiJHtub3JtYWxpemVkUmFuZ2VIZWFkZXJ9XCJgO1xuICAgIH0sXG4gICAgXCJpbnZhbGlkLXJhbmdlLXZhbHVlc1wiOiAoeyBub3JtYWxpemVkUmFuZ2VIZWFkZXIgfSk9PntcbiAgICAgICAgaWYgKCFub3JtYWxpemVkUmFuZ2VIZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnaW52YWxpZC1yYW5nZS12YWx1ZXMnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlIFJhbmdlIGhlYWRlciBpcyBtaXNzaW5nIGJvdGggc3RhcnQgYW5kIGVuZCB2YWx1ZXMuIEF0IGxlYXN0IG9uZSBvZiB0aG9zZSB2YWx1ZXMgaXMgbmVlZGVkLiBUaGUgUmFuZ2UgaGVhZGVyIHByb3ZpZGVkIHdhcyBcIiR7bm9ybWFsaXplZFJhbmdlSGVhZGVyfVwiYDtcbiAgICB9LFxuICAgIFwibm8tcmFuZ2UtaGVhZGVyXCI6ICgpPT57XG4gICAgICAgIHJldHVybiBcIk5vIFJhbmdlIGhlYWRlciB3YXMgZm91bmQgaW4gdGhlIFJlcXVlc3QgcHJvdmlkZWQuXCI7XG4gICAgfSxcbiAgICBcInJhbmdlLW5vdC1zYXRpc2ZpYWJsZVwiOiAoeyBzaXplLCBzdGFydCwgZW5kIH0pPT57XG4gICAgICAgIHJldHVybiBgVGhlIHN0YXJ0ICgke3N0YXJ0fSkgYW5kIGVuZCAoJHtlbmR9KSB2YWx1ZXMgaW4gdGhlIFJhbmdlIGFyZSBgICsgYG5vdCBzYXRpc2ZpYWJsZSBieSB0aGUgY2FjaGVkIHJlc3BvbnNlLCB3aGljaCBpcyAke3NpemV9IGJ5dGVzLmA7XG4gICAgfSxcbiAgICBcImF0dGVtcHQtdG8tY2FjaGUtbm9uLWdldC1yZXF1ZXN0XCI6ICh7IHVybCwgbWV0aG9kIH0pPT57XG4gICAgICAgIHJldHVybiBgVW5hYmxlIHRvIGNhY2hlICcke3VybH0nIGJlY2F1c2UgaXQgaXMgYSAnJHttZXRob2R9JyByZXF1ZXN0IGFuZCBvbmx5ICdHRVQnIHJlcXVlc3RzIGNhbiBiZSBjYWNoZWQuYDtcbiAgICB9LFxuICAgIFwiY2FjaGUtcHV0LXdpdGgtbm8tcmVzcG9uc2VcIjogKHsgdXJsIH0pPT57XG4gICAgICAgIHJldHVybiBgVGhlcmUgd2FzIGFuIGF0dGVtcHQgdG8gY2FjaGUgJyR7dXJsfScgYnV0IHRoZSByZXNwb25zZSB3YXMgbm90IGRlZmluZWQuYDtcbiAgICB9LFxuICAgIFwibm8tcmVzcG9uc2VcIjogKHsgdXJsLCBlcnJvciB9KT0+e1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGBUaGUgc3RyYXRlZ3kgY291bGQgbm90IGdlbmVyYXRlIGEgcmVzcG9uc2UgZm9yICcke3VybH0nLmA7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBgIFRoZSB1bmRlcmx5aW5nIGVycm9yIGlzICR7ZXJyb3J9LmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBcImJhZC1wcmVjYWNoaW5nLXJlc3BvbnNlXCI6ICh7IHVybCwgc3RhdHVzIH0pPT57XG4gICAgICAgIHJldHVybiBgVGhlIHByZWNhY2hpbmcgcmVxdWVzdCBmb3IgJyR7dXJsfScgZmFpbGVkJHtzdGF0dXMgPyBgIHdpdGggYW4gSFRUUCBzdGF0dXMgb2YgJHtzdGF0dXN9LmAgOiBcIi5cIn1gO1xuICAgIH0sXG4gICAgXCJub24tcHJlY2FjaGVkLXVybFwiOiAoeyB1cmwgfSk9PntcbiAgICAgICAgcmV0dXJuIGAnY3JlYXRlSGFuZGxlckJvdW5kVG9VUkwoXCIke3VybH1cIiknIHdhcyBjYWxsZWQsIGJ1dCB0aGF0IFVSTCBpcyBub3QgcHJlY2FjaGVkLiBQbGVhc2UgcGFzcyBpbiBhIFVSTCB0aGF0IGlzIHByZWNhY2hlZCBpbnN0ZWFkLmA7XG4gICAgfSxcbiAgICBcImFkZC10by1jYWNoZS1saXN0LWNvbmZsaWN0aW5nLWludGVncml0aWVzXCI6ICh7IHVybCB9KT0+e1xuICAgICAgICByZXR1cm4gYFR3byBvZiB0aGUgZW50cmllcyBwYXNzZWQgdG8gJ3Nlcndpc3QuU2Vyd2lzdC5hZGRUb1ByZWNhY2hlTGlzdCgpJyBoYWQgdGhlIFVSTCAke3VybH0gd2l0aCBkaWZmZXJlbnQgaW50ZWdyaXR5IHZhbHVlcy4gUGxlYXNlIHJlbW92ZSBvbmUgb2YgdGhlbS5gO1xuICAgIH0sXG4gICAgXCJtaXNzaW5nLXByZWNhY2hlLWVudHJ5XCI6ICh7IGNhY2hlTmFtZSwgdXJsIH0pPT57XG4gICAgICAgIHJldHVybiBgVW5hYmxlIHRvIGZpbmQgYSBwcmVjYWNoZWQgcmVzcG9uc2UgaW4gJHtjYWNoZU5hbWV9IGZvciAke3VybH0uYDtcbiAgICB9LFxuICAgIFwiY3Jvc3Mtb3JpZ2luLWNvcHktcmVzcG9uc2VcIjogKHsgb3JpZ2luIH0pPT57XG4gICAgICAgIHJldHVybiBgJ0BzZXJ3aXN0L2NvcmUuY29weVJlc3BvbnNlKCknIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzYW1lLW9yaWdpbiByZXNwb25zZXMuIEl0IHdhcyBwYXNzZWQgYSByZXNwb25zZSB3aXRoIG9yaWdpbiAke29yaWdpbn0uYDtcbiAgICB9LFxuICAgIFwib3BhcXVlLXN0cmVhbXMtc291cmNlXCI6ICh7IHR5cGUgfSk9PntcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBPbmUgb2YgdGhlICdAc2Vyd2lzdC9zdHJlYW1zJyBzb3VyY2VzIHJlc3VsdGVkIGluIGFuICcke3R5cGV9JyByZXNwb25zZS5gO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJvcGFxdWVyZWRpcmVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7bWVzc2FnZX0gUGxlYXNlIGRvIG5vdCB1c2UgYSBuYXZpZ2F0aW9uIHJlcXVlc3QgdGhhdCByZXN1bHRzIGluIGEgcmVkaXJlY3QgYXMgYSBzb3VyY2UuYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bWVzc2FnZX0gUGxlYXNlIGVuc3VyZSB5b3VyIHNvdXJjZXMgYXJlIENPUlMtZW5hYmxlZC5gO1xuICAgIH1cbn07XG5cbmNvbnN0IGZhbGxiYWNrID0gKGNvZGUsIC4uLmFyZ3MpPT57XG4gICAgbGV0IG1zZyA9IGNvZGU7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBtc2cgKz0gYCA6OiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWA7XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG59O1xuY29uc3QgZ2VuZXJhdG9yRnVuY3Rpb24gPSAoY29kZSwgZGV0YWlscyA9IHt9KT0+e1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBtZXNzYWdlIGZvciBjb2RlICcke2NvZGV9Jy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2UoZGV0YWlscyk7XG59O1xuY29uc3QgbWVzc2FnZUdlbmVyYXRvciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZhbGxiYWNrIDogZ2VuZXJhdG9yRnVuY3Rpb247XG5cbmNsYXNzIFNlcndpc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBkZXRhaWxzO1xuICAgIGNvbnN0cnVjdG9yKGVycm9yQ29kZSwgZGV0YWlscyl7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlR2VuZXJhdG9yKGVycm9yQ29kZSwgZGV0YWlscyk7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnJvckNvZGU7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgfVxufVxuXG5jb25zdCBpc0FycmF5ID0gKHZhbHVlLCBkZXRhaWxzKT0+e1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcIm5vdC1hbi1hcnJheVwiLCBkZXRhaWxzKTtcbiAgICB9XG59O1xuY29uc3QgaGFzTWV0aG9kID0gKG9iamVjdCwgZXhwZWN0ZWRNZXRob2QsIGRldGFpbHMpPT57XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBvYmplY3RbZXhwZWN0ZWRNZXRob2RdO1xuICAgIGlmICh0eXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZGV0YWlscy5leHBlY3RlZE1ldGhvZCA9IGV4cGVjdGVkTWV0aG9kO1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibWlzc2luZy1hLW1ldGhvZFwiLCBkZXRhaWxzKTtcbiAgICB9XG59O1xuY29uc3QgaXNUeXBlID0gKG9iamVjdCwgZXhwZWN0ZWRUeXBlLCBkZXRhaWxzKT0+e1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgZGV0YWlscy5leHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGU7XG4gICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJpbmNvcnJlY3QtdHlwZVwiLCBkZXRhaWxzKTtcbiAgICB9XG59O1xuY29uc3QgaXNJbnN0YW5jZSA9IChvYmplY3QsIGV4cGVjdGVkQ2xhc3MsIGRldGFpbHMpPT57XG4gICAgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgZGV0YWlscy5leHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZTtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImluY29ycmVjdC1jbGFzc1wiLCBkZXRhaWxzKTtcbiAgICB9XG59O1xuY29uc3QgaXNPbmVPZiA9ICh2YWx1ZSwgdmFsaWRWYWx1ZXMsIGRldGFpbHMpPT57XG4gICAgaWYgKCF2YWxpZFZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgZGV0YWlscy52YWxpZFZhbHVlRGVzY3JpcHRpb24gPSBgVmFsaWQgdmFsdWVzIGFyZSAke0pTT04uc3RyaW5naWZ5KHZhbGlkVmFsdWVzKX0uYDtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImludmFsaWQtdmFsdWVcIiwgZGV0YWlscyk7XG4gICAgfVxufTtcbmNvbnN0IGlzQXJyYXlPZkNsYXNzID0gKHZhbHVlLCBleHBlY3RlZENsYXNzLCBkZXRhaWxzKT0+e1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFNlcndpc3RFcnJvcihcIm5vdC1hcnJheS1vZi1jbGFzc1wiLCBkZXRhaWxzKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpe1xuICAgICAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGZpbmFsQXNzZXJ0RXhwb3J0cyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG51bGwgOiB7XG4gICAgaGFzTWV0aG9kLFxuICAgIGlzQXJyYXksXG4gICAgaXNJbnN0YW5jZSxcbiAgICBpc09uZU9mLFxuICAgIGlzVHlwZSxcbiAgICBpc0FycmF5T2ZDbGFzc1xufTtcblxuY29uc3QgbG9nZ2VyID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6ICgoKT0+e1xuICAgIGlmICghKFwiX19XQl9ESVNBQkxFX0RFVl9MT0dTXCIgaW4gZ2xvYmFsVGhpcykpIHtcbiAgICAgICAgc2VsZi5fX1dCX0RJU0FCTEVfREVWX0xPR1MgPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGluR3JvdXAgPSBmYWxzZTtcbiAgICBjb25zdCBtZXRob2RUb0NvbG9yTWFwID0ge1xuICAgICAgICBkZWJ1ZzogXCIjN2Y4YzhkXCIsXG4gICAgICAgIGxvZzogXCIjMmVjYzcxXCIsXG4gICAgICAgIHdhcm46IFwiI2YzOWMxMlwiLFxuICAgICAgICBlcnJvcjogXCIjYzAzOTJiXCIsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBcIiMzNDk4ZGJcIixcbiAgICAgICAgZ3JvdXBFbmQ6IG51bGxcbiAgICB9O1xuICAgIGNvbnN0IHByaW50ID0gKG1ldGhvZCwgYXJncyk9PntcbiAgICAgICAgaWYgKHNlbGYuX19XQl9ESVNBQkxFX0RFVl9MT0dTKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJncm91cENvbGxhcHNlZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZVttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHlsZXMgPSBbXG4gICAgICAgICAgICBgYmFja2dyb3VuZDogJHttZXRob2RUb0NvbG9yTWFwW21ldGhvZF19YCxcbiAgICAgICAgICAgIFwiYm9yZGVyLXJhZGl1czogMC41ZW1cIixcbiAgICAgICAgICAgIFwiY29sb3I6IHdoaXRlXCIsXG4gICAgICAgICAgICBcImZvbnQtd2VpZ2h0OiBib2xkXCIsXG4gICAgICAgICAgICBcInBhZGRpbmc6IDJweCAwLjVlbVwiXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGxvZ1ByZWZpeCA9IGluR3JvdXAgPyBbXSA6IFtcbiAgICAgICAgICAgIFwiJWNzZXJ3aXN0XCIsXG4gICAgICAgICAgICBzdHlsZXMuam9pbihcIjtcIilcbiAgICAgICAgXTtcbiAgICAgICAgY29uc29sZVttZXRob2RdKC4uLmxvZ1ByZWZpeCwgLi4uYXJncyk7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZ3JvdXBDb2xsYXBzZWRcIikge1xuICAgICAgICAgICAgaW5Hcm91cCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJncm91cEVuZFwiKSB7XG4gICAgICAgICAgICBpbkdyb3VwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvZ2dlck1ldGhvZHMgPSBPYmplY3Qua2V5cyhtZXRob2RUb0NvbG9yTWFwKTtcbiAgICByZXR1cm4gbG9nZ2VyTWV0aG9kcy5yZWR1Y2UoKGFwaSwgbWV0aG9kKT0+e1xuICAgICAgICBhcGlbbWV0aG9kXSA9ICguLi5hcmdzKT0+e1xuICAgICAgICAgICAgcHJpbnQobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9LCB7fSk7XG59KSgpO1xuXG5jb25zdCBnZXRGcmllbmRseVVSTCA9ICh1cmwpPT57XG4gICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTChTdHJpbmcodXJsKSwgbG9jYXRpb24uaHJlZik7XG4gICAgcmV0dXJuIHVybE9iai5ocmVmLnJlcGxhY2UobmV3IFJlZ0V4cChgXiR7bG9jYXRpb24ub3JpZ2lufWApLCBcIlwiKTtcbn07XG5cbmNvbnN0IF9jYWNoZU5hbWVEZXRhaWxzID0ge1xuICAgIGdvb2dsZUFuYWx5dGljczogXCJnb29nbGVBbmFseXRpY3NcIixcbiAgICBwcmVjYWNoZTogXCJwcmVjYWNoZS12MlwiLFxuICAgIHByZWZpeDogXCJzZXJ3aXN0XCIsXG4gICAgcnVudGltZTogXCJydW50aW1lXCIsXG4gICAgc3VmZml4OiB0eXBlb2YgcmVnaXN0cmF0aW9uICE9PSBcInVuZGVmaW5lZFwiID8gcmVnaXN0cmF0aW9uLnNjb3BlIDogXCJcIlxufTtcbmNvbnN0IF9jcmVhdGVDYWNoZU5hbWUgPSAoY2FjaGVOYW1lKT0+e1xuICAgIHJldHVybiBbXG4gICAgICAgIF9jYWNoZU5hbWVEZXRhaWxzLnByZWZpeCxcbiAgICAgICAgY2FjaGVOYW1lLFxuICAgICAgICBfY2FjaGVOYW1lRGV0YWlscy5zdWZmaXhcbiAgICBdLmZpbHRlcigodmFsdWUpPT52YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKS5qb2luKFwiLVwiKTtcbn07XG5jb25zdCBlYWNoQ2FjaGVOYW1lRGV0YWlsID0gKGZuKT0+e1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKF9jYWNoZU5hbWVEZXRhaWxzKSl7XG4gICAgICAgIGZuKGtleSk7XG4gICAgfVxufTtcbmNvbnN0IGNhY2hlTmFtZXMgPSB7XG4gICAgdXBkYXRlRGV0YWlsczogKGRldGFpbHMpPT57XG4gICAgICAgIGVhY2hDYWNoZU5hbWVEZXRhaWwoKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbCA9IGRldGFpbHNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGV0YWlsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgX2NhY2hlTmFtZURldGFpbHNba2V5XSA9IGRldGFpbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRHb29nbGVBbmFseXRpY3NOYW1lOiAodXNlckNhY2hlTmFtZSk9PntcbiAgICAgICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5nb29nbGVBbmFseXRpY3MpO1xuICAgIH0sXG4gICAgZ2V0UHJlY2FjaGVOYW1lOiAodXNlckNhY2hlTmFtZSk9PntcbiAgICAgICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5wcmVjYWNoZSk7XG4gICAgfSxcbiAgICBnZXRQcmVmaXg6ICgpPT57XG4gICAgICAgIHJldHVybiBfY2FjaGVOYW1lRGV0YWlscy5wcmVmaXg7XG4gICAgfSxcbiAgICBnZXRSdW50aW1lTmFtZTogKHVzZXJDYWNoZU5hbWUpPT57XG4gICAgICAgIHJldHVybiB1c2VyQ2FjaGVOYW1lIHx8IF9jcmVhdGVDYWNoZU5hbWUoX2NhY2hlTmFtZURldGFpbHMucnVudGltZSk7XG4gICAgfSxcbiAgICBnZXRTdWZmaXg6ICgpPT57XG4gICAgICAgIHJldHVybiBfY2FjaGVOYW1lRGV0YWlscy5zdWZmaXg7XG4gICAgfVxufTtcblxuY2xhc3MgRGVmZXJyZWQge1xuICAgIHByb21pc2U7XG4gICAgcmVzb2x2ZTtcbiAgICByZWplY3Q7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdHJpcFBhcmFtcyhmdWxsVVJMLCBpZ25vcmVQYXJhbXMpIHtcbiAgICBjb25zdCBzdHJpcHBlZFVSTCA9IG5ldyBVUkwoZnVsbFVSTCk7XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBpZ25vcmVQYXJhbXMpe1xuICAgICAgICBzdHJpcHBlZFVSTC5zZWFyY2hQYXJhbXMuZGVsZXRlKHBhcmFtKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlwcGVkVVJMLmhyZWY7XG59XG5hc3luYyBmdW5jdGlvbiBjYWNoZU1hdGNoSWdub3JlUGFyYW1zKGNhY2hlLCByZXF1ZXN0LCBpZ25vcmVQYXJhbXMsIG1hdGNoT3B0aW9ucykge1xuICAgIGNvbnN0IHN0cmlwcGVkUmVxdWVzdFVSTCA9IHN0cmlwUGFyYW1zKHJlcXVlc3QudXJsLCBpZ25vcmVQYXJhbXMpO1xuICAgIGlmIChyZXF1ZXN0LnVybCA9PT0gc3RyaXBwZWRSZXF1ZXN0VVJMKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5tYXRjaChyZXF1ZXN0LCBtYXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzT3B0aW9ucyA9IHtcbiAgICAgICAgLi4ubWF0Y2hPcHRpb25zLFxuICAgICAgICBpZ25vcmVTZWFyY2g6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IGNhY2hlS2V5cyA9IGF3YWl0IGNhY2hlLmtleXMocmVxdWVzdCwga2V5c09wdGlvbnMpO1xuICAgIGZvciAoY29uc3QgY2FjaGVLZXkgb2YgY2FjaGVLZXlzKXtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWRDYWNoZUtleVVSTCA9IHN0cmlwUGFyYW1zKGNhY2hlS2V5LnVybCwgaWdub3JlUGFyYW1zKTtcbiAgICAgICAgaWYgKHN0cmlwcGVkUmVxdWVzdFVSTCA9PT0gc3RyaXBwZWRDYWNoZUtleVVSTCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLm1hdGNoKGNhY2hlS2V5LCBtYXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn1cblxuY29uc3QgcXVvdGFFcnJvckNhbGxiYWNrcyA9IG5ldyBTZXQoKTtcblxuY29uc3QgZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MgPSBhc3luYyAoKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgQWJvdXQgdG8gcnVuICR7cXVvdGFFcnJvckNhbGxiYWNrcy5zaXplfSBjYWxsYmFja3MgdG8gY2xlYW4gdXAgY2FjaGVzLmApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHF1b3RhRXJyb3JDYWxsYmFja3Mpe1xuICAgICAgICBhd2FpdCBjYWxsYmFjaygpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGNhbGxiYWNrLCBcImlzIGNvbXBsZXRlLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJGaW5pc2hlZCBydW5uaW5nIGNhbGxiYWNrcy5cIik7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gdGltZW91dChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PnNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxubGV0IHN1cHBvcnRTdGF0dXM7XG5mdW5jdGlvbiBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtKCkge1xuICAgIGlmIChzdXBwb3J0U3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGVzdFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKFwiXCIpO1xuICAgICAgICBpZiAoXCJib2R5XCIgaW4gdGVzdFJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBSZXNwb25zZSh0ZXN0UmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICAgICAgc3VwcG9ydFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoICB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cHBvcnRTdGF0dXMgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRTdGF0dXM7XG59XG5cbmNvbnN0IFNVQlNUUklOR19UT19GSU5EID0gXCItcHJlY2FjaGUtXCI7XG5jb25zdCBkZWxldGVPdXRkYXRlZENhY2hlcyA9IGFzeW5jIChjdXJyZW50UHJlY2FjaGVOYW1lLCBzdWJzdHJpbmdUb0ZpbmQgPSBTVUJTVFJJTkdfVE9fRklORCk9PntcbiAgICBjb25zdCBjYWNoZU5hbWVzID0gYXdhaXQgc2VsZi5jYWNoZXMua2V5cygpO1xuICAgIGNvbnN0IGNhY2hlTmFtZXNUb0RlbGV0ZSA9IGNhY2hlTmFtZXMuZmlsdGVyKChjYWNoZU5hbWUpPT57XG4gICAgICAgIHJldHVybiBjYWNoZU5hbWUuaW5jbHVkZXMoc3Vic3RyaW5nVG9GaW5kKSAmJiBjYWNoZU5hbWUuaW5jbHVkZXMoc2VsZi5yZWdpc3RyYXRpb24uc2NvcGUpICYmIGNhY2hlTmFtZSAhPT0gY3VycmVudFByZWNhY2hlTmFtZTtcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChjYWNoZU5hbWVzVG9EZWxldGUubWFwKChjYWNoZU5hbWUpPT5zZWxmLmNhY2hlcy5kZWxldGUoY2FjaGVOYW1lKSkpO1xuICAgIHJldHVybiBjYWNoZU5hbWVzVG9EZWxldGU7XG59O1xuXG5jb25zdCBjbGVhbnVwT3V0ZGF0ZWRDYWNoZXMgPSAoY2FjaGVOYW1lKT0+e1xuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImFjdGl2YXRlXCIsIChldmVudCk9PntcbiAgICAgICAgZXZlbnQud2FpdFVudGlsKGRlbGV0ZU91dGRhdGVkQ2FjaGVzKGNhY2hlTmFtZXMuZ2V0UHJlY2FjaGVOYW1lKGNhY2hlTmFtZSkpLnRoZW4oKGNhY2hlc0RlbGV0ZWQpPT57XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlc0RlbGV0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiVGhlIGZvbGxvd2luZyBvdXQtb2YtZGF0ZSBwcmVjYWNoZXMgd2VyZSBjbGVhbmVkIHVwIGF1dG9tYXRpY2FsbHk6XCIsIGNhY2hlc0RlbGV0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH0pO1xufTtcblxuY29uc3QgY2xpZW50c0NsYWltID0gKCk9PntcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJhY3RpdmF0ZVwiLCAoKT0+c2VsZi5jbGllbnRzLmNsYWltKCkpO1xufTtcblxuY29uc3Qgd2FpdFVudGlsID0gKGV2ZW50LCBhc3luY0ZuKT0+e1xuICAgIGNvbnN0IHJldHVyblByb21pc2UgPSBhc3luY0ZuKCk7XG4gICAgZXZlbnQud2FpdFVudGlsKHJldHVyblByb21pc2UpO1xuICAgIHJldHVybiByZXR1cm5Qcm9taXNlO1xufTtcblxuZXhwb3J0IHsgRGVmZXJyZWQgYXMgRCwgU2Vyd2lzdEVycm9yIGFzIFMsIGNsaWVudHNDbGFpbSBhcyBhLCBjbGVhbnVwT3V0ZGF0ZWRDYWNoZXMgYXMgYiwgY2FjaGVOYW1lcyBhcyBjLCBjYWNoZU1hdGNoSWdub3JlUGFyYW1zIGFzIGQsIGV4ZWN1dGVRdW90YUVycm9yQ2FsbGJhY2tzIGFzIGUsIGZpbmFsQXNzZXJ0RXhwb3J0cyBhcyBmLCBnZXRGcmllbmRseVVSTCBhcyBnLCBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtIGFzIGgsIGxvZ2dlciBhcyBsLCBxdW90YUVycm9yQ2FsbGJhY2tzIGFzIHEsIHRpbWVvdXQgYXMgdCwgd2FpdFVudGlsIGFzIHcgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/serwist/dist/chunks/waitUntil.js\n"));

/***/ }),

/***/ "./node_modules/serwist/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/serwist/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BROADCAST_UPDATE_DEFAULT_HEADERS: () => (/* binding */ BROADCAST_UPDATE_DEFAULT_HEADERS),\n/* harmony export */   BackgroundSyncPlugin: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   BackgroundSyncQueue: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   BackgroundSyncQueueStore: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   BroadcastCacheUpdate: () => (/* binding */ BroadcastCacheUpdate),\n/* harmony export */   BroadcastUpdatePlugin: () => (/* binding */ BroadcastUpdatePlugin),\n/* harmony export */   CacheExpiration: () => (/* binding */ CacheExpiration),\n/* harmony export */   CacheFirst: () => (/* binding */ CacheFirst),\n/* harmony export */   CacheOnly: () => (/* binding */ CacheOnly),\n/* harmony export */   CacheableResponse: () => (/* binding */ CacheableResponse),\n/* harmony export */   CacheableResponsePlugin: () => (/* binding */ CacheableResponsePlugin),\n/* harmony export */   ExpirationPlugin: () => (/* binding */ ExpirationPlugin),\n/* harmony export */   NavigationRoute: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   NetworkFirst: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   NetworkOnly: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   PrecacheFallbackPlugin: () => (/* binding */ PrecacheFallbackPlugin),\n/* harmony export */   PrecacheRoute: () => (/* binding */ PrecacheRoute),\n/* harmony export */   PrecacheStrategy: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   RangeRequestsPlugin: () => (/* binding */ RangeRequestsPlugin),\n/* harmony export */   RegExpRoute: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   Route: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   Serwist: () => (/* binding */ Serwist),\n/* harmony export */   StaleWhileRevalidate: () => (/* binding */ StaleWhileRevalidate),\n/* harmony export */   StorableRequest: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   Strategy: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   StrategyHandler: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   cacheNames: () => (/* binding */ cacheNames),\n/* harmony export */   copyResponse: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   createPartialResponse: () => (/* binding */ createPartialResponse),\n/* harmony export */   disableDevLogs: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   disableNavigationPreload: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   enableNavigationPreload: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   initializeGoogleAnalytics: () => (/* binding */ initializeGoogleAnalytics),\n/* harmony export */   isNavigationPreloadSupported: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   registerQuotaErrorCallback: () => (/* binding */ registerQuotaErrorCallback),\n/* harmony export */   responsesAreSame: () => (/* binding */ responsesAreSame),\n/* harmony export */   setCacheNameDetails: () => (/* reexport safe */ _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.s)\n/* harmony export */ });\n/* harmony import */ var _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/printInstallDetails.js */ \"./node_modules/serwist/dist/chunks/printInstallDetails.js\");\n/* harmony import */ var _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunks/waitUntil.js */ \"./node_modules/serwist/dist/chunks/waitUntil.js\");\n/* harmony import */ var _chunks_resultingClientExists_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunks/resultingClientExists.js */ \"./node_modules/serwist/dist/chunks/resultingClientExists.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"./node_modules/idb/build/index.js\");\n\n\n\n\n\n\nclass PrecacheRoute extends _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.R {\n    constructor(serwist, options){\n        const match = ({ request })=>{\n            const urlsToCacheKeys = serwist.getUrlsToPrecacheKeys();\n            for (const possibleURL of (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url, options)){\n                const cacheKey = urlsToCacheKeys.get(possibleURL);\n                if (cacheKey) {\n                    const integrity = serwist.getIntegrityForPrecacheKey(cacheKey);\n                    return {\n                        cacheKey,\n                        integrity\n                    };\n                }\n            }\n            if (true) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.debug(`Precaching did not find a match for ${(0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.g)(request.url)}.`);\n            }\n            return;\n        };\n        super(match, serwist.precacheStrategy);\n    }\n}\n\nconst QUEUE_NAME = \"serwist-google-analytics\";\nconst MAX_RETENTION_TIME = 60 * 48;\nconst GOOGLE_ANALYTICS_HOST = \"www.google-analytics.com\";\nconst GTM_HOST = \"www.googletagmanager.com\";\nconst ANALYTICS_JS_PATH = \"/analytics.js\";\nconst GTAG_JS_PATH = \"/gtag/js\";\nconst GTM_JS_PATH = \"/gtm.js\";\nconst COLLECT_PATHS_REGEX = /^\\/(\\w+\\/)?collect/;\n\nconst createOnSyncCallback = (config)=>{\n    return async ({ queue })=>{\n        let entry;\n        while(entry = await queue.shiftRequest()){\n            const { request, timestamp } = entry;\n            const url = new URL(request.url);\n            try {\n                const params = request.method === \"POST\" ? new URLSearchParams(await request.clone().text()) : url.searchParams;\n                const originalHitTime = timestamp - (Number(params.get(\"qt\")) || 0);\n                const queueTime = Date.now() - originalHitTime;\n                params.set(\"qt\", String(queueTime));\n                if (config.parameterOverrides) {\n                    for (const param of Object.keys(config.parameterOverrides)){\n                        const value = config.parameterOverrides[param];\n                        params.set(param, value);\n                    }\n                }\n                if (typeof config.hitFilter === \"function\") {\n                    config.hitFilter.call(null, params);\n                }\n                await fetch(new Request(url.origin + url.pathname, {\n                    body: params.toString(),\n                    method: \"POST\",\n                    mode: \"cors\",\n                    credentials: \"omit\",\n                    headers: {\n                        \"Content-Type\": \"text/plain\"\n                    }\n                }));\n                if (true) {\n                    _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(`Request for '${(0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.g)(url.href)}' has been replayed`);\n                }\n            } catch (err) {\n                await queue.unshiftRequest(entry);\n                if (true) {\n                    _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(`Request for '${(0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.g)(url.href)}' failed to replay, putting it back in the queue.`);\n                }\n                throw err;\n            }\n        }\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(\"All Google Analytics request successfully replayed; \" + \"the queue is now empty!\");\n        }\n    };\n};\nconst createCollectRoutes = (bgSyncPlugin)=>{\n    const match = ({ url })=>url.hostname === GOOGLE_ANALYTICS_HOST && COLLECT_PATHS_REGEX.test(url.pathname);\n    const handler = new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.a({\n        plugins: [\n            bgSyncPlugin\n        ]\n    });\n    return [\n        new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.R(match, handler, \"GET\"),\n        new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.R(match, handler, \"POST\")\n    ];\n};\nconst createAnalyticsJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GOOGLE_ANALYTICS_HOST && url.pathname === ANALYTICS_JS_PATH;\n    const handler = new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.N({\n        cacheName\n    });\n    return new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.R(match, handler, \"GET\");\n};\nconst createGtagJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GTM_HOST && url.pathname === GTAG_JS_PATH;\n    const handler = new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.N({\n        cacheName\n    });\n    return new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.R(match, handler, \"GET\");\n};\nconst createGtmJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GTM_HOST && url.pathname === GTM_JS_PATH;\n    const handler = new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.N({\n        cacheName\n    });\n    return new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.R(match, handler, \"GET\");\n};\nconst initializeGoogleAnalytics = ({ serwist, cacheName, ...options })=>{\n    const resolvedCacheName = _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.c.getGoogleAnalyticsName(cacheName);\n    const bgSyncPlugin = new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.B(QUEUE_NAME, {\n        maxRetentionTime: MAX_RETENTION_TIME,\n        onSync: createOnSyncCallback(options)\n    });\n    const routes = [\n        createGtmJsRoute(resolvedCacheName),\n        createAnalyticsJsRoute(resolvedCacheName),\n        createGtagJsRoute(resolvedCacheName),\n        ...createCollectRoutes(bgSyncPlugin)\n    ];\n    for (const route of routes){\n        serwist.registerRoute(route);\n    }\n};\n\nclass PrecacheFallbackPlugin {\n    _fallbackUrls;\n    _serwist;\n    constructor({ fallbackUrls, serwist }){\n        this._fallbackUrls = fallbackUrls;\n        this._serwist = serwist;\n    }\n    async handlerDidError(param) {\n        for (const fallback of this._fallbackUrls){\n            if (typeof fallback === \"string\") {\n                const fallbackResponse = await this._serwist.matchPrecache(fallback);\n                if (fallbackResponse !== undefined) {\n                    return fallbackResponse;\n                }\n            } else if (fallback.matcher(param)) {\n                const fallbackResponse = await this._serwist.matchPrecache(fallback.url);\n                if (fallbackResponse !== undefined) {\n                    return fallbackResponse;\n                }\n            }\n        }\n        return undefined;\n    }\n}\n\nclass PrecacheCacheKeyPlugin {\n    _precacheController;\n    constructor({ precacheController }){\n        this._precacheController = precacheController;\n    }\n    cacheKeyWillBeUsed = async ({ request, params })=>{\n        const cacheKey = params?.cacheKey || this._precacheController.getPrecacheKeyForUrl(request.url);\n        return cacheKey ? new Request(cacheKey, {\n            headers: request.headers\n        }) : request;\n    };\n}\n\nconst parsePrecacheOptions = (serwist, precacheOptions = {})=>{\n    const { cacheName: precacheCacheName, plugins: precachePlugins = [], fetchOptions: precacheFetchOptions, matchOptions: precacheMatchOptions, fallbackToNetwork: precacheFallbackToNetwork, directoryIndex: precacheDirectoryIndex, ignoreURLParametersMatching: precacheIgnoreUrls, cleanURLs: precacheCleanUrls, urlManipulation: precacheUrlManipulation, cleanupOutdatedCaches, concurrency = 10, navigateFallback, navigateFallbackAllowlist, navigateFallbackDenylist } = precacheOptions ?? {};\n    return {\n        precacheStrategyOptions: {\n            cacheName: _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.c.getPrecacheName(precacheCacheName),\n            plugins: [\n                ...precachePlugins,\n                new PrecacheCacheKeyPlugin({\n                    precacheController: serwist\n                })\n            ],\n            fetchOptions: precacheFetchOptions,\n            matchOptions: precacheMatchOptions,\n            fallbackToNetwork: precacheFallbackToNetwork\n        },\n        precacheRouteOptions: {\n            directoryIndex: precacheDirectoryIndex,\n            ignoreURLParametersMatching: precacheIgnoreUrls,\n            cleanURLs: precacheCleanUrls,\n            urlManipulation: precacheUrlManipulation\n        },\n        precacheMiscOptions: {\n            cleanupOutdatedCaches,\n            concurrency,\n            navigateFallback,\n            navigateFallbackAllowlist,\n            navigateFallbackDenylist\n        }\n    };\n};\n\nclass Serwist {\n    _urlsToCacheKeys = new Map();\n    _urlsToCacheModes = new Map();\n    _cacheKeysToIntegrities = new Map();\n    _concurrentPrecaching;\n    _precacheStrategy;\n    _routes;\n    _defaultHandlerMap;\n    _catchHandler;\n    constructor({ precacheEntries, precacheOptions, skipWaiting = false, importScripts, navigationPreload = false, cacheId, clientsClaim: clientsClaim$1 = false, runtimeCaching, offlineAnalyticsConfig, disableDevLogs: disableDevLogs$1 = false, fallbacks } = {}){\n        const { precacheStrategyOptions, precacheRouteOptions, precacheMiscOptions } = parsePrecacheOptions(this, precacheOptions);\n        this._concurrentPrecaching = precacheMiscOptions.concurrency;\n        this._precacheStrategy = new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.P(precacheStrategyOptions);\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n        this.handleInstall = this.handleInstall.bind(this);\n        this.handleActivate = this.handleActivate.bind(this);\n        this.handleFetch = this.handleFetch.bind(this);\n        this.handleCache = this.handleCache.bind(this);\n        if (!!importScripts && importScripts.length > 0) self.importScripts(...importScripts);\n        if (navigationPreload) (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.e)();\n        if (cacheId !== undefined) {\n            (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.s)({\n                prefix: cacheId\n            });\n        }\n        if (skipWaiting) {\n            self.skipWaiting();\n        } else {\n            self.addEventListener(\"message\", (event)=>{\n                if (event.data && event.data.type === \"SKIP_WAITING\") {\n                    self.skipWaiting();\n                }\n            });\n        }\n        if (clientsClaim$1) (0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.a)();\n        if (!!precacheEntries && precacheEntries.length > 0) {\n            this.addToPrecacheList(precacheEntries);\n        }\n        if (precacheMiscOptions.cleanupOutdatedCaches) {\n            (0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.b)(precacheStrategyOptions.cacheName);\n        }\n        this.registerRoute(new PrecacheRoute(this, precacheRouteOptions));\n        if (precacheMiscOptions.navigateFallback) {\n            this.registerRoute(new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.b(this.createHandlerBoundToUrl(precacheMiscOptions.navigateFallback), {\n                allowlist: precacheMiscOptions.navigateFallbackAllowlist,\n                denylist: precacheMiscOptions.navigateFallbackDenylist\n            }));\n        }\n        if (offlineAnalyticsConfig !== undefined) {\n            if (typeof offlineAnalyticsConfig === \"boolean\") {\n                offlineAnalyticsConfig && initializeGoogleAnalytics({\n                    serwist: this\n                });\n            } else {\n                initializeGoogleAnalytics({\n                    ...offlineAnalyticsConfig,\n                    serwist: this\n                });\n            }\n        }\n        if (runtimeCaching !== undefined) {\n            if (fallbacks !== undefined) {\n                const fallbackPlugin = new PrecacheFallbackPlugin({\n                    fallbackUrls: fallbacks.entries,\n                    serwist: this\n                });\n                runtimeCaching.forEach((cacheEntry)=>{\n                    if (cacheEntry.handler instanceof _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.S && !cacheEntry.handler.plugins.some((plugin)=>\"handlerDidError\" in plugin)) {\n                        cacheEntry.handler.plugins.push(fallbackPlugin);\n                    }\n                });\n            }\n            for (const entry of runtimeCaching){\n                this.registerCapture(entry.matcher, entry.handler, entry.method);\n            }\n        }\n        if (disableDevLogs$1) (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.d)();\n    }\n    get precacheStrategy() {\n        return this._precacheStrategy;\n    }\n    get routes() {\n        return this._routes;\n    }\n    addEventListeners() {\n        self.addEventListener(\"install\", this.handleInstall);\n        self.addEventListener(\"activate\", this.handleActivate);\n        self.addEventListener(\"fetch\", this.handleFetch);\n        self.addEventListener(\"message\", this.handleCache);\n    }\n    addToPrecacheList(entries) {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isArray(entries, {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"addToCacheList\",\n                paramName: \"entries\"\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries){\n            if (typeof entry === \"string\") {\n                urlsToWarnAbout.push(entry);\n            } else if (entry && !entry.integrity && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.c)(entry);\n            const cacheMode = typeof entry !== \"string\" && entry.revision ? \"reload\" : \"default\";\n            if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"add-to-cache-list-conflicting-entries\", {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey\n                });\n            }\n            if (typeof entry !== \"string\" && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"add-to-cache-list-conflicting-integrities\", {\n                        url\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Serwist is precaching URLs without revision info: ${urlsToWarnAbout.join(\", \")}\\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;\n                if (false) {} else {\n                    _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(warningMessage);\n                }\n            }\n        }\n    }\n    handleInstall(event) {\n        return (0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.w)(event, async ()=>{\n            const installReportPlugin = new _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.h();\n            this.precacheStrategy.plugins.push(installReportPlugin);\n            await (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.i)(this._concurrentPrecaching, Array.from(this._urlsToCacheKeys.entries()), async ([url, cacheKey])=>{\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: \"same-origin\"\n                });\n                await Promise.all(this.precacheStrategy.handleAll({\n                    event,\n                    request,\n                    url: new URL(request.url),\n                    params: {\n                        cacheKey\n                    }\n                }));\n            });\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (true) {\n                (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.j)(updatedURLs, notUpdatedURLs);\n            }\n            return {\n                updatedURLs,\n                notUpdatedURLs\n            };\n        });\n    }\n    handleActivate(event) {\n        return (0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.w)(event, async ()=>{\n            const cache = await self.caches.open(this.precacheStrategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedCacheRequests = [];\n            for (const request of currentlyCachedRequests){\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedCacheRequests.push(request.url);\n                }\n            }\n            if (true) {\n                (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.k)(deletedCacheRequests);\n            }\n            return {\n                deletedCacheRequests\n            };\n        });\n    }\n    handleFetch(event) {\n        const { request } = event;\n        const responsePromise = this.handleRequest({\n            request,\n            event\n        });\n        if (responsePromise) {\n            event.respondWith(responsePromise);\n        }\n    }\n    handleCache(event) {\n        if (event.data && event.data.type === \"CACHE_URLS\") {\n            const { payload } = event.data;\n            if (true) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.debug(\"Caching URLs from the window\", payload.urlsToCache);\n            }\n            const requestPromises = Promise.all(payload.urlsToCache.map((entry)=>{\n                let request;\n                if (typeof entry === \"string\") {\n                    request = new Request(entry);\n                } else {\n                    request = new Request(...entry);\n                }\n                return this.handleRequest({\n                    request,\n                    event\n                });\n            }));\n            event.waitUntil(requestPromises);\n            if (event.ports?.[0]) {\n                void requestPromises.then(()=>event.ports[0].postMessage(true));\n            }\n        }\n    }\n    setDefaultHandler(handler, method = _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.f) {\n        this._defaultHandlerMap.set(method, (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.n)(handler));\n    }\n    setCatchHandler(handler) {\n        this._catchHandler = (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.n)(handler);\n    }\n    registerCapture(capture, handler, method) {\n        const route = (0,_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.p)(capture, handler, method);\n        this.registerRoute(route);\n        return route;\n    }\n    registerRoute(route) {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(route, \"object\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.hasMethod(route, \"match\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(route.handler, \"object\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.hasMethod(route.handler, \"handle\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route.handler\"\n            });\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(route.method, \"string\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route.method\"\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        this._routes.get(route.method).push(route);\n    }\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"unregister-route-but-not-found-with-method\", {\n                method: route.method\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        } else {\n            throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"unregister-route-route-not-registered\");\n        }\n    }\n    getUrlsToPrecacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    getPrecachedUrls() {\n        return [\n            ...this._urlsToCacheKeys.keys()\n        ];\n    }\n    getPrecacheKeyForUrl(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    getIntegrityForPrecacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getPrecacheKeyForUrl(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.precacheStrategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    createHandlerBoundToUrl(url) {\n        const cacheKey = this.getPrecacheKeyForUrl(url);\n        if (!cacheKey) {\n            throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"non-precached-url\", {\n                url\n            });\n        }\n        return (options)=>{\n            options.request = new Request(url);\n            options.params = {\n                cacheKey,\n                ...options.params\n            };\n            return this.precacheStrategy.handle(options);\n        };\n    }\n    handleRequest({ request, event }) {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"handleRequest\",\n                paramName: \"options.request\"\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith(\"http\")) {\n            if (true) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.debug(\"Router only supports URLs that start with 'http'.\");\n            }\n            return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const { params, route } = this.findMatchingRoute({\n            event,\n            request,\n            sameOrigin,\n            url\n        });\n        let handler = route?.handler;\n        const debugMessages = [];\n        if (true) {\n            if (handler) {\n                debugMessages.push([\n                    \"Found a route to handle this request:\",\n                    route\n                ]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`,\n                        params\n                    ]);\n                }\n            }\n        }\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n            if (true) {\n                debugMessages.push(`Failed to find a matching route. Falling back to the default handler for ${method}.`);\n            }\n            handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n            if (true) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.debug(`No route found for: ${(0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.g)(url)}`);\n            }\n            return;\n        }\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(`Router is responding to: ${(0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.g)(url)}`);\n            for (const msg of debugMessages){\n                if (Array.isArray(msg)) {\n                    _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(...msg);\n                } else {\n                    _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(msg);\n                }\n            }\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n        }\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({\n                url,\n                request,\n                event,\n                params\n            });\n        } catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        const catchHandler = route?.catchHandler;\n        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n            responsePromise = responsePromise.catch(async (err)=>{\n                if (catchHandler) {\n                    if (true) {\n                        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(`Error thrown when responding to:  ${(0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.g)(url)}. Falling back to route's Catch Handler.`);\n                        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.error(\"Error thrown by:\", route);\n                        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.error(err);\n                        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n                    }\n                    try {\n                        return await catchHandler.handle({\n                            url,\n                            request,\n                            event,\n                            params\n                        });\n                    } catch (catchErr) {\n                        if (catchErr instanceof Error) {\n                            err = catchErr;\n                        }\n                    }\n                }\n                if (this._catchHandler) {\n                    if (true) {\n                        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(`Error thrown when responding to:  ${(0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.g)(url)}. Falling back to global Catch Handler.`);\n                        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.error(\"Error thrown by:\", route);\n                        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.error(err);\n                        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n                    }\n                    return this._catchHandler.handle({\n                        url,\n                        request,\n                        event\n                    });\n                }\n                throw err;\n            });\n        }\n        return responsePromise;\n    }\n    findMatchingRoute({ url, sameOrigin, request, event }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes){\n            let params;\n            const matchResult = route.match({\n                url,\n                sameOrigin,\n                request,\n                event\n            });\n            if (matchResult) {\n                if (true) {\n                    if (matchResult instanceof Promise) {\n                        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`While routing ${(0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.g)(url)}, an async matchCallback function was used. Please convert the following route to use a synchronous matchCallback function:`, route);\n                    }\n                }\n                params = matchResult;\n                if (Array.isArray(params) && params.length === 0) {\n                    params = undefined;\n                } else if (matchResult.constructor === Object && Object.keys(matchResult).length === 0) {\n                    params = undefined;\n                } else if (typeof matchResult === \"boolean\") {\n                    params = undefined;\n                }\n                return {\n                    route,\n                    params\n                };\n            }\n        }\n        return {};\n    }\n}\n\nconst cacheNames = {\n    get googleAnalytics () {\n        return _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.c.getGoogleAnalyticsName();\n    },\n    get precache () {\n        return _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.c.getPrecacheName();\n    },\n    get prefix () {\n        return _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.c.getPrefix();\n    },\n    get runtime () {\n        return _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.c.getRuntimeName();\n    },\n    get suffix () {\n        return _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.c.getSuffix();\n    }\n};\n\nconst BROADCAST_UPDATE_MESSAGE_TYPE = \"CACHE_UPDATED\";\nconst BROADCAST_UPDATE_MESSAGE_META = \"serwist-broadcast-update\";\nconst BROADCAST_UPDATE_DEFAULT_NOTIFY = true;\nconst BROADCAST_UPDATE_DEFAULT_HEADERS = [\n    \"content-length\",\n    \"etag\",\n    \"last-modified\"\n];\n\nconst responsesAreSame = (firstResponse, secondResponse, headersToCheck)=>{\n    if (true) {\n        if (!(firstResponse instanceof Response && secondResponse instanceof Response)) {\n            throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"invalid-responses-are-same-args\");\n        }\n    }\n    const atLeastOneHeaderAvailable = headersToCheck.some((header)=>{\n        return firstResponse.headers.has(header) && secondResponse.headers.has(header);\n    });\n    if (!atLeastOneHeaderAvailable) {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(\"Unable to determine where the response has been updated because none of the headers that would be checked are present.\");\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.debug(\"Attempting to compare the following: \", firstResponse, secondResponse, headersToCheck);\n        }\n        return true;\n    }\n    return headersToCheck.every((header)=>{\n        const headerStateComparison = firstResponse.headers.has(header) === secondResponse.headers.has(header);\n        const headerValueComparison = firstResponse.headers.get(header) === secondResponse.headers.get(header);\n        return headerStateComparison && headerValueComparison;\n    });\n};\n\nconst isSafari = typeof navigator !== \"undefined\" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nconst defaultPayloadGenerator = (data)=>{\n    return {\n        cacheName: data.cacheName,\n        updatedURL: data.request.url\n    };\n};\nclass BroadcastCacheUpdate {\n    _headersToCheck;\n    _generatePayload;\n    _notifyAllClients;\n    constructor({ generatePayload, headersToCheck, notifyAllClients } = {}){\n        this._headersToCheck = headersToCheck || BROADCAST_UPDATE_DEFAULT_HEADERS;\n        this._generatePayload = generatePayload || defaultPayloadGenerator;\n        this._notifyAllClients = notifyAllClients ?? BROADCAST_UPDATE_DEFAULT_NOTIFY;\n    }\n    async notifyIfUpdated(options) {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(options.cacheName, \"string\", {\n                moduleName: \"serwist\",\n                className: \"BroadcastCacheUpdate\",\n                funcName: \"notifyIfUpdated\",\n                paramName: \"cacheName\"\n            });\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(options.newResponse, Response, {\n                moduleName: \"serwist\",\n                className: \"BroadcastCacheUpdate\",\n                funcName: \"notifyIfUpdated\",\n                paramName: \"newResponse\"\n            });\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(options.request, Request, {\n                moduleName: \"serwist\",\n                className: \"BroadcastCacheUpdate\",\n                funcName: \"notifyIfUpdated\",\n                paramName: \"request\"\n            });\n        }\n        if (!options.oldResponse) {\n            return;\n        }\n        if (!responsesAreSame(options.oldResponse, options.newResponse, this._headersToCheck)) {\n            if (true) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(\"Newer response found (and cached) for:\", options.request.url);\n            }\n            const messageData = {\n                type: BROADCAST_UPDATE_MESSAGE_TYPE,\n                meta: BROADCAST_UPDATE_MESSAGE_META,\n                payload: this._generatePayload(options)\n            };\n            if (options.request.mode === \"navigate\") {\n                let resultingClientId;\n                if (options.event instanceof FetchEvent) {\n                    resultingClientId = options.event.resultingClientId;\n                }\n                const resultingWin = await (0,_chunks_resultingClientExists_js__WEBPACK_IMPORTED_MODULE_2__.r)(resultingClientId);\n                if (!resultingWin || isSafari) {\n                    await (0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.t)(3500);\n                }\n            }\n            if (this._notifyAllClients) {\n                const windows = await self.clients.matchAll({\n                    type: \"window\"\n                });\n                for (const win of windows){\n                    win.postMessage(messageData);\n                }\n            } else {\n                if (options.event instanceof FetchEvent) {\n                    const client = await self.clients.get(options.event.clientId);\n                    client?.postMessage(messageData);\n                }\n            }\n        }\n    }\n}\n\nclass BroadcastUpdatePlugin {\n    _broadcastUpdate;\n    constructor(options){\n        this._broadcastUpdate = new BroadcastCacheUpdate(options);\n    }\n    cacheDidUpdate(options) {\n        void this._broadcastUpdate.notifyIfUpdated(options);\n    }\n}\n\nclass CacheableResponse {\n    _statuses;\n    _headers;\n    constructor(config = {}){\n        if (true) {\n            if (!(config.statuses || config.headers)) {\n                throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"statuses-or-headers-required\", {\n                    moduleName: \"serwist\",\n                    className: \"CacheableResponse\",\n                    funcName: \"constructor\"\n                });\n            }\n            if (config.statuses) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isArray(config.statuses, {\n                    moduleName: \"serwist\",\n                    className: \"CacheableResponse\",\n                    funcName: \"constructor\",\n                    paramName: \"config.statuses\"\n                });\n            }\n            if (config.headers) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(config.headers, \"object\", {\n                    moduleName: \"serwist\",\n                    className: \"CacheableResponse\",\n                    funcName: \"constructor\",\n                    paramName: \"config.headers\"\n                });\n            }\n        }\n        this._statuses = config.statuses;\n        if (config.headers) {\n            this._headers = new Headers(config.headers);\n        }\n    }\n    isResponseCacheable(response) {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(response, Response, {\n                moduleName: \"serwist\",\n                className: \"CacheableResponse\",\n                funcName: \"isResponseCacheable\",\n                paramName: \"response\"\n            });\n        }\n        let cacheable = true;\n        if (this._statuses) {\n            cacheable = this._statuses.includes(response.status);\n        }\n        if (this._headers && cacheable) {\n            for (const [headerName, headerValue] of this._headers.entries()){\n                if (response.headers.get(headerName) !== headerValue) {\n                    cacheable = false;\n                    break;\n                }\n            }\n        }\n        if (true) {\n            if (!cacheable) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(`The request for '${(0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.g)(response.url)}' returned a response that does not meet the criteria for being cached.`);\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(\"View cacheability criteria here.\");\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(`Cacheable statuses: ${JSON.stringify(this._statuses)}`);\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(`Cacheable headers: ${JSON.stringify(this._headers, null, 2)}`);\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n                const logFriendlyHeaders = {};\n                response.headers.forEach((value, key)=>{\n                    logFriendlyHeaders[key] = value;\n                });\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(\"View response status and headers here.\");\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(`Response status: ${response.status}`);\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(`Response headers: ${JSON.stringify(logFriendlyHeaders, null, 2)}`);\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(\"View full response details here.\");\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(response.headers);\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(response);\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n            }\n        }\n        return cacheable;\n    }\n}\n\nclass CacheableResponsePlugin {\n    _cacheableResponse;\n    constructor(config){\n        this._cacheableResponse = new CacheableResponse(config);\n    }\n    cacheWillUpdate = async ({ response })=>{\n        if (this._cacheableResponse.isResponseCacheable(response)) {\n            return response;\n        }\n        return null;\n    };\n}\n\nconst DB_NAME = \"serwist-expiration\";\nconst CACHE_OBJECT_STORE = \"cache-entries\";\nconst normalizeURL = (unNormalizedUrl)=>{\n    const url = new URL(unNormalizedUrl, location.href);\n    url.hash = \"\";\n    return url.href;\n};\nclass CacheTimestampsModel {\n    _cacheName;\n    _db = null;\n    constructor(cacheName){\n        this._cacheName = cacheName;\n    }\n    _getId(url) {\n        return `${this._cacheName}|${normalizeURL(url)}`;\n    }\n    _upgradeDb(db) {\n        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, {\n            keyPath: \"id\"\n        });\n        objStore.createIndex(\"cacheName\", \"cacheName\", {\n            unique: false\n        });\n        objStore.createIndex(\"timestamp\", \"timestamp\", {\n            unique: false\n        });\n    }\n    _upgradeDbAndDeleteOldDbs(db) {\n        this._upgradeDb(db);\n        if (this._cacheName) {\n            void (0,idb__WEBPACK_IMPORTED_MODULE_3__.deleteDB)(this._cacheName);\n        }\n    }\n    async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n            id: this._getId(url),\n            cacheName: this._cacheName,\n            url,\n            timestamp\n        };\n        const db = await this.getDb();\n        const tx = db.transaction(CACHE_OBJECT_STORE, \"readwrite\", {\n            durability: \"relaxed\"\n        });\n        await tx.store.put(entry);\n        await tx.done;\n    }\n    async getTimestamp(url) {\n        const db = await this.getDb();\n        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n        return entry?.timestamp;\n    }\n    async expireEntries(minTimestamp, maxCount) {\n        const db = await this.getDb();\n        let cursor = await db.transaction(CACHE_OBJECT_STORE, \"readwrite\").store.index(\"timestamp\").openCursor(null, \"prev\");\n        const urlsDeleted = [];\n        let entriesNotDeletedCount = 0;\n        while(cursor){\n            const result = cursor.value;\n            if (result.cacheName === this._cacheName) {\n                if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n                    cursor.delete();\n                    urlsDeleted.push(result.url);\n                } else {\n                    entriesNotDeletedCount++;\n                }\n            }\n            cursor = await cursor.continue();\n        }\n        return urlsDeleted;\n    }\n    async getDb() {\n        if (!this._db) {\n            this._db = await (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, 1, {\n                upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)\n            });\n        }\n        return this._db;\n    }\n}\n\nclass CacheExpiration {\n    _isRunning = false;\n    _rerunRequested = false;\n    _maxEntries;\n    _maxAgeSeconds;\n    _matchOptions;\n    _cacheName;\n    _timestampModel;\n    constructor(cacheName, config = {}){\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(cacheName, \"string\", {\n                moduleName: \"serwist\",\n                className: \"CacheExpiration\",\n                funcName: \"constructor\",\n                paramName: \"cacheName\"\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"max-entries-or-age-required\", {\n                    moduleName: \"serwist\",\n                    className: \"CacheExpiration\",\n                    funcName: \"constructor\"\n                });\n            }\n            if (config.maxEntries) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(config.maxEntries, \"number\", {\n                    moduleName: \"serwist\",\n                    className: \"CacheExpiration\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxEntries\"\n                });\n            }\n            if (config.maxAgeSeconds) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(config.maxAgeSeconds, \"number\", {\n                    moduleName: \"serwist\",\n                    className: \"CacheExpiration\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxAgeSeconds\"\n                });\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired){\n            await cache.delete(url, this._matchOptions);\n        }\n        if (true) {\n            if (urlsExpired.length > 0) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? \"entry\" : \"entries\"} and removed ` + `${urlsExpired.length === 1 ? \"it\" : \"them\"} from the ` + `'${this._cacheName}' cache.`);\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(`Expired the following ${urlsExpired.length === 1 ? \"URL\" : \"URLs\"}:`);\n                for (const url of urlsExpired){\n                    _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(`    ${url}`);\n                }\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n            } else {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.debug(\"Cache expiration ran and found no entries to remove.\");\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            void this.expireEntries();\n        }\n    }\n    async updateTimestamp(url) {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(url, \"string\", {\n                moduleName: \"serwist\",\n                className: \"CacheExpiration\",\n                funcName: \"updateTimestamp\",\n                paramName: \"url\"\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (true) {\n                throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"expired-test-without-max-age\", {\n                    methodName: \"isURLExpired\",\n                    paramName: \"maxAgeSeconds\"\n                });\n            }\n            return false;\n        }\n        const timestamp = await this._timestampModel.getTimestamp(url);\n        const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n        return timestamp !== undefined ? timestamp < expireOlderThan : true;\n    }\n    async delete() {\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Number.POSITIVE_INFINITY);\n    }\n}\n\nconst registerQuotaErrorCallback = (callback)=>{\n    if (true) {\n        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(callback, \"function\", {\n            moduleName: \"@serwist/core\",\n            funcName: \"register\",\n            paramName: \"callback\"\n        });\n    }\n    _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.q.add(callback);\n    if (true) {\n        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(\"Registered a callback to respond to quota errors.\", callback);\n    }\n};\n\nclass ExpirationPlugin {\n    _config;\n    _cacheExpirations;\n    constructor(config = {}){\n        if (true) {\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"max-entries-or-age-required\", {\n                    moduleName: \"serwist\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\"\n                });\n            }\n            if (config.maxEntries) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(config.maxEntries, \"number\", {\n                    moduleName: \"serwist\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxEntries\"\n                });\n            }\n            if (config.maxAgeSeconds) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(config.maxAgeSeconds, \"number\", {\n                    moduleName: \"serwist\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxAgeSeconds\"\n                });\n            }\n            if (config.maxAgeFrom) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(config.maxAgeFrom, \"string\", {\n                    moduleName: \"serwist\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxAgeFrom\"\n                });\n            }\n        }\n        this._config = config;\n        this._cacheExpirations = new Map();\n        if (!this._config.maxAgeFrom) {\n            this._config.maxAgeFrom = \"last-fetched\";\n        }\n        if (this._config.purgeOnQuotaError) {\n            registerQuotaErrorCallback(()=>this.deleteCacheAndMetadata());\n        }\n    }\n    _getCacheExpiration(cacheName) {\n        if (cacheName === _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.c.getRuntimeName()) {\n            throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"expire-custom-caches-only\");\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\n            this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n    }\n    cachedResponseWillBeUsed({ event, cacheName, request, cachedResponse }) {\n        if (!cachedResponse) {\n            return null;\n        }\n        const isFresh = this._isResponseDateFresh(cachedResponse);\n        const cacheExpiration = this._getCacheExpiration(cacheName);\n        const isMaxAgeFromLastUsed = this._config.maxAgeFrom === \"last-used\";\n        const done = (async ()=>{\n            if (isMaxAgeFromLastUsed) {\n                await cacheExpiration.updateTimestamp(request.url);\n            }\n            await cacheExpiration.expireEntries();\n        })();\n        try {\n            event.waitUntil(done);\n        } catch  {\n            if (true) {\n                if (event instanceof FetchEvent) {\n                    _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`Unable to ensure service worker stays alive when updating cache entry for '${(0,_chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.g)(event.request.url)}'.`);\n                }\n            }\n        }\n        return isFresh ? cachedResponse : null;\n    }\n    _isResponseDateFresh(cachedResponse) {\n        const isMaxAgeFromLastUsed = this._config.maxAgeFrom === \"last-used\";\n        if (isMaxAgeFromLastUsed) {\n            return true;\n        }\n        const now = Date.now();\n        if (!this._config.maxAgeSeconds) {\n            return true;\n        }\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n            return true;\n        }\n        return dateHeaderTimestamp >= now - this._config.maxAgeSeconds * 1000;\n    }\n    _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has(\"date\")) {\n            return null;\n        }\n        const dateHeader = cachedResponse.headers.get(\"date\");\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        if (Number.isNaN(headerTime)) {\n            return null;\n        }\n        return headerTime;\n    }\n    async cacheDidUpdate({ cacheName, request }) {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(cacheName, \"string\", {\n                moduleName: \"serwist\",\n                className: \"Plugin\",\n                funcName: \"cacheDidUpdate\",\n                paramName: \"cacheName\"\n            });\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: \"Plugin\",\n                funcName: \"cacheDidUpdate\",\n                paramName: \"request\"\n            });\n        }\n        const cacheExpiration = this._getCacheExpiration(cacheName);\n        await cacheExpiration.updateTimestamp(request.url);\n        await cacheExpiration.expireEntries();\n    }\n    async deleteCacheAndMetadata() {\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations){\n            await self.caches.delete(cacheName);\n            await cacheExpiration.delete();\n        }\n        this._cacheExpirations = new Map();\n    }\n}\n\nconst calculateEffectiveBoundaries = (blob, start, end)=>{\n    if (true) {\n        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(blob, Blob, {\n            moduleName: \"@serwist/range-requests\",\n            funcName: \"calculateEffectiveBoundaries\",\n            paramName: \"blob\"\n        });\n    }\n    const blobSize = blob.size;\n    if (end && end > blobSize || start && start < 0) {\n        throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"range-not-satisfiable\", {\n            size: blobSize,\n            end,\n            start\n        });\n    }\n    let effectiveStart;\n    let effectiveEnd;\n    if (start !== undefined && end !== undefined) {\n        effectiveStart = start;\n        effectiveEnd = end + 1;\n    } else if (start !== undefined && end === undefined) {\n        effectiveStart = start;\n        effectiveEnd = blobSize;\n    } else if (end !== undefined && start === undefined) {\n        effectiveStart = blobSize - end;\n        effectiveEnd = blobSize;\n    }\n    return {\n        start: effectiveStart,\n        end: effectiveEnd\n    };\n};\n\nconst parseRangeHeader = (rangeHeader)=>{\n    if (true) {\n        _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isType(rangeHeader, \"string\", {\n            moduleName: \"@serwist/range-requests\",\n            funcName: \"parseRangeHeader\",\n            paramName: \"rangeHeader\"\n        });\n    }\n    const normalizedRangeHeader = rangeHeader.trim().toLowerCase();\n    if (!normalizedRangeHeader.startsWith(\"bytes=\")) {\n        throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"unit-must-be-bytes\", {\n            normalizedRangeHeader\n        });\n    }\n    if (normalizedRangeHeader.includes(\",\")) {\n        throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"single-range-only\", {\n            normalizedRangeHeader\n        });\n    }\n    const rangeParts = /(\\d*)-(\\d*)/.exec(normalizedRangeHeader);\n    if (!rangeParts || !(rangeParts[1] || rangeParts[2])) {\n        throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"invalid-range-values\", {\n            normalizedRangeHeader\n        });\n    }\n    return {\n        start: rangeParts[1] === \"\" ? undefined : Number(rangeParts[1]),\n        end: rangeParts[2] === \"\" ? undefined : Number(rangeParts[2])\n    };\n};\n\nconst createPartialResponse = async (request, originalResponse)=>{\n    try {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(request, Request, {\n                moduleName: \"@serwist/range-requests\",\n                funcName: \"createPartialResponse\",\n                paramName: \"request\"\n            });\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(originalResponse, Response, {\n                moduleName: \"@serwist/range-requests\",\n                funcName: \"createPartialResponse\",\n                paramName: \"originalResponse\"\n            });\n        }\n        if (originalResponse.status === 206) {\n            return originalResponse;\n        }\n        const rangeHeader = request.headers.get(\"range\");\n        if (!rangeHeader) {\n            throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"no-range-header\");\n        }\n        const boundaries = parseRangeHeader(rangeHeader);\n        const originalBlob = await originalResponse.blob();\n        const effectiveBoundaries = calculateEffectiveBoundaries(originalBlob, boundaries.start, boundaries.end);\n        const slicedBlob = originalBlob.slice(effectiveBoundaries.start, effectiveBoundaries.end);\n        const slicedBlobSize = slicedBlob.size;\n        const slicedResponse = new Response(slicedBlob, {\n            status: 206,\n            statusText: \"Partial Content\",\n            headers: originalResponse.headers\n        });\n        slicedResponse.headers.set(\"Content-Length\", String(slicedBlobSize));\n        slicedResponse.headers.set(\"Content-Range\", `bytes ${effectiveBoundaries.start}-${effectiveBoundaries.end - 1}/` + `${originalBlob.size}`);\n        return slicedResponse;\n    } catch (error) {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(\"Unable to construct a partial response; returning a \" + \"416 Range Not Satisfiable response instead.\");\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(\"View details here.\");\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(error);\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(request);\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(originalResponse);\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n        }\n        return new Response(\"\", {\n            status: 416,\n            statusText: \"Range Not Satisfiable\"\n        });\n    }\n};\n\nclass RangeRequestsPlugin {\n    cachedResponseWillBeUsed = async ({ request, cachedResponse })=>{\n        if (cachedResponse && request.headers.has(\"range\")) {\n            return await createPartialResponse(request, cachedResponse);\n        }\n        return cachedResponse;\n    };\n}\n\nclass CacheFirst extends _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.S {\n    async _handle(request, handler) {\n        const logs = [];\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: this.constructor.name,\n                funcName: \"makeRequest\",\n                paramName: \"request\"\n            });\n        }\n        let response = await handler.cacheMatch(request);\n        let error;\n        if (!response) {\n            if (true) {\n                logs.push(`No response found in the '${this.cacheName}' cache. Will respond with a network request.`);\n            }\n            try {\n                response = await handler.fetchAndCachePut(request);\n            } catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n            if (true) {\n                if (response) {\n                    logs.push(\"Got response from network.\");\n                } else {\n                    logs.push(\"Unable to get a response from the network.\");\n                }\n            }\n        } else {\n            if (true) {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n            }\n        }\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.m.strategyStart(this.constructor.name, request));\n            for (const log of logs){\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(log);\n            }\n            _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.m.printFinalResponse(response);\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n        }\n        if (!response) {\n            throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"no-response\", {\n                url: request.url,\n                error\n            });\n        }\n        return response;\n    }\n}\n\nclass CacheOnly extends _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.S {\n    async _handle(request, handler) {\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: this.constructor.name,\n                funcName: \"makeRequest\",\n                paramName: \"request\"\n            });\n        }\n        const response = await handler.cacheMatch(request);\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.m.strategyStart(this.constructor.name, request));\n            if (response) {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(`Found a cached response in the '${this.cacheName}' cache.`);\n                _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.m.printFinalResponse(response);\n            } else {\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(`No response found in the '${this.cacheName}' cache.`);\n            }\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n        }\n        if (!response) {\n            throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"no-response\", {\n                url: request.url\n            });\n        }\n        return response;\n    }\n}\n\nclass StaleWhileRevalidate extends _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.S {\n    constructor(options = {}){\n        super(options);\n        if (!this.plugins.some((p)=>\"cacheWillUpdate\" in p)) {\n            this.plugins.unshift(_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.l);\n        }\n    }\n    async _handle(request, handler) {\n        const logs = [];\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.f.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: this.constructor.name,\n                funcName: \"handle\",\n                paramName: \"request\"\n            });\n        }\n        const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(()=>{});\n        void handler.waitUntil(fetchAndCachePromise);\n        let response = await handler.cacheMatch(request);\n        let error;\n        if (response) {\n            if (true) {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache. Will update with the network response in the background.`);\n            }\n        } else {\n            if (true) {\n                logs.push(`No response found in the '${this.cacheName}' cache. Will wait for the network response.`);\n            }\n            try {\n                response = await fetchAndCachePromise;\n            } catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n        }\n        if (true) {\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupCollapsed(_chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.m.strategyStart(this.constructor.name, request));\n            for (const log of logs){\n                _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.log(log);\n            }\n            _chunks_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_0__.m.printFinalResponse(response);\n            _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.l.groupEnd();\n        }\n        if (!response) {\n            throw new _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.S(\"no-response\", {\n                url: request.url,\n                error\n            });\n        }\n        return response;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2Vyd2lzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9nQjtBQUN2UTtBQUNkO0FBQ2hLO0FBQ3hDOztBQUV2Qyw0QkFBNEIsNkRBQUs7QUFDakM7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBLHNDQUFzQyxpRUFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQXFDO0FBQ3JELGdCQUFnQixtREFBTSw4Q0FBOEMsdURBQWMsY0FBYztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsb0JBQW9CLElBQXFDO0FBQ3pELG9CQUFvQixtREFBTSxxQkFBcUIsdURBQWMsV0FBVztBQUN4RTtBQUNBLGNBQWM7QUFDZDtBQUNBLG9CQUFvQixJQUFxQztBQUN6RCxvQkFBb0IsbURBQU0scUJBQXFCLHVEQUFjLFdBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pELFlBQVksbURBQU0sMERBQTBEO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUIsd0JBQXdCLDZEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVksNkRBQUs7QUFDakIsWUFBWSw2REFBSztBQUNqQjtBQUNBO0FBQ0E7QUFD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QUFDQSxnQkFBZ0IsSUFBcUM7QUFDckQsNkRBQTZELGVBQWU7QUFDNUU7QUFDQSxVQUFVO0FBQ1YsZ0JBQWdCLElBQXFDO0FBQ3JELHVEQUF1RCxlQUFlO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLG1EQUFNLGdCQUFnQiw2REFBUTtBQUMxQztBQUNBLGdCQUFnQixtREFBTTtBQUN0QjtBQUNBLFlBQVksNkRBQVE7QUFDcEIsWUFBWSxtREFBTTtBQUNsQjtBQUNBO0FBQ0Esc0JBQXNCLG1EQUFZO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRXlpQiIsInNvdXJjZXMiOlsiL2hvbWUvbnl4L1dvcmtzcGFjZS9Pc3VjL1ViaUNhdGUtdjIvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSIGFzIFJvdXRlLCBnIGFzIGdlbmVyYXRlVVJMVmFyaWF0aW9ucywgQiBhcyBCYWNrZ3JvdW5kU3luY1BsdWdpbiwgTiBhcyBOZXR3b3JrRmlyc3QsIGEgYXMgTmV0d29ya09ubHksIFAgYXMgUHJlY2FjaGVTdHJhdGVneSwgZSBhcyBlbmFibGVOYXZpZ2F0aW9uUHJlbG9hZCwgcyBhcyBzZXRDYWNoZU5hbWVEZXRhaWxzLCBiIGFzIE5hdmlnYXRpb25Sb3V0ZSwgUyBhcyBTdHJhdGVneSwgZCBhcyBkaXNhYmxlRGV2TG9ncywgYyBhcyBjcmVhdGVDYWNoZUtleSwgZiBhcyBkZWZhdWx0TWV0aG9kLCBuIGFzIG5vcm1hbGl6ZUhhbmRsZXIsIHAgYXMgcGFyc2VSb3V0ZSwgaCBhcyBQcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4sIGkgYXMgcGFyYWxsZWwsIGogYXMgcHJpbnRJbnN0YWxsRGV0YWlscywgayBhcyBwcmludENsZWFudXBEZXRhaWxzLCBtIGFzIG1lc3NhZ2VzLCBsIGFzIGNhY2hlT2tBbmRPcGFxdWVQbHVnaW4gfSBmcm9tICcuL2NodW5rcy9wcmludEluc3RhbGxEZXRhaWxzLmpzJztcbmV4cG9ydCB7IHYgYXMgQmFja2dyb3VuZFN5bmNRdWV1ZSwgdyBhcyBCYWNrZ3JvdW5kU3luY1F1ZXVlU3RvcmUsIHUgYXMgUmVnRXhwUm91dGUsIHggYXMgU3RvcmFibGVSZXF1ZXN0LCB0IGFzIFN0cmF0ZWd5SGFuZGxlciwgbyBhcyBjb3B5UmVzcG9uc2UsIHEgYXMgZGlzYWJsZU5hdmlnYXRpb25QcmVsb2FkLCByIGFzIGlzTmF2aWdhdGlvblByZWxvYWRTdXBwb3J0ZWQgfSBmcm9tICcuL2NodW5rcy9wcmludEluc3RhbGxEZXRhaWxzLmpzJztcbmltcG9ydCB7IGwgYXMgbG9nZ2VyLCBnIGFzIGdldEZyaWVuZGx5VVJMLCBjIGFzIGNhY2hlTmFtZXMkMSwgYSBhcyBjbGllbnRzQ2xhaW0sIGIgYXMgY2xlYW51cE91dGRhdGVkQ2FjaGVzLCBmIGFzIGZpbmFsQXNzZXJ0RXhwb3J0cywgUyBhcyBTZXJ3aXN0RXJyb3IsIHcgYXMgd2FpdFVudGlsLCB0IGFzIHRpbWVvdXQsIHEgYXMgcXVvdGFFcnJvckNhbGxiYWNrcyB9IGZyb20gJy4vY2h1bmtzL3dhaXRVbnRpbC5qcyc7XG5pbXBvcnQgeyByIGFzIHJlc3VsdGluZ0NsaWVudEV4aXN0cyB9IGZyb20gJy4vY2h1bmtzL3Jlc3VsdGluZ0NsaWVudEV4aXN0cy5qcyc7XG5pbXBvcnQgeyBkZWxldGVEQiwgb3BlbkRCIH0gZnJvbSAnaWRiJztcblxuY2xhc3MgUHJlY2FjaGVSb3V0ZSBleHRlbmRzIFJvdXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ3aXN0LCBvcHRpb25zKXtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAoeyByZXF1ZXN0IH0pPT57XG4gICAgICAgICAgICBjb25zdCB1cmxzVG9DYWNoZUtleXMgPSBzZXJ3aXN0LmdldFVybHNUb1ByZWNhY2hlS2V5cygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwb3NzaWJsZVVSTCBvZiBnZW5lcmF0ZVVSTFZhcmlhdGlvbnMocmVxdWVzdC51cmwsIG9wdGlvbnMpKXtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHVybHNUb0NhY2hlS2V5cy5nZXQocG9zc2libGVVUkwpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlZ3JpdHkgPSBzZXJ3aXN0LmdldEludGVncml0eUZvclByZWNhY2hlS2V5KGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgUHJlY2FjaGluZyBkaWQgbm90IGZpbmQgYSBtYXRjaCBmb3IgJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBzdXBlcihtYXRjaCwgc2Vyd2lzdC5wcmVjYWNoZVN0cmF0ZWd5KTtcbiAgICB9XG59XG5cbmNvbnN0IFFVRVVFX05BTUUgPSBcInNlcndpc3QtZ29vZ2xlLWFuYWx5dGljc1wiO1xuY29uc3QgTUFYX1JFVEVOVElPTl9USU1FID0gNjAgKiA0ODtcbmNvbnN0IEdPT0dMRV9BTkFMWVRJQ1NfSE9TVCA9IFwid3d3Lmdvb2dsZS1hbmFseXRpY3MuY29tXCI7XG5jb25zdCBHVE1fSE9TVCA9IFwid3d3Lmdvb2dsZXRhZ21hbmFnZXIuY29tXCI7XG5jb25zdCBBTkFMWVRJQ1NfSlNfUEFUSCA9IFwiL2FuYWx5dGljcy5qc1wiO1xuY29uc3QgR1RBR19KU19QQVRIID0gXCIvZ3RhZy9qc1wiO1xuY29uc3QgR1RNX0pTX1BBVEggPSBcIi9ndG0uanNcIjtcbmNvbnN0IENPTExFQ1RfUEFUSFNfUkVHRVggPSAvXlxcLyhcXHcrXFwvKT9jb2xsZWN0LztcblxuY29uc3QgY3JlYXRlT25TeW5jQ2FsbGJhY2sgPSAoY29uZmlnKT0+e1xuICAgIHJldHVybiBhc3luYyAoeyBxdWV1ZSB9KT0+e1xuICAgICAgICBsZXQgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gYXdhaXQgcXVldWUuc2hpZnRSZXF1ZXN0KCkpe1xuICAgICAgICAgICAgY29uc3QgeyByZXF1ZXN0LCB0aW1lc3RhbXAgfSA9IGVudHJ5O1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHJlcXVlc3QubWV0aG9kID09PSBcIlBPU1RcIiA/IG5ldyBVUkxTZWFyY2hQYXJhbXMoYXdhaXQgcmVxdWVzdC5jbG9uZSgpLnRleHQoKSkgOiB1cmwuc2VhcmNoUGFyYW1zO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSGl0VGltZSA9IHRpbWVzdGFtcCAtIChOdW1iZXIocGFyYW1zLmdldChcInF0XCIpKSB8fCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZVRpbWUgPSBEYXRlLm5vdygpIC0gb3JpZ2luYWxIaXRUaW1lO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zZXQoXCJxdFwiLCBTdHJpbmcocXVldWVUaW1lKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5wYXJhbWV0ZXJPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiBPYmplY3Qua2V5cyhjb25maWcucGFyYW1ldGVyT3ZlcnJpZGVzKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZy5wYXJhbWV0ZXJPdmVycmlkZXNbcGFyYW1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNldChwYXJhbSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLmhpdEZpbHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5oaXRGaWx0ZXIuY2FsbChudWxsLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBmZXRjaChuZXcgUmVxdWVzdCh1cmwub3JpZ2luICsgdXJsLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHBhcmFtcy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcImNvcnNcIixcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IFwib21pdFwiLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmVxdWVzdCBmb3IgJyR7Z2V0RnJpZW5kbHlVUkwodXJsLmhyZWYpfScgaGFzIGJlZW4gcmVwbGF5ZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBxdWV1ZS51bnNoaWZ0UmVxdWVzdChlbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBSZXF1ZXN0IGZvciAnJHtnZXRGcmllbmRseVVSTCh1cmwuaHJlZil9JyBmYWlsZWQgdG8gcmVwbGF5LCBwdXR0aW5nIGl0IGJhY2sgaW4gdGhlIHF1ZXVlLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIkFsbCBHb29nbGUgQW5hbHl0aWNzIHJlcXVlc3Qgc3VjY2Vzc2Z1bGx5IHJlcGxheWVkOyBcIiArIFwidGhlIHF1ZXVlIGlzIG5vdyBlbXB0eSFcIik7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmNvbnN0IGNyZWF0ZUNvbGxlY3RSb3V0ZXMgPSAoYmdTeW5jUGx1Z2luKT0+e1xuICAgIGNvbnN0IG1hdGNoID0gKHsgdXJsIH0pPT51cmwuaG9zdG5hbWUgPT09IEdPT0dMRV9BTkFMWVRJQ1NfSE9TVCAmJiBDT0xMRUNUX1BBVEhTX1JFR0VYLnRlc3QodXJsLnBhdGhuYW1lKTtcbiAgICBjb25zdCBoYW5kbGVyID0gbmV3IE5ldHdvcmtPbmx5KHtcbiAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgYmdTeW5jUGx1Z2luXG4gICAgICAgIF1cbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgUm91dGUobWF0Y2gsIGhhbmRsZXIsIFwiR0VUXCIpLFxuICAgICAgICBuZXcgUm91dGUobWF0Y2gsIGhhbmRsZXIsIFwiUE9TVFwiKVxuICAgIF07XG59O1xuY29uc3QgY3JlYXRlQW5hbHl0aWNzSnNSb3V0ZSA9IChjYWNoZU5hbWUpPT57XG4gICAgY29uc3QgbWF0Y2ggPSAoeyB1cmwgfSk9PnVybC5ob3N0bmFtZSA9PT0gR09PR0xFX0FOQUxZVElDU19IT1NUICYmIHVybC5wYXRobmFtZSA9PT0gQU5BTFlUSUNTX0pTX1BBVEg7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBOZXR3b3JrRmlyc3Qoe1xuICAgICAgICBjYWNoZU5hbWVcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJvdXRlKG1hdGNoLCBoYW5kbGVyLCBcIkdFVFwiKTtcbn07XG5jb25zdCBjcmVhdGVHdGFnSnNSb3V0ZSA9IChjYWNoZU5hbWUpPT57XG4gICAgY29uc3QgbWF0Y2ggPSAoeyB1cmwgfSk9PnVybC5ob3N0bmFtZSA9PT0gR1RNX0hPU1QgJiYgdXJsLnBhdGhuYW1lID09PSBHVEFHX0pTX1BBVEg7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBOZXR3b3JrRmlyc3Qoe1xuICAgICAgICBjYWNoZU5hbWVcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFJvdXRlKG1hdGNoLCBoYW5kbGVyLCBcIkdFVFwiKTtcbn07XG5jb25zdCBjcmVhdGVHdG1Kc1JvdXRlID0gKGNhY2hlTmFtZSk9PntcbiAgICBjb25zdCBtYXRjaCA9ICh7IHVybCB9KT0+dXJsLmhvc3RuYW1lID09PSBHVE1fSE9TVCAmJiB1cmwucGF0aG5hbWUgPT09IEdUTV9KU19QQVRIO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgTmV0d29ya0ZpcnN0KHtcbiAgICAgICAgY2FjaGVOYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSb3V0ZShtYXRjaCwgaGFuZGxlciwgXCJHRVRcIik7XG59O1xuY29uc3QgaW5pdGlhbGl6ZUdvb2dsZUFuYWx5dGljcyA9ICh7IHNlcndpc3QsIGNhY2hlTmFtZSwgLi4ub3B0aW9ucyB9KT0+e1xuICAgIGNvbnN0IHJlc29sdmVkQ2FjaGVOYW1lID0gY2FjaGVOYW1lcyQxLmdldEdvb2dsZUFuYWx5dGljc05hbWUoY2FjaGVOYW1lKTtcbiAgICBjb25zdCBiZ1N5bmNQbHVnaW4gPSBuZXcgQmFja2dyb3VuZFN5bmNQbHVnaW4oUVVFVUVfTkFNRSwge1xuICAgICAgICBtYXhSZXRlbnRpb25UaW1lOiBNQVhfUkVURU5USU9OX1RJTUUsXG4gICAgICAgIG9uU3luYzogY3JlYXRlT25TeW5jQ2FsbGJhY2sob3B0aW9ucylcbiAgICB9KTtcbiAgICBjb25zdCByb3V0ZXMgPSBbXG4gICAgICAgIGNyZWF0ZUd0bUpzUm91dGUocmVzb2x2ZWRDYWNoZU5hbWUpLFxuICAgICAgICBjcmVhdGVBbmFseXRpY3NKc1JvdXRlKHJlc29sdmVkQ2FjaGVOYW1lKSxcbiAgICAgICAgY3JlYXRlR3RhZ0pzUm91dGUocmVzb2x2ZWRDYWNoZU5hbWUpLFxuICAgICAgICAuLi5jcmVhdGVDb2xsZWN0Um91dGVzKGJnU3luY1BsdWdpbilcbiAgICBdO1xuICAgIGZvciAoY29uc3Qgcm91dGUgb2Ygcm91dGVzKXtcbiAgICAgICAgc2Vyd2lzdC5yZWdpc3RlclJvdXRlKHJvdXRlKTtcbiAgICB9XG59O1xuXG5jbGFzcyBQcmVjYWNoZUZhbGxiYWNrUGx1Z2luIHtcbiAgICBfZmFsbGJhY2tVcmxzO1xuICAgIF9zZXJ3aXN0O1xuICAgIGNvbnN0cnVjdG9yKHsgZmFsbGJhY2tVcmxzLCBzZXJ3aXN0IH0pe1xuICAgICAgICB0aGlzLl9mYWxsYmFja1VybHMgPSBmYWxsYmFja1VybHM7XG4gICAgICAgIHRoaXMuX3Nlcndpc3QgPSBzZXJ3aXN0O1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVyRGlkRXJyb3IocGFyYW0pIHtcbiAgICAgICAgZm9yIChjb25zdCBmYWxsYmFjayBvZiB0aGlzLl9mYWxsYmFja1VybHMpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9zZXJ3aXN0Lm1hdGNoUHJlY2FjaGUoZmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChmYWxsYmFja1Jlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmYWxsYmFjay5tYXRjaGVyKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9zZXJ3aXN0Lm1hdGNoUHJlY2FjaGUoZmFsbGJhY2sudXJsKTtcbiAgICAgICAgICAgICAgICBpZiAoZmFsbGJhY2tSZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFja1Jlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuY2xhc3MgUHJlY2FjaGVDYWNoZUtleVBsdWdpbiB7XG4gICAgX3ByZWNhY2hlQ29udHJvbGxlcjtcbiAgICBjb25zdHJ1Y3Rvcih7IHByZWNhY2hlQ29udHJvbGxlciB9KXtcbiAgICAgICAgdGhpcy5fcHJlY2FjaGVDb250cm9sbGVyID0gcHJlY2FjaGVDb250cm9sbGVyO1xuICAgIH1cbiAgICBjYWNoZUtleVdpbGxCZVVzZWQgPSBhc3luYyAoeyByZXF1ZXN0LCBwYXJhbXMgfSk9PntcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBwYXJhbXM/LmNhY2hlS2V5IHx8IHRoaXMuX3ByZWNhY2hlQ29udHJvbGxlci5nZXRQcmVjYWNoZUtleUZvclVybChyZXF1ZXN0LnVybCk7XG4gICAgICAgIHJldHVybiBjYWNoZUtleSA/IG5ldyBSZXF1ZXN0KGNhY2hlS2V5LCB7XG4gICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnNcbiAgICAgICAgfSkgOiByZXF1ZXN0O1xuICAgIH07XG59XG5cbmNvbnN0IHBhcnNlUHJlY2FjaGVPcHRpb25zID0gKHNlcndpc3QsIHByZWNhY2hlT3B0aW9ucyA9IHt9KT0+e1xuICAgIGNvbnN0IHsgY2FjaGVOYW1lOiBwcmVjYWNoZUNhY2hlTmFtZSwgcGx1Z2luczogcHJlY2FjaGVQbHVnaW5zID0gW10sIGZldGNoT3B0aW9uczogcHJlY2FjaGVGZXRjaE9wdGlvbnMsIG1hdGNoT3B0aW9uczogcHJlY2FjaGVNYXRjaE9wdGlvbnMsIGZhbGxiYWNrVG9OZXR3b3JrOiBwcmVjYWNoZUZhbGxiYWNrVG9OZXR3b3JrLCBkaXJlY3RvcnlJbmRleDogcHJlY2FjaGVEaXJlY3RvcnlJbmRleCwgaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nOiBwcmVjYWNoZUlnbm9yZVVybHMsIGNsZWFuVVJMczogcHJlY2FjaGVDbGVhblVybHMsIHVybE1hbmlwdWxhdGlvbjogcHJlY2FjaGVVcmxNYW5pcHVsYXRpb24sIGNsZWFudXBPdXRkYXRlZENhY2hlcywgY29uY3VycmVuY3kgPSAxMCwgbmF2aWdhdGVGYWxsYmFjaywgbmF2aWdhdGVGYWxsYmFja0FsbG93bGlzdCwgbmF2aWdhdGVGYWxsYmFja0RlbnlsaXN0IH0gPSBwcmVjYWNoZU9wdGlvbnMgPz8ge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlY2FjaGVTdHJhdGVneU9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNhY2hlTmFtZTogY2FjaGVOYW1lcyQxLmdldFByZWNhY2hlTmFtZShwcmVjYWNoZUNhY2hlTmFtZSksXG4gICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgLi4ucHJlY2FjaGVQbHVnaW5zLFxuICAgICAgICAgICAgICAgIG5ldyBQcmVjYWNoZUNhY2hlS2V5UGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2FjaGVDb250cm9sbGVyOiBzZXJ3aXN0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBmZXRjaE9wdGlvbnM6IHByZWNhY2hlRmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgbWF0Y2hPcHRpb25zOiBwcmVjYWNoZU1hdGNoT3B0aW9ucyxcbiAgICAgICAgICAgIGZhbGxiYWNrVG9OZXR3b3JrOiBwcmVjYWNoZUZhbGxiYWNrVG9OZXR3b3JrXG4gICAgICAgIH0sXG4gICAgICAgIHByZWNhY2hlUm91dGVPcHRpb25zOiB7XG4gICAgICAgICAgICBkaXJlY3RvcnlJbmRleDogcHJlY2FjaGVEaXJlY3RvcnlJbmRleCxcbiAgICAgICAgICAgIGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZzogcHJlY2FjaGVJZ25vcmVVcmxzLFxuICAgICAgICAgICAgY2xlYW5VUkxzOiBwcmVjYWNoZUNsZWFuVXJscyxcbiAgICAgICAgICAgIHVybE1hbmlwdWxhdGlvbjogcHJlY2FjaGVVcmxNYW5pcHVsYXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgcHJlY2FjaGVNaXNjT3B0aW9uczoge1xuICAgICAgICAgICAgY2xlYW51cE91dGRhdGVkQ2FjaGVzLFxuICAgICAgICAgICAgY29uY3VycmVuY3ksXG4gICAgICAgICAgICBuYXZpZ2F0ZUZhbGxiYWNrLFxuICAgICAgICAgICAgbmF2aWdhdGVGYWxsYmFja0FsbG93bGlzdCxcbiAgICAgICAgICAgIG5hdmlnYXRlRmFsbGJhY2tEZW55bGlzdFxuICAgICAgICB9XG4gICAgfTtcbn07XG5cbmNsYXNzIFNlcndpc3Qge1xuICAgIF91cmxzVG9DYWNoZUtleXMgPSBuZXcgTWFwKCk7XG4gICAgX3VybHNUb0NhY2hlTW9kZXMgPSBuZXcgTWFwKCk7XG4gICAgX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMgPSBuZXcgTWFwKCk7XG4gICAgX2NvbmN1cnJlbnRQcmVjYWNoaW5nO1xuICAgIF9wcmVjYWNoZVN0cmF0ZWd5O1xuICAgIF9yb3V0ZXM7XG4gICAgX2RlZmF1bHRIYW5kbGVyTWFwO1xuICAgIF9jYXRjaEhhbmRsZXI7XG4gICAgY29uc3RydWN0b3IoeyBwcmVjYWNoZUVudHJpZXMsIHByZWNhY2hlT3B0aW9ucywgc2tpcFdhaXRpbmcgPSBmYWxzZSwgaW1wb3J0U2NyaXB0cywgbmF2aWdhdGlvblByZWxvYWQgPSBmYWxzZSwgY2FjaGVJZCwgY2xpZW50c0NsYWltOiBjbGllbnRzQ2xhaW0kMSA9IGZhbHNlLCBydW50aW1lQ2FjaGluZywgb2ZmbGluZUFuYWx5dGljc0NvbmZpZywgZGlzYWJsZURldkxvZ3M6IGRpc2FibGVEZXZMb2dzJDEgPSBmYWxzZSwgZmFsbGJhY2tzIH0gPSB7fSl7XG4gICAgICAgIGNvbnN0IHsgcHJlY2FjaGVTdHJhdGVneU9wdGlvbnMsIHByZWNhY2hlUm91dGVPcHRpb25zLCBwcmVjYWNoZU1pc2NPcHRpb25zIH0gPSBwYXJzZVByZWNhY2hlT3B0aW9ucyh0aGlzLCBwcmVjYWNoZU9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9jb25jdXJyZW50UHJlY2FjaGluZyA9IHByZWNhY2hlTWlzY09wdGlvbnMuY29uY3VycmVuY3k7XG4gICAgICAgIHRoaXMuX3ByZWNhY2hlU3RyYXRlZ3kgPSBuZXcgUHJlY2FjaGVTdHJhdGVneShwcmVjYWNoZVN0cmF0ZWd5T3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3JvdXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5zdGFsbCA9IHRoaXMuaGFuZGxlSW5zdGFsbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUFjdGl2YXRlID0gdGhpcy5oYW5kbGVBY3RpdmF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUZldGNoID0gdGhpcy5oYW5kbGVGZXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUNhY2hlID0gdGhpcy5oYW5kbGVDYWNoZS5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAoISFpbXBvcnRTY3JpcHRzICYmIGltcG9ydFNjcmlwdHMubGVuZ3RoID4gMCkgc2VsZi5pbXBvcnRTY3JpcHRzKC4uLmltcG9ydFNjcmlwdHMpO1xuICAgICAgICBpZiAobmF2aWdhdGlvblByZWxvYWQpIGVuYWJsZU5hdmlnYXRpb25QcmVsb2FkKCk7XG4gICAgICAgIGlmIChjYWNoZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNldENhY2hlTmFtZURldGFpbHMoe1xuICAgICAgICAgICAgICAgIHByZWZpeDogY2FjaGVJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBXYWl0aW5nKSB7XG4gICAgICAgICAgICBzZWxmLnNraXBXYWl0aW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCk9PntcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnR5cGUgPT09IFwiU0tJUF9XQUlUSU5HXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5za2lwV2FpdGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRzQ2xhaW0kMSkgY2xpZW50c0NsYWltKCk7XG4gICAgICAgIGlmICghIXByZWNhY2hlRW50cmllcyAmJiBwcmVjYWNoZUVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hZGRUb1ByZWNhY2hlTGlzdChwcmVjYWNoZUVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVjYWNoZU1pc2NPcHRpb25zLmNsZWFudXBPdXRkYXRlZENhY2hlcykge1xuICAgICAgICAgICAgY2xlYW51cE91dGRhdGVkQ2FjaGVzKHByZWNhY2hlU3RyYXRlZ3lPcHRpb25zLmNhY2hlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlclJvdXRlKG5ldyBQcmVjYWNoZVJvdXRlKHRoaXMsIHByZWNhY2hlUm91dGVPcHRpb25zKSk7XG4gICAgICAgIGlmIChwcmVjYWNoZU1pc2NPcHRpb25zLm5hdmlnYXRlRmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJSb3V0ZShuZXcgTmF2aWdhdGlvblJvdXRlKHRoaXMuY3JlYXRlSGFuZGxlckJvdW5kVG9VcmwocHJlY2FjaGVNaXNjT3B0aW9ucy5uYXZpZ2F0ZUZhbGxiYWNrKSwge1xuICAgICAgICAgICAgICAgIGFsbG93bGlzdDogcHJlY2FjaGVNaXNjT3B0aW9ucy5uYXZpZ2F0ZUZhbGxiYWNrQWxsb3dsaXN0LFxuICAgICAgICAgICAgICAgIGRlbnlsaXN0OiBwcmVjYWNoZU1pc2NPcHRpb25zLm5hdmlnYXRlRmFsbGJhY2tEZW55bGlzdFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZsaW5lQW5hbHl0aWNzQ29uZmlnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2ZmbGluZUFuYWx5dGljc0NvbmZpZyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBvZmZsaW5lQW5hbHl0aWNzQ29uZmlnICYmIGluaXRpYWxpemVHb29nbGVBbmFseXRpY3Moe1xuICAgICAgICAgICAgICAgICAgICBzZXJ3aXN0OiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVHb29nbGVBbmFseXRpY3Moe1xuICAgICAgICAgICAgICAgICAgICAuLi5vZmZsaW5lQW5hbHl0aWNzQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICBzZXJ3aXN0OiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bnRpbWVDYWNoaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChmYWxsYmFja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrUGx1Z2luID0gbmV3IFByZWNhY2hlRmFsbGJhY2tQbHVnaW4oe1xuICAgICAgICAgICAgICAgICAgICBmYWxsYmFja1VybHM6IGZhbGxiYWNrcy5lbnRyaWVzLFxuICAgICAgICAgICAgICAgICAgICBzZXJ3aXN0OiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcnVudGltZUNhY2hpbmcuZm9yRWFjaCgoY2FjaGVFbnRyeSk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkuaGFuZGxlciBpbnN0YW5jZW9mIFN0cmF0ZWd5ICYmICFjYWNoZUVudHJ5LmhhbmRsZXIucGx1Z2lucy5zb21lKChwbHVnaW4pPT5cImhhbmRsZXJEaWRFcnJvclwiIGluIHBsdWdpbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlRW50cnkuaGFuZGxlci5wbHVnaW5zLnB1c2goZmFsbGJhY2tQbHVnaW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHJ1bnRpbWVDYWNoaW5nKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ2FwdHVyZShlbnRyeS5tYXRjaGVyLCBlbnRyeS5oYW5kbGVyLCBlbnRyeS5tZXRob2QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNhYmxlRGV2TG9ncyQxKSBkaXNhYmxlRGV2TG9ncygpO1xuICAgIH1cbiAgICBnZXQgcHJlY2FjaGVTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWNhY2hlU3RyYXRlZ3k7XG4gICAgfVxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3V0ZXM7XG4gICAgfVxuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnN0YWxsXCIsIHRoaXMuaGFuZGxlSW5zdGFsbCk7XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImFjdGl2YXRlXCIsIHRoaXMuaGFuZGxlQWN0aXZhdGUpO1xuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJmZXRjaFwiLCB0aGlzLmhhbmRsZUZldGNoKTtcbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLmhhbmRsZUNhY2hlKTtcbiAgICB9XG4gICAgYWRkVG9QcmVjYWNoZUxpc3QoZW50cmllcykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNBcnJheShlbnRyaWVzLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJhZGRUb0NhY2hlTGlzdFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJlbnRyaWVzXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybHNUb1dhcm5BYm91dCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHVybHNUb1dhcm5BYm91dC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkgJiYgIWVudHJ5LmludGVncml0eSAmJiBlbnRyeS5yZXZpc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdXJsc1RvV2FybkFib3V0LnB1c2goZW50cnkudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGVLZXksIHVybCB9ID0gY3JlYXRlQ2FjaGVLZXkoZW50cnkpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVNb2RlID0gdHlwZW9mIGVudHJ5ICE9PSBcInN0cmluZ1wiICYmIGVudHJ5LnJldmlzaW9uID8gXCJyZWxvYWRcIiA6IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VybHNUb0NhY2hlS2V5cy5oYXModXJsKSAmJiB0aGlzLl91cmxzVG9DYWNoZUtleXMuZ2V0KHVybCkgIT09IGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImFkZC10by1jYWNoZS1saXN0LWNvbmZsaWN0aW5nLWVudHJpZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVudHJ5OiB0aGlzLl91cmxzVG9DYWNoZUtleXMuZ2V0KHVybCksXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZEVudHJ5OiBjYWNoZUtleVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIiAmJiBlbnRyeS5pbnRlZ3JpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVLZXlzVG9JbnRlZ3JpdGllcy5oYXMoY2FjaGVLZXkpICYmIHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuZ2V0KGNhY2hlS2V5KSAhPT0gZW50cnkuaW50ZWdyaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJhZGQtdG8tY2FjaGUtbGlzdC1jb25mbGljdGluZy1pbnRlZ3JpdGllc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuc2V0KGNhY2hlS2V5LCBlbnRyeS5pbnRlZ3JpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXJsc1RvQ2FjaGVLZXlzLnNldCh1cmwsIGNhY2hlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuX3VybHNUb0NhY2hlTW9kZXMuc2V0KHVybCwgY2FjaGVNb2RlKTtcbiAgICAgICAgICAgIGlmICh1cmxzVG9XYXJuQWJvdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gYFNlcndpc3QgaXMgcHJlY2FjaGluZyBVUkxzIHdpdGhvdXQgcmV2aXNpb24gaW5mbzogJHt1cmxzVG9XYXJuQWJvdXQuam9pbihcIiwgXCIpfVxcblRoaXMgaXMgZ2VuZXJhbGx5IE5PVCBzYWZlLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vYml0Lmx5L3diLXByZWNhY2hlYDtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4od2FybmluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVJbnN0YWxsKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB3YWl0VW50aWwoZXZlbnQsIGFzeW5jICgpPT57XG4gICAgICAgICAgICBjb25zdCBpbnN0YWxsUmVwb3J0UGx1Z2luID0gbmV3IFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbigpO1xuICAgICAgICAgICAgdGhpcy5wcmVjYWNoZVN0cmF0ZWd5LnBsdWdpbnMucHVzaChpbnN0YWxsUmVwb3J0UGx1Z2luKTtcbiAgICAgICAgICAgIGF3YWl0IHBhcmFsbGVsKHRoaXMuX2NvbmN1cnJlbnRQcmVjYWNoaW5nLCBBcnJheS5mcm9tKHRoaXMuX3VybHNUb0NhY2hlS2V5cy5lbnRyaWVzKCkpLCBhc3luYyAoW3VybCwgY2FjaGVLZXldKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVncml0eSA9IHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZU1vZGUgPSB0aGlzLl91cmxzVG9DYWNoZU1vZGVzLmdldCh1cmwpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyaXR5LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGVNb2RlLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5wcmVjYWNoZVN0cmF0ZWd5LmhhbmRsZUFsbCh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICB1cmw6IG5ldyBVUkwocmVxdWVzdC51cmwpLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgdXBkYXRlZFVSTHMsIG5vdFVwZGF0ZWRVUkxzIH0gPSBpbnN0YWxsUmVwb3J0UGx1Z2luO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHByaW50SW5zdGFsbERldGFpbHModXBkYXRlZFVSTHMsIG5vdFVwZGF0ZWRVUkxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZFVSTHMsXG4gICAgICAgICAgICAgICAgbm90VXBkYXRlZFVSTHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVBY3RpdmF0ZShldmVudCkge1xuICAgICAgICByZXR1cm4gd2FpdFVudGlsKGV2ZW50LCBhc3luYyAoKT0+e1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKHRoaXMucHJlY2FjaGVTdHJhdGVneS5jYWNoZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudGx5Q2FjaGVkUmVxdWVzdHMgPSBhd2FpdCBjYWNoZS5rZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZENhY2hlS2V5cyA9IG5ldyBTZXQodGhpcy5fdXJsc1RvQ2FjaGVLZXlzLnZhbHVlcygpKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZWRDYWNoZVJlcXVlc3RzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgY3VycmVudGx5Q2FjaGVkUmVxdWVzdHMpe1xuICAgICAgICAgICAgICAgIGlmICghZXhwZWN0ZWRDYWNoZUtleXMuaGFzKHJlcXVlc3QudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWNoZS5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRDYWNoZVJlcXVlc3RzLnB1c2gocmVxdWVzdC51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwcmludENsZWFudXBEZXRhaWxzKGRlbGV0ZWRDYWNoZVJlcXVlc3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlZENhY2hlUmVxdWVzdHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVGZXRjaChldmVudCkge1xuICAgICAgICBjb25zdCB7IHJlcXVlc3QgfSA9IGV2ZW50O1xuICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLmhhbmRsZVJlcXVlc3Qoe1xuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgICAgICBldmVudC5yZXNwb25kV2l0aChyZXNwb25zZVByb21pc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNhY2hlKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5kYXRhICYmIGV2ZW50LmRhdGEudHlwZSA9PT0gXCJDQUNIRV9VUkxTXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJDYWNoaW5nIFVSTHMgZnJvbSB0aGUgd2luZG93XCIsIHBheWxvYWQudXJsc1RvQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdFByb21pc2VzID0gUHJvbWlzZS5hbGwocGF5bG9hZC51cmxzVG9DYWNoZS5tYXAoKGVudHJ5KT0+e1xuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGVudHJ5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoLi4uZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGV2ZW50LndhaXRVbnRpbChyZXF1ZXN0UHJvbWlzZXMpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnBvcnRzPy5bMF0pIHtcbiAgICAgICAgICAgICAgICB2b2lkIHJlcXVlc3RQcm9taXNlcy50aGVuKCgpPT5ldmVudC5wb3J0c1swXS5wb3N0TWVzc2FnZSh0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RGVmYXVsdEhhbmRsZXIoaGFuZGxlciwgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5zZXQobWV0aG9kLCBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpKTtcbiAgICB9XG4gICAgc2V0Q2F0Y2hIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fY2F0Y2hIYW5kbGVyID0gbm9ybWFsaXplSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDYXB0dXJlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCkge1xuICAgICAgICBjb25zdCByb3V0ZSA9IHBhcnNlUm91dGUoY2FwdHVyZSwgaGFuZGxlciwgbWV0aG9kKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclJvdXRlKHJvdXRlKTtcbiAgICAgICAgcmV0dXJuIHJvdXRlO1xuICAgIH1cbiAgICByZWdpc3RlclJvdXRlKHJvdXRlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUocm91dGUsIFwib2JqZWN0XCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiU2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInJlZ2lzdGVyUm91dGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicm91dGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaGFzTWV0aG9kKHJvdXRlLCBcIm1hdGNoXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiU2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInJlZ2lzdGVyUm91dGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicm91dGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKHJvdXRlLmhhbmRsZXIsIFwib2JqZWN0XCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiU2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInJlZ2lzdGVyUm91dGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicm91dGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaGFzTWV0aG9kKHJvdXRlLmhhbmRsZXIsIFwiaGFuZGxlXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiU2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInJlZ2lzdGVyUm91dGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicm91dGUuaGFuZGxlclwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUocm91dGUubWV0aG9kLCBcInN0cmluZ1wiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJyZWdpc3RlclJvdXRlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJvdXRlLm1ldGhvZFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3JvdXRlcy5oYXMocm91dGUubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpcy5fcm91dGVzLnNldChyb3V0ZS5tZXRob2QsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3V0ZXMuZ2V0KHJvdXRlLm1ldGhvZCkucHVzaChyb3V0ZSk7XG4gICAgfVxuICAgIHVucmVnaXN0ZXJSb3V0ZShyb3V0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3JvdXRlcy5oYXMocm91dGUubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcInVucmVnaXN0ZXItcm91dGUtYnV0LW5vdC1mb3VuZC13aXRoLW1ldGhvZFwiLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiByb3V0ZS5tZXRob2RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlSW5kZXggPSB0aGlzLl9yb3V0ZXMuZ2V0KHJvdXRlLm1ldGhvZCkuaW5kZXhPZihyb3V0ZSk7XG4gICAgICAgIGlmIChyb3V0ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdXRlcy5nZXQocm91dGUubWV0aG9kKS5zcGxpY2Uocm91dGVJbmRleCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwidW5yZWdpc3Rlci1yb3V0ZS1yb3V0ZS1ub3QtcmVnaXN0ZXJlZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRVcmxzVG9QcmVjYWNoZUtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmxzVG9DYWNoZUtleXM7XG4gICAgfVxuICAgIGdldFByZWNhY2hlZFVybHMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLl91cmxzVG9DYWNoZUtleXMua2V5cygpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGdldFByZWNhY2hlS2V5Rm9yVXJsKHVybCkge1xuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmxzVG9DYWNoZUtleXMuZ2V0KHVybE9iamVjdC5ocmVmKTtcbiAgICB9XG4gICAgZ2V0SW50ZWdyaXR5Rm9yUHJlY2FjaGVLZXkoY2FjaGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICB9XG4gICAgYXN5bmMgbWF0Y2hQcmVjYWNoZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gcmVxdWVzdC51cmwgOiByZXF1ZXN0O1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0UHJlY2FjaGVLZXlGb3JVcmwodXJsKTtcbiAgICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHNlbGYuY2FjaGVzLm9wZW4odGhpcy5wcmVjYWNoZVN0cmF0ZWd5LmNhY2hlTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUubWF0Y2goY2FjaGVLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNyZWF0ZUhhbmRsZXJCb3VuZFRvVXJsKHVybCkge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0UHJlY2FjaGVLZXlGb3JVcmwodXJsKTtcbiAgICAgICAgaWYgKCFjYWNoZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcIm5vbi1wcmVjYWNoZWQtdXJsXCIsIHtcbiAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAob3B0aW9ucyk9PntcbiAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCk7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLnBhcmFtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZWNhY2hlU3RyYXRlZ3kuaGFuZGxlKG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBoYW5kbGVSZXF1ZXN0KHsgcmVxdWVzdCwgZXZlbnQgfSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJoYW5kbGVSZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm9wdGlvbnMucmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKCF1cmwucHJvdG9jb2wuc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJSb3V0ZXIgb25seSBzdXBwb3J0cyBVUkxzIHRoYXQgc3RhcnQgd2l0aCAnaHR0cCcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhbWVPcmlnaW4gPSB1cmwub3JpZ2luID09PSBsb2NhdGlvbi5vcmlnaW47XG4gICAgICAgIGNvbnN0IHsgcGFyYW1zLCByb3V0ZSB9ID0gdGhpcy5maW5kTWF0Y2hpbmdSb3V0ZSh7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzYW1lT3JpZ2luLFxuICAgICAgICAgICAgdXJsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaGFuZGxlciA9IHJvdXRlPy5oYW5kbGVyO1xuICAgICAgICBjb25zdCBkZWJ1Z01lc3NhZ2VzID0gW107XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZGVidWdNZXNzYWdlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgXCJGb3VuZCBhIHJvdXRlIHRvIGhhbmRsZSB0aGlzIHJlcXVlc3Q6XCIsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z01lc3NhZ2VzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgYFBhc3NpbmcgdGhlIGZvbGxvd2luZyBwYXJhbXMgdG8gdGhlIHJvdXRlJ3MgaGFuZGxlcjpgLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgaWYgKCFoYW5kbGVyICYmIHRoaXMuX2RlZmF1bHRIYW5kbGVyTWFwLmhhcyhtZXRob2QpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZGVidWdNZXNzYWdlcy5wdXNoKGBGYWlsZWQgdG8gZmluZCBhIG1hdGNoaW5nIHJvdXRlLiBGYWxsaW5nIGJhY2sgdG8gdGhlIGRlZmF1bHQgaGFuZGxlciBmb3IgJHttZXRob2R9LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlciA9IHRoaXMuX2RlZmF1bHRIYW5kbGVyTWFwLmdldChtZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTm8gcm91dGUgZm91bmQgZm9yOiAke2dldEZyaWVuZGx5VVJMKHVybCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBSb3V0ZXIgaXMgcmVzcG9uZGluZyB0bzogJHtnZXRGcmllbmRseVVSTCh1cmwpfWApO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtc2cgb2YgZGVidWdNZXNzYWdlcyl7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKC4uLm1zZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZVByb21pc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UgPSBoYW5kbGVyLmhhbmRsZSh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhdGNoSGFuZGxlciA9IHJvdXRlPy5jYXRjaEhhbmRsZXI7XG4gICAgICAgIGlmIChyZXNwb25zZVByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlICYmICh0aGlzLl9jYXRjaEhhbmRsZXIgfHwgY2F0Y2hIYW5kbGVyKSkge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gcmVzcG9uc2VQcm9taXNlLmNhdGNoKGFzeW5jIChlcnIpPT57XG4gICAgICAgICAgICAgICAgaWYgKGNhdGNoSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYEVycm9yIHRocm93biB3aGVuIHJlc3BvbmRpbmcgdG86ICAke2dldEZyaWVuZGx5VVJMKHVybCl9LiBGYWxsaW5nIGJhY2sgdG8gcm91dGUncyBDYXRjaCBIYW5kbGVyLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgdGhyb3duIGJ5OlwiLCByb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgY2F0Y2hIYW5kbGVyLmhhbmRsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoY2F0Y2hFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXRjaEVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gY2F0Y2hFcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhdGNoSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYEVycm9yIHRocm93biB3aGVuIHJlc3BvbmRpbmcgdG86ICAke2dldEZyaWVuZGx5VVJMKHVybCl9LiBGYWxsaW5nIGJhY2sgdG8gZ2xvYmFsIENhdGNoIEhhbmRsZXIuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciB0aHJvd24gYnk6XCIsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhdGNoSGFuZGxlci5oYW5kbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuICAgIH1cbiAgICBmaW5kTWF0Y2hpbmdSb3V0ZSh7IHVybCwgc2FtZU9yaWdpbiwgcmVxdWVzdCwgZXZlbnQgfSkge1xuICAgICAgICBjb25zdCByb3V0ZXMgPSB0aGlzLl9yb3V0ZXMuZ2V0KHJlcXVlc3QubWV0aG9kKSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3V0ZSBvZiByb3V0ZXMpe1xuICAgICAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoUmVzdWx0ID0gcm91dGUubWF0Y2goe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBzYW1lT3JpZ2luLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgV2hpbGUgcm91dGluZyAke2dldEZyaWVuZGx5VVJMKHVybCl9LCBhbiBhc3luYyBtYXRjaENhbGxiYWNrIGZ1bmN0aW9uIHdhcyB1c2VkLiBQbGVhc2UgY29udmVydCB0aGUgZm9sbG93aW5nIHJvdXRlIHRvIHVzZSBhIHN5bmNocm9ub3VzIG1hdGNoQ2FsbGJhY2sgZnVuY3Rpb246YCwgcm91dGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG1hdGNoUmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFJlc3VsdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIE9iamVjdC5rZXlzKG1hdGNoUmVzdWx0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoUmVzdWx0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59XG5cbmNvbnN0IGNhY2hlTmFtZXMgPSB7XG4gICAgZ2V0IGdvb2dsZUFuYWx5dGljcyAoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZU5hbWVzJDEuZ2V0R29vZ2xlQW5hbHl0aWNzTmFtZSgpO1xuICAgIH0sXG4gICAgZ2V0IHByZWNhY2hlICgpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlTmFtZXMkMS5nZXRQcmVjYWNoZU5hbWUoKTtcbiAgICB9LFxuICAgIGdldCBwcmVmaXggKCkge1xuICAgICAgICByZXR1cm4gY2FjaGVOYW1lcyQxLmdldFByZWZpeCgpO1xuICAgIH0sXG4gICAgZ2V0IHJ1bnRpbWUgKCkge1xuICAgICAgICByZXR1cm4gY2FjaGVOYW1lcyQxLmdldFJ1bnRpbWVOYW1lKCk7XG4gICAgfSxcbiAgICBnZXQgc3VmZml4ICgpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlTmFtZXMkMS5nZXRTdWZmaXgoKTtcbiAgICB9XG59O1xuXG5jb25zdCBCUk9BRENBU1RfVVBEQVRFX01FU1NBR0VfVFlQRSA9IFwiQ0FDSEVfVVBEQVRFRFwiO1xuY29uc3QgQlJPQURDQVNUX1VQREFURV9NRVNTQUdFX01FVEEgPSBcInNlcndpc3QtYnJvYWRjYXN0LXVwZGF0ZVwiO1xuY29uc3QgQlJPQURDQVNUX1VQREFURV9ERUZBVUxUX05PVElGWSA9IHRydWU7XG5jb25zdCBCUk9BRENBU1RfVVBEQVRFX0RFRkFVTFRfSEVBREVSUyA9IFtcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJldGFnXCIsXG4gICAgXCJsYXN0LW1vZGlmaWVkXCJcbl07XG5cbmNvbnN0IHJlc3BvbnNlc0FyZVNhbWUgPSAoZmlyc3RSZXNwb25zZSwgc2Vjb25kUmVzcG9uc2UsIGhlYWRlcnNUb0NoZWNrKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKCEoZmlyc3RSZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIHNlY29uZFJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiaW52YWxpZC1yZXNwb25zZXMtYXJlLXNhbWUtYXJnc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhdExlYXN0T25lSGVhZGVyQXZhaWxhYmxlID0gaGVhZGVyc1RvQ2hlY2suc29tZSgoaGVhZGVyKT0+e1xuICAgICAgICByZXR1cm4gZmlyc3RSZXNwb25zZS5oZWFkZXJzLmhhcyhoZWFkZXIpICYmIHNlY29uZFJlc3BvbnNlLmhlYWRlcnMuaGFzKGhlYWRlcik7XG4gICAgfSk7XG4gICAgaWYgKCFhdExlYXN0T25lSGVhZGVyQXZhaWxhYmxlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiVW5hYmxlIHRvIGRldGVybWluZSB3aGVyZSB0aGUgcmVzcG9uc2UgaGFzIGJlZW4gdXBkYXRlZCBiZWNhdXNlIG5vbmUgb2YgdGhlIGhlYWRlcnMgdGhhdCB3b3VsZCBiZSBjaGVja2VkIGFyZSBwcmVzZW50LlwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkF0dGVtcHRpbmcgdG8gY29tcGFyZSB0aGUgZm9sbG93aW5nOiBcIiwgZmlyc3RSZXNwb25zZSwgc2Vjb25kUmVzcG9uc2UsIGhlYWRlcnNUb0NoZWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnNUb0NoZWNrLmV2ZXJ5KChoZWFkZXIpPT57XG4gICAgICAgIGNvbnN0IGhlYWRlclN0YXRlQ29tcGFyaXNvbiA9IGZpcnN0UmVzcG9uc2UuaGVhZGVycy5oYXMoaGVhZGVyKSA9PT0gc2Vjb25kUmVzcG9uc2UuaGVhZGVycy5oYXMoaGVhZGVyKTtcbiAgICAgICAgY29uc3QgaGVhZGVyVmFsdWVDb21wYXJpc29uID0gZmlyc3RSZXNwb25zZS5oZWFkZXJzLmdldChoZWFkZXIpID09PSBzZWNvbmRSZXNwb25zZS5oZWFkZXJzLmdldChoZWFkZXIpO1xuICAgICAgICByZXR1cm4gaGVhZGVyU3RhdGVDb21wYXJpc29uICYmIGhlYWRlclZhbHVlQ29tcGFyaXNvbjtcbiAgICB9KTtcbn07XG5cbmNvbnN0IGlzU2FmYXJpID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgZGVmYXVsdFBheWxvYWRHZW5lcmF0b3IgPSAoZGF0YSk9PntcbiAgICByZXR1cm4ge1xuICAgICAgICBjYWNoZU5hbWU6IGRhdGEuY2FjaGVOYW1lLFxuICAgICAgICB1cGRhdGVkVVJMOiBkYXRhLnJlcXVlc3QudXJsXG4gICAgfTtcbn07XG5jbGFzcyBCcm9hZGNhc3RDYWNoZVVwZGF0ZSB7XG4gICAgX2hlYWRlcnNUb0NoZWNrO1xuICAgIF9nZW5lcmF0ZVBheWxvYWQ7XG4gICAgX25vdGlmeUFsbENsaWVudHM7XG4gICAgY29uc3RydWN0b3IoeyBnZW5lcmF0ZVBheWxvYWQsIGhlYWRlcnNUb0NoZWNrLCBub3RpZnlBbGxDbGllbnRzIH0gPSB7fSl7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNUb0NoZWNrID0gaGVhZGVyc1RvQ2hlY2sgfHwgQlJPQURDQVNUX1VQREFURV9ERUZBVUxUX0hFQURFUlM7XG4gICAgICAgIHRoaXMuX2dlbmVyYXRlUGF5bG9hZCA9IGdlbmVyYXRlUGF5bG9hZCB8fCBkZWZhdWx0UGF5bG9hZEdlbmVyYXRvcjtcbiAgICAgICAgdGhpcy5fbm90aWZ5QWxsQ2xpZW50cyA9IG5vdGlmeUFsbENsaWVudHMgPz8gQlJPQURDQVNUX1VQREFURV9ERUZBVUxUX05PVElGWTtcbiAgICB9XG4gICAgYXN5bmMgbm90aWZ5SWZVcGRhdGVkKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShvcHRpb25zLmNhY2hlTmFtZSwgXCJzdHJpbmdcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCcm9hZGNhc3RDYWNoZVVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcIm5vdGlmeUlmVXBkYXRlZFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjYWNoZU5hbWVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNJbnN0YW5jZShvcHRpb25zLm5ld1Jlc3BvbnNlLCBSZXNwb25zZSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCcm9hZGNhc3RDYWNoZVVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcIm5vdGlmeUlmVXBkYXRlZFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJuZXdSZXNwb25zZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc0luc3RhbmNlKG9wdGlvbnMucmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCcm9hZGNhc3RDYWNoZVVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcIm5vdGlmeUlmVXBkYXRlZFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyZXF1ZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5vbGRSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2VzQXJlU2FtZShvcHRpb25zLm9sZFJlc3BvbnNlLCBvcHRpb25zLm5ld1Jlc3BvbnNlLCB0aGlzLl9oZWFkZXJzVG9DaGVjaykpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiTmV3ZXIgcmVzcG9uc2UgZm91bmQgKGFuZCBjYWNoZWQpIGZvcjpcIiwgb3B0aW9ucy5yZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBCUk9BRENBU1RfVVBEQVRFX01FU1NBR0VfVFlQRSxcbiAgICAgICAgICAgICAgICBtZXRhOiBCUk9BRENBU1RfVVBEQVRFX01FU1NBR0VfTUVUQSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB0aGlzLl9nZW5lcmF0ZVBheWxvYWQob3B0aW9ucylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0Lm1vZGUgPT09IFwibmF2aWdhdGVcIikge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHRpbmdDbGllbnRJZDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ldmVudCBpbnN0YW5jZW9mIEZldGNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nQ2xpZW50SWQgPSBvcHRpb25zLmV2ZW50LnJlc3VsdGluZ0NsaWVudElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRpbmdXaW4gPSBhd2FpdCByZXN1bHRpbmdDbGllbnRFeGlzdHMocmVzdWx0aW5nQ2xpZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0aW5nV2luIHx8IGlzU2FmYXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMzUwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX25vdGlmeUFsbENsaWVudHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3dzID0gYXdhaXQgc2VsZi5jbGllbnRzLm1hdGNoQWxsKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ3aW5kb3dcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgd2luIG9mIHdpbmRvd3Mpe1xuICAgICAgICAgICAgICAgICAgICB3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnQgaW5zdGFuY2VvZiBGZXRjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHNlbGYuY2xpZW50cy5nZXQob3B0aW9ucy5ldmVudC5jbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudD8ucG9zdE1lc3NhZ2UobWVzc2FnZURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQnJvYWRjYXN0VXBkYXRlUGx1Z2luIHtcbiAgICBfYnJvYWRjYXN0VXBkYXRlO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICB0aGlzLl9icm9hZGNhc3RVcGRhdGUgPSBuZXcgQnJvYWRjYXN0Q2FjaGVVcGRhdGUob3B0aW9ucyk7XG4gICAgfVxuICAgIGNhY2hlRGlkVXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgdm9pZCB0aGlzLl9icm9hZGNhc3RVcGRhdGUubm90aWZ5SWZVcGRhdGVkKG9wdGlvbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FjaGVhYmxlUmVzcG9uc2Uge1xuICAgIF9zdGF0dXNlcztcbiAgICBfaGVhZGVycztcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSl7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZy5zdGF0dXNlcyB8fCBjb25maWcuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwic3RhdHVzZXMtb3ItaGVhZGVycy1yZXF1aXJlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQ2FjaGVhYmxlUmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5zdGF0dXNlcykge1xuICAgICAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc0FycmF5KGNvbmZpZy5zdGF0dXNlcywge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkNhY2hlYWJsZVJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjb25maWcuc3RhdHVzZXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShjb25maWcuaGVhZGVycywgXCJvYmplY3RcIiwge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkNhY2hlYWJsZVJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjb25maWcuaGVhZGVyc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdHVzZXMgPSBjb25maWcuc3RhdHVzZXM7XG4gICAgICAgIGlmIChjb25maWcuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycyA9IG5ldyBIZWFkZXJzKGNvbmZpZy5oZWFkZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1Jlc3BvbnNlQ2FjaGVhYmxlKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc0luc3RhbmNlKHJlc3BvbnNlLCBSZXNwb25zZSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJDYWNoZWFibGVSZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImlzUmVzcG9uc2VDYWNoZWFibGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicmVzcG9uc2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0dXNlcykge1xuICAgICAgICAgICAgY2FjaGVhYmxlID0gdGhpcy5fc3RhdHVzZXMuaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faGVhZGVycyAmJiBjYWNoZWFibGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2hlYWRlck5hbWUsIGhlYWRlclZhbHVlXSBvZiB0aGlzLl9oZWFkZXJzLmVudHJpZXMoKSl7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KGhlYWRlck5hbWUpICE9PSBoZWFkZXJWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBUaGUgcmVxdWVzdCBmb3IgJyR7Z2V0RnJpZW5kbHlVUkwocmVzcG9uc2UudXJsKX0nIHJldHVybmVkIGEgcmVzcG9uc2UgdGhhdCBkb2VzIG5vdCBtZWV0IHRoZSBjcml0ZXJpYSBmb3IgYmVpbmcgY2FjaGVkLmApO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChcIlZpZXcgY2FjaGVhYmlsaXR5IGNyaXRlcmlhIGhlcmUuXCIpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYENhY2hlYWJsZSBzdGF0dXNlczogJHtKU09OLnN0cmluZ2lmeSh0aGlzLl9zdGF0dXNlcyl9YCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgQ2FjaGVhYmxlIGhlYWRlcnM6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5faGVhZGVycywgbnVsbCwgMil9YCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nRnJpZW5kbHlIZWFkZXJzID0ge307XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xuICAgICAgICAgICAgICAgICAgICBsb2dGcmllbmRseUhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChcIlZpZXcgcmVzcG9uc2Ugc3RhdHVzIGFuZCBoZWFkZXJzIGhlcmUuXCIpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlc3BvbnNlIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmVzcG9uc2UgaGVhZGVyczogJHtKU09OLnN0cmluZ2lmeShsb2dGcmllbmRseUhlYWRlcnMsIG51bGwsIDIpfWApO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChcIlZpZXcgZnVsbCByZXNwb25zZSBkZXRhaWxzIGhlcmUuXCIpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2cocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlYWJsZTtcbiAgICB9XG59XG5cbmNsYXNzIENhY2hlYWJsZVJlc3BvbnNlUGx1Z2luIHtcbiAgICBfY2FjaGVhYmxlUmVzcG9uc2U7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKXtcbiAgICAgICAgdGhpcy5fY2FjaGVhYmxlUmVzcG9uc2UgPSBuZXcgQ2FjaGVhYmxlUmVzcG9uc2UoY29uZmlnKTtcbiAgICB9XG4gICAgY2FjaGVXaWxsVXBkYXRlID0gYXN5bmMgKHsgcmVzcG9uc2UgfSk9PntcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlYWJsZVJlc3BvbnNlLmlzUmVzcG9uc2VDYWNoZWFibGUocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbn1cblxuY29uc3QgREJfTkFNRSA9IFwic2Vyd2lzdC1leHBpcmF0aW9uXCI7XG5jb25zdCBDQUNIRV9PQkpFQ1RfU1RPUkUgPSBcImNhY2hlLWVudHJpZXNcIjtcbmNvbnN0IG5vcm1hbGl6ZVVSTCA9ICh1bk5vcm1hbGl6ZWRVcmwpPT57XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh1bk5vcm1hbGl6ZWRVcmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgIHVybC5oYXNoID0gXCJcIjtcbiAgICByZXR1cm4gdXJsLmhyZWY7XG59O1xuY2xhc3MgQ2FjaGVUaW1lc3RhbXBzTW9kZWwge1xuICAgIF9jYWNoZU5hbWU7XG4gICAgX2RiID0gbnVsbDtcbiAgICBjb25zdHJ1Y3RvcihjYWNoZU5hbWUpe1xuICAgICAgICB0aGlzLl9jYWNoZU5hbWUgPSBjYWNoZU5hbWU7XG4gICAgfVxuICAgIF9nZXRJZCh1cmwpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuX2NhY2hlTmFtZX18JHtub3JtYWxpemVVUkwodXJsKX1gO1xuICAgIH1cbiAgICBfdXBncmFkZURiKGRiKSB7XG4gICAgICAgIGNvbnN0IG9ialN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoQ0FDSEVfT0JKRUNUX1NUT1JFLCB7XG4gICAgICAgICAgICBrZXlQYXRoOiBcImlkXCJcbiAgICAgICAgfSk7XG4gICAgICAgIG9ialN0b3JlLmNyZWF0ZUluZGV4KFwiY2FjaGVOYW1lXCIsIFwiY2FjaGVOYW1lXCIsIHtcbiAgICAgICAgICAgIHVuaXF1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIG9ialN0b3JlLmNyZWF0ZUluZGV4KFwidGltZXN0YW1wXCIsIFwidGltZXN0YW1wXCIsIHtcbiAgICAgICAgICAgIHVuaXF1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF91cGdyYWRlRGJBbmREZWxldGVPbGREYnMoZGIpIHtcbiAgICAgICAgdGhpcy5fdXBncmFkZURiKGRiKTtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlTmFtZSkge1xuICAgICAgICAgICAgdm9pZCBkZWxldGVEQih0aGlzLl9jYWNoZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNldFRpbWVzdGFtcCh1cmwsIHRpbWVzdGFtcCkge1xuICAgICAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICAgICAgY29uc3QgZW50cnkgPSB7XG4gICAgICAgICAgICBpZDogdGhpcy5fZ2V0SWQodXJsKSxcbiAgICAgICAgICAgIGNhY2hlTmFtZTogdGhpcy5fY2FjaGVOYW1lLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgdGltZXN0YW1wXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREYigpO1xuICAgICAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKENBQ0hFX09CSkVDVF9TVE9SRSwgXCJyZWFkd3JpdGVcIiwge1xuICAgICAgICAgICAgZHVyYWJpbGl0eTogXCJyZWxheGVkXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHR4LnN0b3JlLnB1dChlbnRyeSk7XG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XG4gICAgfVxuICAgIGFzeW5jIGdldFRpbWVzdGFtcCh1cmwpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgZGIuZ2V0KENBQ0hFX09CSkVDVF9TVE9SRSwgdGhpcy5fZ2V0SWQodXJsKSk7XG4gICAgICAgIHJldHVybiBlbnRyeT8udGltZXN0YW1wO1xuICAgIH1cbiAgICBhc3luYyBleHBpcmVFbnRyaWVzKG1pblRpbWVzdGFtcCwgbWF4Q291bnQpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIGxldCBjdXJzb3IgPSBhd2FpdCBkYi50cmFuc2FjdGlvbihDQUNIRV9PQkpFQ1RfU1RPUkUsIFwicmVhZHdyaXRlXCIpLnN0b3JlLmluZGV4KFwidGltZXN0YW1wXCIpLm9wZW5DdXJzb3IobnVsbCwgXCJwcmV2XCIpO1xuICAgICAgICBjb25zdCB1cmxzRGVsZXRlZCA9IFtdO1xuICAgICAgICBsZXQgZW50cmllc05vdERlbGV0ZWRDb3VudCA9IDA7XG4gICAgICAgIHdoaWxlKGN1cnNvcil7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmNhY2hlTmFtZSA9PT0gdGhpcy5fY2FjaGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pblRpbWVzdGFtcCAmJiByZXN1bHQudGltZXN0YW1wIDwgbWluVGltZXN0YW1wIHx8IG1heENvdW50ICYmIGVudHJpZXNOb3REZWxldGVkQ291bnQgPj0gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB1cmxzRGVsZXRlZC5wdXNoKHJlc3VsdC51cmwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXNOb3REZWxldGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJzb3IgPSBhd2FpdCBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsc0RlbGV0ZWQ7XG4gICAgfVxuICAgIGFzeW5jIGdldERiKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RiKSB7XG4gICAgICAgICAgICB0aGlzLl9kYiA9IGF3YWl0IG9wZW5EQihEQl9OQU1FLCAxLCB7XG4gICAgICAgICAgICAgICAgdXBncmFkZTogdGhpcy5fdXBncmFkZURiQW5kRGVsZXRlT2xkRGJzLmJpbmQodGhpcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kYjtcbiAgICB9XG59XG5cbmNsYXNzIENhY2hlRXhwaXJhdGlvbiB7XG4gICAgX2lzUnVubmluZyA9IGZhbHNlO1xuICAgIF9yZXJ1blJlcXVlc3RlZCA9IGZhbHNlO1xuICAgIF9tYXhFbnRyaWVzO1xuICAgIF9tYXhBZ2VTZWNvbmRzO1xuICAgIF9tYXRjaE9wdGlvbnM7XG4gICAgX2NhY2hlTmFtZTtcbiAgICBfdGltZXN0YW1wTW9kZWw7XG4gICAgY29uc3RydWN0b3IoY2FjaGVOYW1lLCBjb25maWcgPSB7fSl7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUoY2FjaGVOYW1lLCBcInN0cmluZ1wiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkNhY2hlRXhwaXJhdGlvblwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImNhY2hlTmFtZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZy5tYXhFbnRyaWVzIHx8IGNvbmZpZy5tYXhBZ2VTZWNvbmRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJtYXgtZW50cmllcy1vci1hZ2UtcmVxdWlyZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkNhY2hlRXhwaXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKGNvbmZpZy5tYXhFbnRyaWVzLCBcIm51bWJlclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQ2FjaGVFeHBpcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjb25maWcubWF4RW50cmllc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEFnZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKGNvbmZpZy5tYXhBZ2VTZWNvbmRzLCBcIm51bWJlclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQ2FjaGVFeHBpcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjb25maWcubWF4QWdlU2Vjb25kc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF4RW50cmllcyA9IGNvbmZpZy5tYXhFbnRyaWVzO1xuICAgICAgICB0aGlzLl9tYXhBZ2VTZWNvbmRzID0gY29uZmlnLm1heEFnZVNlY29uZHM7XG4gICAgICAgIHRoaXMuX21hdGNoT3B0aW9ucyA9IGNvbmZpZy5tYXRjaE9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2NhY2hlTmFtZSA9IGNhY2hlTmFtZTtcbiAgICAgICAgdGhpcy5fdGltZXN0YW1wTW9kZWwgPSBuZXcgQ2FjaGVUaW1lc3RhbXBzTW9kZWwoY2FjaGVOYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgZXhwaXJlRW50cmllcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgICAgICAgdGhpcy5fcmVydW5SZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1pblRpbWVzdGFtcCA9IHRoaXMuX21heEFnZVNlY29uZHMgPyBEYXRlLm5vdygpIC0gdGhpcy5fbWF4QWdlU2Vjb25kcyAqIDEwMDAgOiAwO1xuICAgICAgICBjb25zdCB1cmxzRXhwaXJlZCA9IGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmV4cGlyZUVudHJpZXMobWluVGltZXN0YW1wLCB0aGlzLl9tYXhFbnRyaWVzKTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKHRoaXMuX2NhY2hlTmFtZSk7XG4gICAgICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHNFeHBpcmVkKXtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlLmRlbGV0ZSh1cmwsIHRoaXMuX21hdGNoT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKHVybHNFeHBpcmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYEV4cGlyZWQgJHt1cmxzRXhwaXJlZC5sZW5ndGh9IGAgKyBgJHt1cmxzRXhwaXJlZC5sZW5ndGggPT09IDEgPyBcImVudHJ5XCIgOiBcImVudHJpZXNcIn0gYW5kIHJlbW92ZWQgYCArIGAke3VybHNFeHBpcmVkLmxlbmd0aCA9PT0gMSA/IFwiaXRcIiA6IFwidGhlbVwifSBmcm9tIHRoZSBgICsgYCcke3RoaXMuX2NhY2hlTmFtZX0nIGNhY2hlLmApO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYEV4cGlyZWQgdGhlIGZvbGxvd2luZyAke3VybHNFeHBpcmVkLmxlbmd0aCA9PT0gMSA/IFwiVVJMXCIgOiBcIlVSTHNcIn06YCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB1cmwgb2YgdXJsc0V4cGlyZWQpe1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGAgICAgJHt1cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJDYWNoZSBleHBpcmF0aW9uIHJhbiBhbmQgZm91bmQgbm8gZW50cmllcyB0byByZW1vdmUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcmVydW5SZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcnVuUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2b2lkIHRoaXMuZXhwaXJlRW50cmllcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVRpbWVzdGFtcCh1cmwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZSh1cmwsIFwic3RyaW5nXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQ2FjaGVFeHBpcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwidXBkYXRlVGltZXN0YW1wXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInVybFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl90aW1lc3RhbXBNb2RlbC5zZXRUaW1lc3RhbXAodXJsLCBEYXRlLm5vdygpKTtcbiAgICB9XG4gICAgYXN5bmMgaXNVUkxFeHBpcmVkKHVybCkge1xuICAgICAgICBpZiAoIXRoaXMuX21heEFnZVNlY29uZHMpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiZXhwaXJlZC10ZXN0LXdpdGhvdXQtbWF4LWFnZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6IFwiaXNVUkxFeHBpcmVkXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJtYXhBZ2VTZWNvbmRzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBhd2FpdCB0aGlzLl90aW1lc3RhbXBNb2RlbC5nZXRUaW1lc3RhbXAodXJsKTtcbiAgICAgICAgY29uc3QgZXhwaXJlT2xkZXJUaGFuID0gRGF0ZS5ub3coKSAtIHRoaXMuX21heEFnZVNlY29uZHMgKiAxMDAwO1xuICAgICAgICByZXR1cm4gdGltZXN0YW1wICE9PSB1bmRlZmluZWQgPyB0aW1lc3RhbXAgPCBleHBpcmVPbGRlclRoYW4gOiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGUoKSB7XG4gICAgICAgIHRoaXMuX3JlcnVuUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmV4cGlyZUVudHJpZXMoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICB9XG59XG5cbmNvbnN0IHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrID0gKGNhbGxiYWNrKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShjYWxsYmFjaywgXCJmdW5jdGlvblwiLCB7XG4gICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L2NvcmVcIixcbiAgICAgICAgICAgIGZ1bmNOYW1lOiBcInJlZ2lzdGVyXCIsXG4gICAgICAgICAgICBwYXJhbU5hbWU6IFwiY2FsbGJhY2tcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVvdGFFcnJvckNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIlJlZ2lzdGVyZWQgYSBjYWxsYmFjayB0byByZXNwb25kIHRvIHF1b3RhIGVycm9ycy5cIiwgY2FsbGJhY2spO1xuICAgIH1cbn07XG5cbmNsYXNzIEV4cGlyYXRpb25QbHVnaW4ge1xuICAgIF9jb25maWc7XG4gICAgX2NhY2hlRXhwaXJhdGlvbnM7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pe1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIShjb25maWcubWF4RW50cmllcyB8fCBjb25maWcubWF4QWdlU2Vjb25kcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibWF4LWVudHJpZXMtb3ItYWdlLXJlcXVpcmVkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJFeHBpcmF0aW9uUGx1Z2luXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcubWF4RW50cmllcykge1xuICAgICAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUoY29uZmlnLm1heEVudHJpZXMsIFwibnVtYmVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJFeHBpcmF0aW9uUGx1Z2luXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjb25maWcubWF4RW50cmllc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEFnZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKGNvbmZpZy5tYXhBZ2VTZWNvbmRzLCBcIm51bWJlclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiRXhwaXJhdGlvblBsdWdpblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiY29uZmlnLm1heEFnZVNlY29uZHNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXhBZ2VGcm9tKSB7XG4gICAgICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShjb25maWcubWF4QWdlRnJvbSwgXCJzdHJpbmdcIiwge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkV4cGlyYXRpb25QbHVnaW5cIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImNvbmZpZy5tYXhBZ2VGcm9tXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuX2NhY2hlRXhwaXJhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLm1heEFnZUZyb20pIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5tYXhBZ2VGcm9tID0gXCJsYXN0LWZldGNoZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLnB1cmdlT25RdW90YUVycm9yKSB7XG4gICAgICAgICAgICByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjaygoKT0+dGhpcy5kZWxldGVDYWNoZUFuZE1ldGFkYXRhKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRDYWNoZUV4cGlyYXRpb24oY2FjaGVOYW1lKSB7XG4gICAgICAgIGlmIChjYWNoZU5hbWUgPT09IGNhY2hlTmFtZXMkMS5nZXRSdW50aW1lTmFtZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiZXhwaXJlLWN1c3RvbS1jYWNoZXMtb25seVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FjaGVFeHBpcmF0aW9uID0gdGhpcy5fY2FjaGVFeHBpcmF0aW9ucy5nZXQoY2FjaGVOYW1lKTtcbiAgICAgICAgaWYgKCFjYWNoZUV4cGlyYXRpb24pIHtcbiAgICAgICAgICAgIGNhY2hlRXhwaXJhdGlvbiA9IG5ldyBDYWNoZUV4cGlyYXRpb24oY2FjaGVOYW1lLCB0aGlzLl9jb25maWcpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucy5zZXQoY2FjaGVOYW1lLCBjYWNoZUV4cGlyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZUV4cGlyYXRpb247XG4gICAgfVxuICAgIGNhY2hlZFJlc3BvbnNlV2lsbEJlVXNlZCh7IGV2ZW50LCBjYWNoZU5hbWUsIHJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlIH0pIHtcbiAgICAgICAgaWYgKCFjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNGcmVzaCA9IHRoaXMuX2lzUmVzcG9uc2VEYXRlRnJlc2goY2FjaGVkUmVzcG9uc2UpO1xuICAgICAgICBjb25zdCBjYWNoZUV4cGlyYXRpb24gPSB0aGlzLl9nZXRDYWNoZUV4cGlyYXRpb24oY2FjaGVOYW1lKTtcbiAgICAgICAgY29uc3QgaXNNYXhBZ2VGcm9tTGFzdFVzZWQgPSB0aGlzLl9jb25maWcubWF4QWdlRnJvbSA9PT0gXCJsYXN0LXVzZWRcIjtcbiAgICAgICAgY29uc3QgZG9uZSA9IChhc3luYyAoKT0+e1xuICAgICAgICAgICAgaWYgKGlzTWF4QWdlRnJvbUxhc3RVc2VkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY2FjaGVFeHBpcmF0aW9uLnVwZGF0ZVRpbWVzdGFtcChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBjYWNoZUV4cGlyYXRpb24uZXhwaXJlRW50cmllcygpO1xuICAgICAgICB9KSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZlbnQud2FpdFVudGlsKGRvbmUpO1xuICAgICAgICB9IGNhdGNoICB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRmV0Y2hFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVW5hYmxlIHRvIGVuc3VyZSBzZXJ2aWNlIHdvcmtlciBzdGF5cyBhbGl2ZSB3aGVuIHVwZGF0aW5nIGNhY2hlIGVudHJ5IGZvciAnJHtnZXRGcmllbmRseVVSTChldmVudC5yZXF1ZXN0LnVybCl9Jy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzRnJlc2ggPyBjYWNoZWRSZXNwb25zZSA6IG51bGw7XG4gICAgfVxuICAgIF9pc1Jlc3BvbnNlRGF0ZUZyZXNoKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnN0IGlzTWF4QWdlRnJvbUxhc3RVc2VkID0gdGhpcy5fY29uZmlnLm1heEFnZUZyb20gPT09IFwibGFzdC11c2VkXCI7XG4gICAgICAgIGlmIChpc01heEFnZUZyb21MYXN0VXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcubWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZUhlYWRlclRpbWVzdGFtcCA9IHRoaXMuX2dldERhdGVIZWFkZXJUaW1lc3RhbXAoY2FjaGVkUmVzcG9uc2UpO1xuICAgICAgICBpZiAoZGF0ZUhlYWRlclRpbWVzdGFtcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVIZWFkZXJUaW1lc3RhbXAgPj0gbm93IC0gdGhpcy5fY29uZmlnLm1heEFnZVNlY29uZHMgKiAxMDAwO1xuICAgIH1cbiAgICBfZ2V0RGF0ZUhlYWRlclRpbWVzdGFtcChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICBpZiAoIWNhY2hlZFJlc3BvbnNlLmhlYWRlcnMuaGFzKFwiZGF0ZVwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0ZUhlYWRlciA9IGNhY2hlZFJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiZGF0ZVwiKTtcbiAgICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGVIZWFkZXIpO1xuICAgICAgICBjb25zdCBoZWFkZXJUaW1lID0gcGFyc2VkRGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaGVhZGVyVGltZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJUaW1lO1xuICAgIH1cbiAgICBhc3luYyBjYWNoZURpZFVwZGF0ZSh7IGNhY2hlTmFtZSwgcmVxdWVzdCB9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUoY2FjaGVOYW1lLCBcInN0cmluZ1wiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlBsdWdpblwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNhY2hlRGlkVXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImNhY2hlTmFtZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc0luc3RhbmNlKHJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiUGx1Z2luXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY2FjaGVEaWRVcGRhdGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZUV4cGlyYXRpb24gPSB0aGlzLl9nZXRDYWNoZUV4cGlyYXRpb24oY2FjaGVOYW1lKTtcbiAgICAgICAgYXdhaXQgY2FjaGVFeHBpcmF0aW9uLnVwZGF0ZVRpbWVzdGFtcChyZXF1ZXN0LnVybCk7XG4gICAgICAgIGF3YWl0IGNhY2hlRXhwaXJhdGlvbi5leHBpcmVFbnRyaWVzKCk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUNhY2hlQW5kTWV0YWRhdGEoKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2NhY2hlTmFtZSwgY2FjaGVFeHBpcmF0aW9uXSBvZiB0aGlzLl9jYWNoZUV4cGlyYXRpb25zKXtcbiAgICAgICAgICAgIGF3YWl0IHNlbGYuY2FjaGVzLmRlbGV0ZShjYWNoZU5hbWUpO1xuICAgICAgICAgICAgYXdhaXQgY2FjaGVFeHBpcmF0aW9uLmRlbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhY2hlRXhwaXJhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgfVxufVxuXG5jb25zdCBjYWxjdWxhdGVFZmZlY3RpdmVCb3VuZGFyaWVzID0gKGJsb2IsIHN0YXJ0LCBlbmQpPT57XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNJbnN0YW5jZShibG9iLCBCbG9iLCB7XG4gICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3JhbmdlLXJlcXVlc3RzXCIsXG4gICAgICAgICAgICBmdW5jTmFtZTogXCJjYWxjdWxhdGVFZmZlY3RpdmVCb3VuZGFyaWVzXCIsXG4gICAgICAgICAgICBwYXJhbU5hbWU6IFwiYmxvYlwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBibG9iU2l6ZSA9IGJsb2Iuc2l6ZTtcbiAgICBpZiAoZW5kICYmIGVuZCA+IGJsb2JTaXplIHx8IHN0YXJ0ICYmIHN0YXJ0IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwicmFuZ2Utbm90LXNhdGlzZmlhYmxlXCIsIHtcbiAgICAgICAgICAgIHNpemU6IGJsb2JTaXplLFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgc3RhcnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBlZmZlY3RpdmVTdGFydDtcbiAgICBsZXQgZWZmZWN0aXZlRW5kO1xuICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkICYmIGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVmZmVjdGl2ZVN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGVmZmVjdGl2ZUVuZCA9IGVuZCArIDE7XG4gICAgfSBlbHNlIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVmZmVjdGl2ZVN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGVmZmVjdGl2ZUVuZCA9IGJsb2JTaXplO1xuICAgIH0gZWxzZSBpZiAoZW5kICE9PSB1bmRlZmluZWQgJiYgc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlZmZlY3RpdmVTdGFydCA9IGJsb2JTaXplIC0gZW5kO1xuICAgICAgICBlZmZlY3RpdmVFbmQgPSBibG9iU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGVmZmVjdGl2ZVN0YXJ0LFxuICAgICAgICBlbmQ6IGVmZmVjdGl2ZUVuZFxuICAgIH07XG59O1xuXG5jb25zdCBwYXJzZVJhbmdlSGVhZGVyID0gKHJhbmdlSGVhZGVyKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShyYW5nZUhlYWRlciwgXCJzdHJpbmdcIiwge1xuICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9yYW5nZS1yZXF1ZXN0c1wiLFxuICAgICAgICAgICAgZnVuY05hbWU6IFwicGFyc2VSYW5nZUhlYWRlclwiLFxuICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJhbmdlSGVhZGVyXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRSYW5nZUhlYWRlciA9IHJhbmdlSGVhZGVyLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghbm9ybWFsaXplZFJhbmdlSGVhZGVyLnN0YXJ0c1dpdGgoXCJieXRlcz1cIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcInVuaXQtbXVzdC1iZS1ieXRlc1wiLCB7XG4gICAgICAgICAgICBub3JtYWxpemVkUmFuZ2VIZWFkZXJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkUmFuZ2VIZWFkZXIuaW5jbHVkZXMoXCIsXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJzaW5nbGUtcmFuZ2Utb25seVwiLCB7XG4gICAgICAgICAgICBub3JtYWxpemVkUmFuZ2VIZWFkZXJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlUGFydHMgPSAvKFxcZCopLShcXGQqKS8uZXhlYyhub3JtYWxpemVkUmFuZ2VIZWFkZXIpO1xuICAgIGlmICghcmFuZ2VQYXJ0cyB8fCAhKHJhbmdlUGFydHNbMV0gfHwgcmFuZ2VQYXJ0c1syXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImludmFsaWQtcmFuZ2UtdmFsdWVzXCIsIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRSYW5nZUhlYWRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHJhbmdlUGFydHNbMV0gPT09IFwiXCIgPyB1bmRlZmluZWQgOiBOdW1iZXIocmFuZ2VQYXJ0c1sxXSksXG4gICAgICAgIGVuZDogcmFuZ2VQYXJ0c1syXSA9PT0gXCJcIiA/IHVuZGVmaW5lZCA6IE51bWJlcihyYW5nZVBhcnRzWzJdKVxuICAgIH07XG59O1xuXG5jb25zdCBjcmVhdGVQYXJ0aWFsUmVzcG9uc2UgPSBhc3luYyAocmVxdWVzdCwgb3JpZ2luYWxSZXNwb25zZSk9PntcbiAgICB0cnkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9yYW5nZS1yZXF1ZXN0c1wiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNyZWF0ZVBhcnRpYWxSZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyZXF1ZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzSW5zdGFuY2Uob3JpZ2luYWxSZXNwb25zZSwgUmVzcG9uc2UsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3JhbmdlLXJlcXVlc3RzXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY3JlYXRlUGFydGlhbFJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm9yaWdpbmFsUmVzcG9uc2VcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbmFsUmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzLmdldChcInJhbmdlXCIpO1xuICAgICAgICBpZiAoIXJhbmdlSGVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm8tcmFuZ2UtaGVhZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvdW5kYXJpZXMgPSBwYXJzZVJhbmdlSGVhZGVyKHJhbmdlSGVhZGVyKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxCbG9iID0gYXdhaXQgb3JpZ2luYWxSZXNwb25zZS5ibG9iKCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZUJvdW5kYXJpZXMgPSBjYWxjdWxhdGVFZmZlY3RpdmVCb3VuZGFyaWVzKG9yaWdpbmFsQmxvYiwgYm91bmRhcmllcy5zdGFydCwgYm91bmRhcmllcy5lbmQpO1xuICAgICAgICBjb25zdCBzbGljZWRCbG9iID0gb3JpZ2luYWxCbG9iLnNsaWNlKGVmZmVjdGl2ZUJvdW5kYXJpZXMuc3RhcnQsIGVmZmVjdGl2ZUJvdW5kYXJpZXMuZW5kKTtcbiAgICAgICAgY29uc3Qgc2xpY2VkQmxvYlNpemUgPSBzbGljZWRCbG9iLnNpemU7XG4gICAgICAgIGNvbnN0IHNsaWNlZFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHNsaWNlZEJsb2IsIHtcbiAgICAgICAgICAgIHN0YXR1czogMjA2LFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IG9yaWdpbmFsUmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgc2xpY2VkUmVzcG9uc2UuaGVhZGVycy5zZXQoXCJDb250ZW50LUxlbmd0aFwiLCBTdHJpbmcoc2xpY2VkQmxvYlNpemUpKTtcbiAgICAgICAgc2xpY2VkUmVzcG9uc2UuaGVhZGVycy5zZXQoXCJDb250ZW50LVJhbmdlXCIsIGBieXRlcyAke2VmZmVjdGl2ZUJvdW5kYXJpZXMuc3RhcnR9LSR7ZWZmZWN0aXZlQm91bmRhcmllcy5lbmQgLSAxfS9gICsgYCR7b3JpZ2luYWxCbG9iLnNpemV9YCk7XG4gICAgICAgIHJldHVybiBzbGljZWRSZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIlVuYWJsZSB0byBjb25zdHJ1Y3QgYSBwYXJ0aWFsIHJlc3BvbnNlOyByZXR1cm5pbmcgYSBcIiArIFwiNDE2IFJhbmdlIE5vdCBTYXRpc2ZpYWJsZSByZXNwb25zZSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChcIlZpZXcgZGV0YWlscyBoZXJlLlwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coZXJyb3IpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhyZXF1ZXN0KTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cob3JpZ2luYWxSZXNwb25zZSk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiXCIsIHtcbiAgICAgICAgICAgIHN0YXR1czogNDE2LFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIlxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5jbGFzcyBSYW5nZVJlcXVlc3RzUGx1Z2luIHtcbiAgICBjYWNoZWRSZXNwb25zZVdpbGxCZVVzZWQgPSBhc3luYyAoeyByZXF1ZXN0LCBjYWNoZWRSZXNwb25zZSB9KT0+e1xuICAgICAgICBpZiAoY2FjaGVkUmVzcG9uc2UgJiYgcmVxdWVzdC5oZWFkZXJzLmhhcyhcInJhbmdlXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgY3JlYXRlUGFydGlhbFJlc3BvbnNlKHJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzcG9uc2U7XG4gICAgfTtcbn1cblxuY2xhc3MgQ2FjaGVGaXJzdCBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgbG9ncyA9IFtdO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwibWFrZVJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxvZ3MucHVzaChgTm8gcmVzcG9uc2UgZm91bmQgaW4gdGhlICcke3RoaXMuY2FjaGVOYW1lfScgY2FjaGUuIFdpbGwgcmVzcG9uZCB3aXRoIGEgbmV0d29yayByZXF1ZXN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuZmV0Y2hBbmRDYWNoZVB1dChyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChcIkdvdCByZXNwb25zZSBmcm9tIG5ldHdvcmsuXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChcIlVuYWJsZSB0byBnZXQgYSByZXNwb25zZSBmcm9tIHRoZSBuZXR3b3JrLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBGb3VuZCBhIGNhY2hlZCByZXNwb25zZSBpbiB0aGUgJyR7dGhpcy5jYWNoZU5hbWV9JyBjYWNoZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZXMuc3RyYXRlZ3lTdGFydCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3Mpe1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2cobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2VzLnByaW50RmluYWxSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5cbmNsYXNzIENhY2hlT25seSBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcIm1ha2VSZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJlcXVlc3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChtZXNzYWdlcy5zdHJhdGVneVN0YXJ0KHRoaXMuY29uc3RydWN0b3IubmFtZSwgcmVxdWVzdCkpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgRm91bmQgYSBjYWNoZWQgcmVzcG9uc2UgaW4gdGhlICcke3RoaXMuY2FjaGVOYW1lfScgY2FjaGUuYCk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXMucHJpbnRGaW5hbFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTm8gcmVzcG9uc2UgZm91bmQgaW4gdGhlICcke3RoaXMuY2FjaGVOYW1lfScgY2FjaGUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5cbmNsYXNzIFN0YWxlV2hpbGVSZXZhbGlkYXRlIGV4dGVuZHMgU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMucGx1Z2lucy5zb21lKChwKT0+XCJjYWNoZVdpbGxVcGRhdGVcIiBpbiBwKSkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zLnVuc2hpZnQoY2FjaGVPa0FuZE9wYXF1ZVBsdWdpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZShyZXF1ZXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGxvZ3MgPSBbXTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImhhbmRsZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyZXF1ZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZldGNoQW5kQ2FjaGVQcm9taXNlID0gaGFuZGxlci5mZXRjaEFuZENhY2hlUHV0KHJlcXVlc3QpLmNhdGNoKCgpPT57fSk7XG4gICAgICAgIHZvaWQgaGFuZGxlci53YWl0VW50aWwoZmV0Y2hBbmRDYWNoZVByb21pc2UpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBGb3VuZCBhIGNhY2hlZCByZXNwb25zZSBpbiB0aGUgJyR7dGhpcy5jYWNoZU5hbWV9JyBjYWNoZS4gV2lsbCB1cGRhdGUgd2l0aCB0aGUgbmV0d29yayByZXNwb25zZSBpbiB0aGUgYmFja2dyb3VuZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dzLnB1c2goYE5vIHJlc3BvbnNlIGZvdW5kIGluIHRoZSAnJHt0aGlzLmNhY2hlTmFtZX0nIGNhY2hlLiBXaWxsIHdhaXQgZm9yIHRoZSBuZXR3b3JrIHJlc3BvbnNlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kQ2FjaGVQcm9taXNlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZXMuc3RyYXRlZ3lTdGFydCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3Mpe1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2cobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2VzLnByaW50RmluYWxSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJST0FEQ0FTVF9VUERBVEVfREVGQVVMVF9IRUFERVJTLCBCYWNrZ3JvdW5kU3luY1BsdWdpbiwgQnJvYWRjYXN0Q2FjaGVVcGRhdGUsIEJyb2FkY2FzdFVwZGF0ZVBsdWdpbiwgQ2FjaGVFeHBpcmF0aW9uLCBDYWNoZUZpcnN0LCBDYWNoZU9ubHksIENhY2hlYWJsZVJlc3BvbnNlLCBDYWNoZWFibGVSZXNwb25zZVBsdWdpbiwgRXhwaXJhdGlvblBsdWdpbiwgTmF2aWdhdGlvblJvdXRlLCBOZXR3b3JrRmlyc3QsIE5ldHdvcmtPbmx5LCBQcmVjYWNoZUZhbGxiYWNrUGx1Z2luLCBQcmVjYWNoZVJvdXRlLCBQcmVjYWNoZVN0cmF0ZWd5LCBSYW5nZVJlcXVlc3RzUGx1Z2luLCBSb3V0ZSwgU2Vyd2lzdCwgU3RhbGVXaGlsZVJldmFsaWRhdGUsIFN0cmF0ZWd5LCBjYWNoZU5hbWVzLCBjcmVhdGVQYXJ0aWFsUmVzcG9uc2UsIGRpc2FibGVEZXZMb2dzLCBlbmFibGVOYXZpZ2F0aW9uUHJlbG9hZCwgaW5pdGlhbGl6ZUdvb2dsZUFuYWx5dGljcywgcmVnaXN0ZXJRdW90YUVycm9yQ2FsbGJhY2ssIHJlc3BvbnNlc0FyZVNhbWUsIHNldENhY2hlTmFtZURldGFpbHMgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/serwist/dist/index.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	(() => {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = () => {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: (script) => (script)
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	(() => {
/******/ 		__webpack_require__.ts = (script) => (__webpack_require__.tt().createScript(script));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	(() => {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push((options) => {
/******/ 			const originalFactory = options.factory;
/******/ 			options.factory = (moduleObject, moduleExports, webpackRequire) => {
/******/ 				const hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				const cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : () => {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app/sw.ts");
/******/ 	
/******/ })()
;